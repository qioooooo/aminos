AudioBitsPerSample.cs

using System;

namespace System.Speech.AudioFormat
{
	public enum AudioBitsPerSample
	{
		Eight = 8,
		Sixteen = 16
	}
}

AudioChannel.cs

using System;

namespace System.Speech.AudioFormat
{
	public enum AudioChannel
	{
		Mono = 1,
		Stereo
	}
}

EncodingFormat.cs

using System;

namespace System.Speech.AudioFormat
{
	public enum EncodingFormat
	{
		Pcm = 1,
		ALaw = 6,
		ULaw
	}
}


SpeechAudioFormatInfo.cs

using System;
using System.ComponentModel;
using System.Speech.Internal.Synthesis;

namespace System.Speech.AudioFormat
{
	[Serializable]
	public class SpeechAudioFormatInfo
	{
		private SpeechAudioFormatInfo(EncodingFormat encodingFormat, int samplesPerSecond, short bitsPerSample, short channelCount, byte[] formatSpecificData)
		{
			if (encodingFormat == (EncodingFormat)0)
			{
				throw new ArgumentException(SR.Get(SRID.CannotUseCustomFormat, new object[0]), "encodingFormat");
			}
			if (samplesPerSecond <= 0)
			{
				throw new ArgumentOutOfRangeException("samplesPerSecond", SR.Get(SRID.MustBeGreaterThanZero, new object[0]));
			}
			if (bitsPerSample <= 0)
			{
				throw new ArgumentOutOfRangeException("bitsPerSample", SR.Get(SRID.MustBeGreaterThanZero, new object[0]));
			}
			if (channelCount <= 0)
			{
				throw new ArgumentOutOfRangeException("channelCount", SR.Get(SRID.MustBeGreaterThanZero, new object[0]));
			}
			this._encodingFormat = encodingFormat;
			this._samplesPerSecond = samplesPerSecond;
			this._bitsPerSample = bitsPerSample;
			this._channelCount = channelCount;
			if (formatSpecificData == null)
			{
				this._formatSpecificData = new byte[0];
			}
			else
			{
				this._formatSpecificData = (byte[])formatSpecificData.Clone();
			}
			switch (encodingFormat)
			{
			case EncodingFormat.ALaw:
			case EncodingFormat.ULaw:
				if (bitsPerSample != 8)
				{
					throw new ArgumentOutOfRangeException("bitsPerSample");
				}
				if (formatSpecificData != null && formatSpecificData.Length != 0)
				{
					throw new ArgumentOutOfRangeException("formatSpecificData");
				}
				return;
			default:
				return;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SpeechAudioFormatInfo(EncodingFormat encodingFormat, int samplesPerSecond, int bitsPerSample, int channelCount, int averageBytesPerSecond, int blockAlign, byte[] formatSpecificData)
			: this(encodingFormat, samplesPerSecond, (short)bitsPerSample, (short)channelCount, formatSpecificData)
		{
			if (averageBytesPerSecond <= 0)
			{
				throw new ArgumentOutOfRangeException("averageBytesPerSecond", SR.Get(SRID.MustBeGreaterThanZero, new object[0]));
			}
			if (blockAlign <= 0)
			{
				throw new ArgumentOutOfRangeException("blockAlign", SR.Get(SRID.MustBeGreaterThanZero, new object[0]));
			}
			this._averageBytesPerSecond = averageBytesPerSecond;
			this._blockAlign = (short)blockAlign;
		}

		public SpeechAudioFormatInfo(int samplesPerSecond, AudioBitsPerSample bitsPerSample, AudioChannel channel)
			: this(EncodingFormat.Pcm, samplesPerSecond, (short)bitsPerSample, (short)channel, null)
		{
			this._blockAlign = this._channelCount * (this._bitsPerSample / 8);
			this._averageBytesPerSecond = this._samplesPerSecond * (int)this._blockAlign;
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int AverageBytesPerSecond
		{
			get
			{
				return this._averageBytesPerSecond;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int BitsPerSample
		{
			get
			{
				return (int)this._bitsPerSample;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int BlockAlign
		{
			get
			{
				return (int)this._blockAlign;
			}
		}

		public EncodingFormat EncodingFormat
		{
			get
			{
				return this._encodingFormat;
			}
		}

		public int ChannelCount
		{
			get
			{
				return (int)this._channelCount;
			}
		}

		public int SamplesPerSecond
		{
			get
			{
				return this._samplesPerSecond;
			}
		}
		public byte[] FormatSpecificData()
		{
			return (byte[])this._formatSpecificData.Clone();
		}
		public override bool Equals(object obj)
		{
			SpeechAudioFormatInfo speechAudioFormatInfo = obj as SpeechAudioFormatInfo;
			if (speechAudioFormatInfo == null)
			{
				return false;
			}
			if (!this._averageBytesPerSecond.Equals(speechAudioFormatInfo._averageBytesPerSecond) || !this._bitsPerSample.Equals(speechAudioFormatInfo._bitsPerSample) || !this._blockAlign.Equals(speechAudioFormatInfo._blockAlign) || !this._encodingFormat.Equals(speechAudioFormatInfo._encodingFormat) || !this._channelCount.Equals(speechAudioFormatInfo._channelCount) || !this._samplesPerSecond.Equals(speechAudioFormatInfo._samplesPerSecond))
			{
				return false;
			}
			if (this._formatSpecificData.Length != speechAudioFormatInfo._formatSpecificData.Length)
			{
				return false;
			}
			for (int i = 0; i < this._formatSpecificData.Length; i++)
			{
				if (this._formatSpecificData[i] != speechAudioFormatInfo._formatSpecificData[i])
				{
					return false;
				}
			}
			return true;
		}
		public override int GetHashCode()
		{
			return this._averageBytesPerSecond.GetHashCode();
		}
		internal byte[] WaveFormat
		{
			get
			{
				WAVEFORMATEX waveformatex = default(WAVEFORMATEX);
				waveformatex.wFormatTag = (short)this.EncodingFormat;
				waveformatex.nChannels = (short)this.ChannelCount;
				waveformatex.nSamplesPerSec = this.SamplesPerSecond;
				waveformatex.nAvgBytesPerSec = this.AverageBytesPerSecond;
				waveformatex.nBlockAlign = (short)this.BlockAlign;
				waveformatex.wBitsPerSample = (short)this.BitsPerSample;
				waveformatex.cbSize = (short)this.FormatSpecificData().Length;
				byte[] array = waveformatex.ToBytes();
				if (waveformatex.cbSize > 0)
				{
					byte[] array2 = new byte[array.Length + (int)waveformatex.cbSize];
					Array.Copy(array, array2, array.Length);
					Array.Copy(this.FormatSpecificData(), 0, array2, array.Length, (int)waveformatex.cbSize);
					array = array2;
				}
				return array;
			}
		}
		private int _averageBytesPerSecond;
		private short _bitsPerSample;
		private short _blockAlign;
		private EncodingFormat _encodingFormat;
		private short _channelCount;
		private int _samplesPerSecond;
		private byte[] _formatSpecificData;
	}
}

BuilderElements.cs

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Speech.Internal.SrgsParser;
using System.Speech.Recognition;
using System.Text;

namespace System.Speech.Internal.GrammarBuilding
{
	internal abstract class BuilderElements : GrammarBuilderBase
	{
		internal BuilderElements()
		{
		}
		public override bool Equals(object obj)
		{
			BuilderElements builderElements = obj as BuilderElements;
			if (builderElements == null)
			{
				return false;
			}
			if (builderElements.Count != this.Count || builderElements.Items.Count != this.Items.Count)
			{
				return false;
			}
			for (int i = 0; i < this.Items.Count; i++)
			{
				if (!this.Items[i].Equals(builderElements.Items[i]))
				{
					return false;
				}
			}
			return true;
		}
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
		protected void Optimize(Collection<RuleElement> newRules)
		{
			SortedDictionary<int, Collection<BuilderElements>> sortedDictionary = new SortedDictionary<int, Collection<BuilderElements>>();
			this.GetDictionaryElements(sortedDictionary);
			int[] array = new int[sortedDictionary.Keys.Count];
			int num = array.Length - 1;
			foreach (int num2 in sortedDictionary.Keys)
			{
				array[num--] = num2;
			}
			int num3 = 0;
			while (num3 < array.Length && array[num3] >= 3)
			{
				Collection<BuilderElements> collection = sortedDictionary[array[num3]];
				for (int i = 0; i < collection.Count; i++)
				{
					RuleElement ruleElement = null;
					RuleRefElement ruleRefElement = null;
					for (int j = i + 1; j < collection.Count; j++)
					{
						if (collection[i] != null && collection[i].Equals(collection[j]))
						{
							BuilderElements builderElements = collection[j];
							BuilderElements parent = builderElements.Parent;
							if (builderElements is SemanticKeyElement)
							{
								parent.Items[parent.Items.IndexOf(builderElements)] = collection[i];
							}
							else
							{
								if (ruleElement == null)
								{
									ruleElement = new RuleElement(builderElements, "_");
									newRules.Add(ruleElement);
								}
								if (ruleRefElement == null)
								{
									ruleRefElement = new RuleRefElement(ruleElement);
									collection[i].Parent.Items[collection[i].Parent.Items.IndexOf(collection[i])] = ruleRefElement;
								}
								parent.Items[builderElements.Parent.Items.IndexOf(builderElements)] = ruleRefElement;
							}
							builderElements.RemoveDictionaryElements(sortedDictionary);
							collection[j] = null;
						}
					}
				}
				num3++;
			}
		}
		internal void Add(string phrase)
		{
			this._items.Add(new GrammarBuilderPhrase(phrase));
		}
		internal void Add(GrammarBuilder builder)
		{
			foreach (GrammarBuilderBase grammarBuilderBase in builder.InternalBuilder.Items)
			{
				this._items.Add(grammarBuilderBase);
			}
		}
		internal void Add(GrammarBuilderBase item)
		{
			this._items.Add(item);
		}
		internal void CloneItems(BuilderElements builders)
		{
			foreach (GrammarBuilderBase grammarBuilderBase in builders.Items)
			{
				this._items.Add(grammarBuilderBase);
			}
		}
		internal void CreateChildrenElements(IElementFactory elementFactory, IRule parent, IdentifierCollection ruleIds)
		{
			foreach (GrammarBuilderBase grammarBuilderBase in this.Items)
			{
				IElement element = grammarBuilderBase.CreateElement(elementFactory, parent, parent, ruleIds);
				if (element != null)
				{
					element.PostParse(parent);
					elementFactory.AddElement(parent, element);
				}
			}
		}
		internal void CreateChildrenElements(IElementFactory elementFactory, IItem parent, IRule rule, IdentifierCollection ruleIds)
		{
			foreach (GrammarBuilderBase grammarBuilderBase in this.Items)
			{
				IElement element = grammarBuilderBase.CreateElement(elementFactory, parent, rule, ruleIds);
				if (element != null)
				{
					element.PostParse(parent);
					elementFactory.AddElement(parent, element);
				}
			}
		}
		internal override int CalcCount(BuilderElements parent)
		{
			base.CalcCount(parent);
			int num = 1;
			foreach (GrammarBuilderBase grammarBuilderBase in this.Items)
			{
				num += grammarBuilderBase.CalcCount(this);
			}
			this.Count = num;
			return num;
		}
		internal List<GrammarBuilderBase> Items
		{
			get
			{
				return this._items;
			}
		}
		internal override string DebugSummary
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				foreach (GrammarBuilderBase grammarBuilderBase in this._items)
				{
					if (stringBuilder.Length > 0)
					{
						stringBuilder.Append(" ");
					}
					stringBuilder.Append(grammarBuilderBase.DebugSummary);
				}
				return stringBuilder.ToString();
			}
		}
		private void GetDictionaryElements(SortedDictionary<int, Collection<BuilderElements>> dict)
		{
			foreach (GrammarBuilderBase grammarBuilderBase in this.Items)
			{
				BuilderElements builderElements = grammarBuilderBase as BuilderElements;
				if (builderElements != null)
				{
					if (!dict.ContainsKey(builderElements.Count))
					{
						dict.Add(builderElements.Count, new Collection<BuilderElements>());
					}
					dict[builderElements.Count].Add(builderElements);
					builderElements.GetDictionaryElements(dict);
				}
			}
		}
		private void RemoveDictionaryElements(SortedDictionary<int, Collection<BuilderElements>> dict)
		{
			foreach (GrammarBuilderBase grammarBuilderBase in this.Items)
			{
				BuilderElements builderElements = grammarBuilderBase as BuilderElements;
				if (builderElements != null)
				{
					builderElements.RemoveDictionaryElements(dict);
					dict[builderElements.Count].Remove(builderElements);
				}
			}
		}
		private readonly List<GrammarBuilderBase> _items = new List<GrammarBuilderBase>();
	}
}

GrammarBuilderBase.cs

using System;
using System.Speech.Internal.SrgsParser;

namespace System.Speech.Internal.GrammarBuilding
{
	internal abstract class GrammarBuilderBase
	{
		internal abstract GrammarBuilderBase Clone();
		internal abstract IElement CreateElement(IElementFactory elementFactory, IElement parent, IRule rule, IdentifierCollection ruleIds);
		internal virtual int CalcCount(BuilderElements parent)
		{
			this.Marked = false;
			this.Parent = parent;
			return this.Count;
		}
		internal virtual int Count
		{
			get
			{
				return this._count;
			}
			set
			{
				this._count = value;
			}
		}
		internal virtual bool Marked
		{
			get
			{
				return this._marker;
			}
			set
			{
				this._marker = value;
			}
		}
		internal virtual BuilderElements Parent
		{
			get
			{
				return this._parent;
			}
			set
			{
				this._parent = value;
			}
		}
		internal abstract string DebugSummary { get; }
		private int _count = 1;
		private bool _marker;
		private BuilderElements _parent;
	}
}

GrammarBuilderPhrase.cs

using System;
using System.Speech.Internal.SrgsCompiler;
using System.Speech.Internal.SrgsParser;
using System.Speech.Recognition;

namespace System.Speech.Internal.GrammarBuilding
{
	internal sealed class GrammarBuilderPhrase : GrammarBuilderBase
	{
		internal GrammarBuilderPhrase(string phrase)
			: this(phrase, false, SubsetMatchingMode.OrderedSubset)
		{
		}
		internal GrammarBuilderPhrase(string phrase, SubsetMatchingMode subsetMatchingCriteria)
			: this(phrase, true, subsetMatchingCriteria)
		{
		}
		private GrammarBuilderPhrase(string phrase, bool subsetMatching, SubsetMatchingMode subsetMatchingCriteria)
		{
			this._phrase = string.Copy(phrase);
			this._subsetMatching = subsetMatching;
			switch (subsetMatchingCriteria)
			{
			case SubsetMatchingMode.Subsequence:
				this._matchMode = MatchMode.Subsequence;
				return;
			case SubsetMatchingMode.OrderedSubset:
				this._matchMode = MatchMode.OrderedSubset;
				return;
			case SubsetMatchingMode.SubsequenceContentRequired:
				this._matchMode = MatchMode.SubsequenceContentRequired;
				return;
			case SubsetMatchingMode.OrderedSubsetContentRequired:
				this._matchMode = MatchMode.OrderedSubsetContentRequired;
				return;
			default:
				return;
			}
		}
		private GrammarBuilderPhrase(string phrase, bool subsetMatching, MatchMode matchMode)
		{
			this._phrase = string.Copy(phrase);
			this._subsetMatching = subsetMatching;
			this._matchMode = matchMode;
		}
		public override bool Equals(object obj)
		{
			GrammarBuilderPhrase grammarBuilderPhrase = obj as GrammarBuilderPhrase;
			return grammarBuilderPhrase != null && (this._phrase == grammarBuilderPhrase._phrase && this._matchMode == grammarBuilderPhrase._matchMode) && this._subsetMatching == grammarBuilderPhrase._subsetMatching;
		}
		public override int GetHashCode()
		{
			return this._phrase.GetHashCode();
		}
		internal override GrammarBuilderBase Clone()
		{
			return new GrammarBuilderPhrase(this._phrase, this._subsetMatching, this._matchMode);
		}
		internal override IElement CreateElement(IElementFactory elementFactory, IElement parent, IRule rule, IdentifierCollection ruleIds)
		{
			return this.CreatePhraseElement(elementFactory, parent);
		}
		internal override string DebugSummary
		{
			get
			{
				return "‘" + this._phrase + "’";
			}
		}
		private IElement CreatePhraseElement(IElementFactory elementFactory, IElement parent)
		{
			if (this._subsetMatching)
			{
				return elementFactory.CreateSubset(parent, this._phrase, this._matchMode);
			}
			if (elementFactory is SrgsElementCompilerFactory)
			{
				XmlParser.ParseText(parent, this._phrase, null, null, -1f, new CreateTokenCallback(elementFactory.CreateToken));
				return null;
			}
			return elementFactory.CreateText(parent, this._phrase);
		}
		private readonly string _phrase;
		private readonly bool _subsetMatching;
		private readonly MatchMode _matchMode;
	}
}


RuleElement.cs

using System;
using System.Speech.Internal.SrgsParser;

namespace System.Speech.Internal.GrammarBuilding
{
	internal sealed class RuleElement : BuilderElements
	{
		internal RuleElement(string name)
		{
			this._name = name;
		}
		internal RuleElement(GrammarBuilderBase builder, string name)
			: this(name)
		{
			base.Add(builder);
		}
		public override bool Equals(object obj)
		{
			RuleElement ruleElement = obj as RuleElement;
			return ruleElement != null && base.Equals(obj) && this._name == ruleElement._name;
		}
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
		internal override GrammarBuilderBase Clone()
		{
			RuleElement ruleElement = new RuleElement(this._name);
			ruleElement.CloneItems(this);
			return ruleElement;
		}
		internal override IElement CreateElement(IElementFactory elementFactory, IElement parent, IRule rule, IdentifierCollection ruleIds)
		{
			if (this._rule == null)
			{
				IGrammar grammar = elementFactory.Grammar;
				this._ruleName = ruleIds.CreateNewIdentifier(this.Name);
				this._rule = grammar.CreateRule(this._ruleName, RulePublic.False, RuleDynamic.NotSet, false);
				base.CreateChildrenElements(elementFactory, this._rule, ruleIds);
				this._rule.PostParse(grammar);
			}
			return this._rule;
		}
		internal override int CalcCount(BuilderElements parent)
		{
			this._rule = null;
			return base.CalcCount(parent);
		}
		internal override string DebugSummary
		{
			get
			{
				return this._name + "=" + base.DebugSummary;
			}
		}
		internal string Name
		{
			get
			{
				return this._name;
			}
		}
		internal string RuleName
		{
			get
			{
				return this._ruleName;
			}
		}
		private readonly string _name;
		private string _ruleName;
		private IRule _rule;
	}
}

ObjectToken.cs

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Speech.Internal.SapiInterop;
using System.Text;

namespace System.Speech.Internal.ObjectTokens
{
	internal class ObjectToken : RegistryDataKey, ISpObjectToken, ISpDataKey
	{
		protected ObjectToken(ISpObjectToken sapiObjectToken, bool disposeSapiToken)
			: base(sapiObjectToken)
		{
			if (sapiObjectToken == null)
			{
				throw new ArgumentNullException("sapiObjectToken");
			}
			this._sapiObjectToken = sapiObjectToken;
			this._disposeSapiObjectToken = disposeSapiToken;
		}
		internal static ObjectToken FindBestMatch(string categoryId, string requiredAttributes, string optionalAttributes)
		{
			if (string.IsNullOrEmpty(categoryId))
			{
				throw new ArgumentNullException("categoryId");
			}
			ObjectToken objectToken;
			using (ObjectTokenCategory objectTokenCategory = ObjectTokenCategory.Create(categoryId))
			{
				if (objectTokenCategory != null)
				{
					StringBuilder stringBuilder = new StringBuilder(optionalAttributes);
					if (!string.IsNullOrEmpty(optionalAttributes))
					{
						stringBuilder.Append(";");
					}
					stringBuilder.Append("VendorPreferred");
					IList<ObjectToken> list = objectTokenCategory.FindMatchingTokens(requiredAttributes, stringBuilder.ToString());
					objectToken = ((list.Count > 0) ? list[0] : null);
				}
				else
				{
					objectToken = null;
				}
			}
			return objectToken;
		}
		internal static ObjectToken Open(ISpObjectToken sapiObjectToken)
		{
			return new ObjectToken(sapiObjectToken, false);
		}
		internal static ObjectToken Open(string sCategoryId, string sTokenId, bool fCreateIfNotExist)
		{
			ISpObjectToken spObjectToken = (ISpObjectToken)new SpObjectToken();
			try
			{
				spObjectToken.SetId(sCategoryId, sTokenId, fCreateIfNotExist);
			}
			catch (Exception)
			{
				Marshal.ReleaseComObject(spObjectToken);
				return null;
			}
			return new ObjectToken(spObjectToken, true);
		}
		internal static ObjectToken Create(string sCategoryId, string sTokenId)
		{
			return ObjectToken.Open(sCategoryId, sTokenId, true);
		}
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing)
				{
					if (this._disposeSapiObjectToken && this._sapiObjectToken != null)
					{
						Marshal.ReleaseComObject(this._sapiObjectToken);
						this._sapiObjectToken = null;
					}
					if (this._attributes != null)
					{
						this._attributes.Dispose();
						this._attributes = null;
					}
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}
		public override bool Equals(object obj)
		{
			ObjectToken objectToken = obj as ObjectToken;
			return objectToken != null && string.Compare(base.Id, objectToken.Id, StringComparison.OrdinalIgnoreCase) == 0;
		}
		public override int GetHashCode()
		{
			return base.Id.GetHashCode();
		}
		internal RegistryDataKey Attributes
		{
			get
			{
				if (this._attributes == null)
				{
					return this._attributes = base.OpenKey("Attributes");
				}
				return this._attributes;
			}
		}
		internal ISpObjectToken SAPIToken
		{
			get
			{
				return this._sapiObjectToken;
			}
		}
		internal string Age
		{
			get
			{
				string empty;
				if (this.Attributes == null || !this.Attributes.TryGetString("Age", out empty))
				{
					empty = string.Empty;
				}
				return empty;
			}
		}
		internal string Gender
		{
			get
			{
				string empty;
				if (this.Attributes == null || !this.Attributes.TryGetString("Gender", out empty))
				{
					empty = string.Empty;
				}
				return empty;
			}
		}
		internal VoiceCategory VoiceCategory
		{
			get
			{
				return this._category;
			}
			set
			{
				this._category = value;
			}
		}

		internal string TokenName()
		{
			string empty = string.Empty;
			if (this.Attributes != null)
			{
				this.Attributes.TryGetString("Name", out empty);
				if (string.IsNullOrEmpty(empty))
				{
					base.TryGetString(null, out empty);
				}
			}
			return empty;
		}
		internal CultureInfo Culture
		{
			get
			{
				CultureInfo cultureInfo = null;
				string text;
				if (this.Attributes.TryGetString("Language", out text))
				{
					cultureInfo = SapiAttributeParser.GetCultureInfoFromLanguageString(text);
				}
				return cultureInfo;
			}
		}
		internal string Description
		{
			get
			{
				string empty = string.Empty;
				string text = string.Format(CultureInfo.InvariantCulture, "{0:x}", new object[] { CultureInfo.CurrentUICulture.LCID });
				if (!base.TryGetString(text, out empty))
				{
					base.TryGetString(null, out empty);
				}
				return empty;
			}
		}
		public void SetId([MarshalAs(UnmanagedType.LPWStr)] string pszCategoryId, [MarshalAs(UnmanagedType.LPWStr)] string pszTokenId, [MarshalAs(UnmanagedType.Bool)] bool fCreateIfNotExist)
		{
			throw new NotImplementedException();
		}
		public void GetId([MarshalAs(UnmanagedType.LPWStr)] out IntPtr ppszCoMemTokenId)
		{
			ppszCoMemTokenId = Marshal.StringToCoTaskMemUni(base.Id);
		}
		public void Slot15()
		{
			throw new NotImplementedException();
		}
		public void Slot16()
		{
			throw new NotImplementedException();
		}
		public void Slot17()
		{
			throw new NotImplementedException();
		}
		public void Slot18()
		{
			throw new NotImplementedException();
		}
		public void Slot19()
		{
			throw new NotImplementedException();
		}
		public void Slot20()
		{
			throw new NotImplementedException();
		}
		public void Slot21()
		{
			throw new NotImplementedException();
		}
		public void MatchesAttributes([MarshalAs(UnmanagedType.LPWStr)] string pszAttributes, [MarshalAs(UnmanagedType.Bool)] out bool pfMatches)
		{
			throw new NotImplementedException();
		}
		internal bool MatchesAttributes(string[] sAttributes)
		{
			bool flag = true;
			foreach (string text in sAttributes)
			{
				flag &= base.HasValue(text) || (this.Attributes != null && this.Attributes.HasValue(text));
				if (!flag)
				{
					break;
				}
			}
			return flag;
		}
		internal T CreateObjectFromToken<T>(string name)
		{
			T t = default(T);
			string text;
			if (!base.TryGetString(name, out text))
			{
				throw new ArgumentException(SR.Get(SRID.TokenCannotCreateInstance, new object[0]));
			}
			try
			{
				Type typeFromCLSID = Type.GetTypeFromCLSID(new Guid(text));
				t = (T)((object)Activator.CreateInstance(typeFromCLSID));
				ObjectToken.ISpObjectWithToken spObjectWithToken = t as ObjectToken.ISpObjectWithToken;
				if (spObjectWithToken != null)
				{
					int num = spObjectWithToken.SetObjectToken(this);
					if (num < 0)
					{
						throw new ArgumentException(SR.Get(SRID.TokenCannotCreateInstance, new object[0]));
					}
				}
			}
			catch (Exception ex)
			{
				if (ex is MissingMethodException || ex is TypeLoadException || ex is FileLoadException || ex is FileNotFoundException || ex is MethodAccessException || ex is MemberAccessException || ex is TargetInvocationException || ex is InvalidComObjectException || ex is NotSupportedException || ex is FormatException)
				{
					throw new ArgumentException(SR.Get(SRID.TokenCannotCreateInstance, new object[0]));
				}
				throw;
			}
			return t;
		}
		private const string sGenerateFileNameSpecifier = "{0}";
		private const string SPTOKENVALUE_CLSID = "CLSID";
		private ISpObjectToken _sapiObjectToken;
		private bool _disposeSapiObjectToken;
		private VoiceCategory _category;
		private RegistryDataKey _attributes;
		[Guid("5B559F40-E952-11D2-BB91-00C04F8EE6C0")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		[ComImport]
		private interface ISpObjectWithToken
		{
			[PreserveSig]
			int SetObjectToken(ISpObjectToken pToken);
			[PreserveSig]
			int GetObjectToken(IntPtr ppToken);
		}
	}
}

ObjectTokenCategory.cs

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Speech.Internal.SapiInterop;
using Microsoft.Win32;

namespace System.Speech.Internal.ObjectTokens
{
	internal class ObjectTokenCategory : RegistryDataKey, IEnumerable<ObjectToken>, IEnumerable
	{
		protected ObjectTokenCategory(string keyId, RegistryKey hkey)
			: base(keyId, hkey)
		{
		}
		protected ObjectTokenCategory(string keyId, RegistryDataKey key)
			: base(keyId, key)
		{
		}
		internal static ObjectTokenCategory Create(string sCategoryId)
		{
			RegistryDataKey registryDataKey = RegistryDataKey.Open(sCategoryId, true);
			return new ObjectTokenCategory(sCategoryId, registryDataKey);
		}
		internal ObjectToken OpenToken(string keyName)
		{
			string text = keyName;
			if (!string.IsNullOrEmpty(text) && text.IndexOf("HKEY_", StringComparison.Ordinal) != 0)
			{
				text = string.Format(CultureInfo.InvariantCulture, "{0}\\Tokens\\{1}", new object[] { base.Id, text });
			}
			return ObjectToken.Open(null, text, false);
		}
		internal IList<ObjectToken> FindMatchingTokens(string requiredAttributes, string optionalAttributes)
		{
			IList<ObjectToken> list = new List<ObjectToken>();
			ISpObjectTokenCategory spObjectTokenCategory = null;
			IEnumSpObjectTokens enumSpObjectTokens = null;
			try
			{
				spObjectTokenCategory = (ISpObjectTokenCategory)new SpObjectTokenCategory();
				spObjectTokenCategory.SetId(this._sKeyId, false);
				spObjectTokenCategory.EnumTokens(requiredAttributes, optionalAttributes, out enumSpObjectTokens);
				uint num;
				enumSpObjectTokens.GetCount(out num);
				for (uint num2 = 0U; num2 < num; num2 += 1U)
				{
					ISpObjectToken spObjectToken = null;
					enumSpObjectTokens.Item(num2, out spObjectToken);
					ObjectToken objectToken = ObjectToken.Open(spObjectToken);
					list.Add(objectToken);
				}
			}
			finally
			{
				if (enumSpObjectTokens != null)
				{
					Marshal.ReleaseComObject(enumSpObjectTokens);
				}
				if (spObjectTokenCategory != null)
				{
					Marshal.ReleaseComObject(spObjectTokenCategory);
				}
			}
			return list;
		}
		IEnumerator<ObjectToken> IEnumerable<ObjectToken>.GetEnumerator()
		{
			ObjectTokenCategory.GetEnumerator>d__0 getEnumerator>d__ = new ObjectTokenCategory.GetEnumerator>d__0(0);
			getEnumerator>d__.<>4__this = this;
			return getEnumerator>d__;
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<ObjectToken>)this).GetEnumerator();
		}
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}
	}
}

RegistryDataKey.cs

using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Speech.Internal.SapiInterop;
using Microsoft.Win32;

namespace System.Speech.Internal.ObjectTokens
{
	internal class RegistryDataKey : ISpDataKey, IEnumerable<RegistryDataKey>, IEnumerable, IDisposable
	{
		protected RegistryDataKey(string fullPath, IntPtr regHandle)
		{
			ISpRegDataKey spRegDataKey = (ISpRegDataKey)new SpDataKey();
			spRegDataKey.SetKey(regHandle, false);
			this._sapiRegKey = spRegDataKey;
			this._sKeyId = fullPath;
			this._disposeSapiKey = true;
		}
		protected RegistryDataKey(string fullPath, RegistryKey managedRegKey)
			: this(fullPath, RegistryDataKey.HKEYfromRegKey(managedRegKey))
		{
		}
		protected RegistryDataKey(string fullPath, RegistryDataKey copyKey)
		{
			this._sKeyId = fullPath;
			this._sapiRegKey = copyKey._sapiRegKey;
			this._disposeSapiKey = copyKey._disposeSapiKey;
		}
		protected RegistryDataKey(string fullPath, ISpDataKey copyKey, bool shouldDispose)
		{
			this._sKeyId = fullPath;
			this._sapiRegKey = copyKey;
			this._disposeSapiKey = shouldDispose;
		}
		protected RegistryDataKey(ISpObjectToken sapiToken)
			: this(RegistryDataKey.GetTokenIdFromToken(sapiToken), sapiToken, false)
		{
		}
		internal static RegistryDataKey Open(string registryPath, bool fCreateIfNotExist)
		{
			if (string.IsNullOrEmpty(registryPath))
			{
				return null;
			}
			registryPath = registryPath.Trim(new char[] { '\\' });
			string firstKeyAndParseRemainder = RegistryDataKey.GetFirstKeyAndParseRemainder(ref registryPath);
			IntPtr intPtr = RegistryDataKey.RootHKEYFromRegPath(firstKeyAndParseRemainder);
			if (IntPtr.Zero == intPtr)
			{
				return null;
			}
			RegistryDataKey registryDataKey = new RegistryDataKey(firstKeyAndParseRemainder, intPtr);
			if (string.IsNullOrEmpty(registryPath))
			{
				return registryDataKey;
			}
			return RegistryDataKey.OpenSubKey(registryDataKey, registryPath, fCreateIfNotExist);
		}
		internal static RegistryDataKey Create(string keyId, RegistryKey hkey)
		{
			return new RegistryDataKey(keyId, hkey);
		}
		private static RegistryDataKey OpenSubKey(RegistryDataKey baseKey, string registryPath, bool createIfNotExist)
		{
			if (string.IsNullOrEmpty(registryPath) || baseKey == null)
			{
				return null;
			}
			string firstKeyAndParseRemainder = RegistryDataKey.GetFirstKeyAndParseRemainder(ref registryPath);
			RegistryDataKey registryDataKey = (createIfNotExist ? baseKey.CreateKey(firstKeyAndParseRemainder) : baseKey.OpenKey(firstKeyAndParseRemainder));
			if (string.IsNullOrEmpty(registryPath))
			{
				return registryDataKey;
			}
			return RegistryDataKey.OpenSubKey(registryDataKey, registryPath, createIfNotExist);
		}
		private static string GetTokenIdFromToken(ISpObjectToken sapiToken)
		{
			IntPtr zero = IntPtr.Zero;
			string text;
			try
			{
				sapiToken.GetId(out zero);
				text = Marshal.PtrToStringUni(zero);
			}
			finally
			{
				Marshal.FreeCoTaskMem(zero);
			}
			return text;
		}
		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}
		[PreserveSig]
		public int SetData([MarshalAs(UnmanagedType.LPWStr)] string valueName, [MarshalAs(UnmanagedType.SysUInt)] uint cbData, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] data)
		{
			return this._sapiRegKey.SetData(valueName, cbData, data);
		}
		[PreserveSig]
		public int GetData([MarshalAs(UnmanagedType.LPWStr)] string valueName, [MarshalAs(UnmanagedType.SysUInt)] ref uint pcbData, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [Out] byte[] data)
		{
			return this._sapiRegKey.GetData(valueName, ref pcbData, data);
		}
		[PreserveSig]
		public int SetStringValue([MarshalAs(UnmanagedType.LPWStr)] string valueName, [MarshalAs(UnmanagedType.LPWStr)] string value)
		{
			return this._sapiRegKey.SetStringValue(valueName, value);
		}
		[PreserveSig]
		public int GetStringValue([MarshalAs(UnmanagedType.LPWStr)] string valueName, [MarshalAs(UnmanagedType.LPWStr)] out string value)
		{
			return this._sapiRegKey.GetStringValue(valueName, out value);
		}
		[PreserveSig]
		public int SetDWORD([MarshalAs(UnmanagedType.LPWStr)] string valueName, [MarshalAs(UnmanagedType.SysUInt)] uint value)
		{
			return this._sapiRegKey.SetDWORD(valueName, value);
		}
		[PreserveSig]
		public int GetDWORD([MarshalAs(UnmanagedType.LPWStr)] string valueName, ref uint pdwValue)
		{
			return this._sapiRegKey.GetDWORD(valueName, ref pdwValue);
		}
		[PreserveSig]
		public int OpenKey([MarshalAs(UnmanagedType.LPWStr)] string subKeyName, out ISpDataKey ppSubKey)
		{
			return this._sapiRegKey.OpenKey(subKeyName, out ppSubKey);
		}
		[PreserveSig]
		public int CreateKey([MarshalAs(UnmanagedType.LPWStr)] string subKeyName, out ISpDataKey ppSubKey)
		{
			return this._sapiRegKey.CreateKey(subKeyName, out ppSubKey);
		}
		[PreserveSig]
		public int DeleteKey([MarshalAs(UnmanagedType.LPWStr)] string subKeyName)
		{
			return this._sapiRegKey.DeleteKey(subKeyName);
		}
		[PreserveSig]
		public int DeleteValue([MarshalAs(UnmanagedType.LPWStr)] string valueName)
		{
			return this._sapiRegKey.DeleteValue(valueName);
		}
		[PreserveSig]
		public int EnumKeys(uint index, [MarshalAs(UnmanagedType.LPWStr)] out string ppszSubKeyName)
		{
			return this._sapiRegKey.EnumKeys(index, out ppszSubKeyName);
		}
		[PreserveSig]
		public int EnumValues(uint index, [MarshalAs(UnmanagedType.LPWStr)] out string valueName)
		{
			return this._sapiRegKey.EnumValues(index, out valueName);
		}
		internal string Id
		{
			get
			{
				return (string)this._sKeyId.Clone();
			}
		}
		internal string Name
		{
			get
			{
				int num = this._sKeyId.LastIndexOf('\\');
				return this._sKeyId.Substring(num + 1);
			}
		}
		internal bool SetString(string valueName, string sValue)
		{
			return 0 == this.SetStringValue(valueName, sValue);
		}
		internal bool TryOpenKey(string keyName, out RegistryDataKey subKey)
		{
			if (string.IsNullOrEmpty(keyName))
			{
				subKey = null;
				return false;
			}
			subKey = this.OpenKey(keyName);
			return null != subKey;
		}
		internal bool TryGetString(string valueName, out string value)
		{
			if (valueName == null)
			{
				valueName = string.Empty;
			}
			return 0 == this.GetStringValue(valueName, out value);
		}
		internal bool HasValue(string valueName)
		{
			uint num = 0U;
			byte[] array = new byte[0];
			string text;
			return this._sapiRegKey.GetStringValue(valueName, out text) == 0 || this._sapiRegKey.GetDWORD(valueName, ref num) == 0 || 0 == this._sapiRegKey.GetData(valueName, ref num, array);
		}
		internal bool TryGetDWORD(string valueName, ref uint value)
		{
			return !string.IsNullOrEmpty(valueName) && 0 == this._sapiRegKey.GetDWORD(valueName, ref value);
		}
		internal RegistryDataKey OpenKey(string keyName)
		{
			Helpers.ThrowIfEmptyOrNull(keyName, "keyName");
			ISpDataKey spDataKey;
			if (this._sapiRegKey.OpenKey(keyName, out spDataKey) != 0)
			{
				return null;
			}
			return new RegistryDataKey(this._sKeyId + "\\" + keyName, spDataKey, true);
		}
		internal RegistryDataKey CreateKey(string keyName)
		{
			Helpers.ThrowIfEmptyOrNull(keyName, "keyName");
			ISpDataKey spDataKey;
			if (this._sapiRegKey.CreateKey(keyName, out spDataKey) != 0)
			{
				return null;
			}
			return new RegistryDataKey(this._sKeyId + "\\" + keyName, spDataKey, true);
		}
		internal string[] GetValueNames()
		{
			List<string> list = new List<string>();
			uint num = 0U;
			string text;
			while (this._sapiRegKey.EnumValues(num, out text) == 0)
			{
				list.Add(text);
				num += 1U;
			}
			return list.ToArray();
		}
		IEnumerator<RegistryDataKey> IEnumerable<RegistryDataKey>.GetEnumerator()
		{
			string childKeyName = string.Empty;
			uint i = 0U;
			while (this._sapiRegKey.EnumKeys(i, out childKeyName) == 0)
			{
				yield return this.CreateKey(childKeyName);
				i += 1U;
			}
			yield break;
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<RegistryDataKey>)this).GetEnumerator();
		}
		internal bool DeleteSubKeyTree(string childKeyName)
		{
			using (RegistryDataKey registryDataKey = this.OpenKey(childKeyName))
			{
				if (registryDataKey == null)
				{
					return true;
				}
				if (!registryDataKey.DeleteSubKeys())
				{
					return false;
				}
			}
			return 0 == this.DeleteKey(childKeyName);
		}
		protected virtual void Dispose(bool disposing)
		{
			if (disposing && this._sapiRegKey != null && this._disposeSapiKey)
			{
				Marshal.ReleaseComObject(this._sapiRegKey);
				this._sapiRegKey = null;
			}
		}
		private static IntPtr HKEYfromRegKey(RegistryKey regKey)
		{
			Type typeFromHandle = typeof(RegistryKey);
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic;
			FieldInfo field = typeFromHandle.GetField("hkey", bindingFlags);
			SafeHandle safeHandle = (SafeHandle)field.GetValue(regKey);
			return safeHandle.DangerousGetHandle();
		}
		private static IntPtr RootHKEYFromRegPath(string rootPath)
		{
			RegistryKey registryKey = RegistryDataKey.RegKeyFromRootPath(rootPath);
			IntPtr intPtr;
			if (registryKey == null)
			{
				intPtr = IntPtr.Zero;
			}
			else
			{
				intPtr = RegistryDataKey.HKEYfromRegKey(registryKey);
			}
			return intPtr;
		}
		private static string GetFirstKeyAndParseRemainder(ref string registryPath)
		{
			registryPath.Trim(new char[] { '\\' });
			int num = registryPath.IndexOf('\\');
			string text;
			if (num >= 0)
			{
				text = registryPath.Substring(0, num);
				registryPath = registryPath.Substring(num + 1, registryPath.Length - num - 1);
			}
			else
			{
				text = registryPath;
				registryPath = string.Empty;
			}
			return text;
		}
		private static RegistryKey RegKeyFromRootPath(string rootPath)
		{
			RegistryKey[] array = new RegistryKey[]
			{
				Registry.ClassesRoot,
				Registry.LocalMachine,
				Registry.CurrentUser,
				Registry.CurrentConfig
			};
			foreach (RegistryKey registryKey in array)
			{
				if (registryKey.Name.Equals(rootPath, StringComparison.InvariantCultureIgnoreCase))
				{
					return registryKey;
				}
			}
			return null;
		}
		private bool DeleteSubKeys()
		{
			string text;
			while (this.EnumKeys(0U, out text) == 0)
			{
				using (RegistryDataKey registryDataKey = this.OpenKey(text))
				{
					if (registryDataKey == null)
					{
						return false;
					}
					if (!registryDataKey.DeleteSubKeys())
					{
						return false;
					}
				}
				if (this.DeleteKey(text) != 0)
				{
					return false;
				}
				continue;
			}
			return true;
		}
		internal string _sKeyId;
		internal ISpDataKey _sapiRegKey;
		internal bool _disposeSapiKey;
		internal enum SAPIErrorCodes
		{
			STG_E_FILENOTFOUND = -2147287038,
			SPERR_UNSUPPORTED_FORMAT = -2147201021,
			SPERR_DEVICE_BUSY = -2147201018,
			SPERR_DEVICE_NOT_SUPPORTED,
			SPERR_DEVICE_NOT_ENABLED,
			SPERR_NO_DRIVER,
			SPERR_TOO_MANY_GRAMMARS = -2147200990,
			SPERR_INVALID_IMPORT = -2147200988,
			SPERR_AUDIO_BUFFER_OVERFLOW = -2147200977,
			SPERR_NO_AUDIO_DATA,
			SPERR_NO_MORE_ITEMS = -2147200967,
			SPERR_NOT_FOUND,
			SPERR_GENERIC_MMSYS_ERROR = -2147200964,
			SPERR_NOT_TOPLEVEL_RULE = -2147200940,
			SPERR_NOT_ACTIVE_SESSION = -2147200925,
			SPERR_SML_GENERATION_FAIL = -2147200921,
			SPERR_SHARED_ENGINE_DISABLED = -2147200906,
			SPERR_RECOGNIZER_NOT_FOUND,
			SPERR_AUDIO_NOT_FOUND,
			S_OK = 0,
			S_FALSE,
			E_INVALIDARG = -2147024809,
			SP_NO_RULES_TO_ACTIVATE = 282747,
			ERROR_MORE_DATA = 20714
		}
	}
}

SAPICategories.cs

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Speech.Internal.Synthesis;
using Microsoft.Win32;

namespace System.Speech.Internal.ObjectTokens
{
	internal static class SAPICategories
	{
		internal static ObjectToken DefaultToken(string category)
		{
			Helpers.ThrowIfEmptyOrNull(category, "category");
			ObjectToken objectToken = SAPICategories.DefaultToken("HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\" + category, "DefaultTokenId");
			if (objectToken == null)
			{
				objectToken = SAPICategories.DefaultToken("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\" + category, "DefaultTokenId");
			}
			return objectToken;
		}
		internal static int DefaultDeviceOut()
		{
			int num = -1;
			using (ObjectTokenCategory objectTokenCategory = ObjectTokenCategory.Create("HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\AudioOutput"))
			{
				string text;
				if (objectTokenCategory != null && objectTokenCategory.TryGetString("DefaultTokenId", out text))
				{
					int num2 = text.IndexOf('\\');
					if (num2 > 0 && num2 < text.Length)
					{
						using (RegistryDataKey registryDataKey = RegistryDataKey.Create(text.Substring(num2 + 1), Registry.LocalMachine))
						{
							if (registryDataKey != null)
							{
								num = AudioDeviceOut.GetDevicedId(registryDataKey.Name);
							}
						}
					}
				}
			}
			return num;
		}
		private static ObjectToken DefaultToken(string category, string defaultTokenIdValueName)
		{
			ObjectToken objectToken = SAPICategories.GetPreference(category, defaultTokenIdValueName);
			if (objectToken != null)
			{
				using (ObjectTokenCategory objectTokenCategory = ObjectTokenCategory.Create(category))
				{
					if (objectTokenCategory != null)
					{
						if (objectToken != null)
						{
							using (IEnumerator<ObjectToken> enumerator = ((IEnumerable<ObjectToken>)objectTokenCategory).GetEnumerator())
							{
								while (enumerator.MoveNext())
								{
									ObjectToken objectToken2 = enumerator.Current;
									objectToken = SAPICategories.GetHighestTokenVersion(objectToken, objectToken2, SAPICategories.asVersionDefault);
								}
								goto IL_00FD;
							}
						}
						string[] array = new string[] { string.Format(CultureInfo.InvariantCulture, "{0:x}", new object[] { CultureInfo.CurrentUICulture.LCID }) };
						foreach (ObjectToken objectToken3 in ((IEnumerable<ObjectToken>)objectTokenCategory))
						{
							if (objectToken3.MatchesAttributes(array))
							{
								objectToken = objectToken3;
								break;
							}
						}
						if (objectToken == null)
						{
							using (IEnumerator<ObjectToken> enumerator3 = ((IEnumerable<ObjectToken>)objectTokenCategory).GetEnumerator())
							{
								if (enumerator3.MoveNext())
								{
									ObjectToken objectToken4 = enumerator3.Current;
									objectToken = objectToken4;
								}
							}
						}
					}
					IL_00FD:;
				}
			}
			return objectToken;
		}
		private static ObjectToken GetPreference(string category, string defaultLocation)
		{
			ObjectToken objectToken = null;
			using (ObjectTokenCategory objectTokenCategory = ObjectTokenCategory.Create(category))
			{
				string text;
				if (objectTokenCategory != null && objectTokenCategory.TryGetString(defaultLocation, out text))
				{
					objectToken = objectTokenCategory.OpenToken(text);
				}
			}
			return objectToken;
		}
		private static int CompareTokenVersions(ObjectToken token1, ObjectToken token2, out bool pfDidCompare)
		{
			pfDidCompare = false;
			RegistryDataKey attributes = token1.Attributes;
			RegistryDataKey attributes2 = token2.Attributes;
			if (attributes == null)
			{
				return -1;
			}
			string text;
			attributes.TryGetString("Vendor", out text);
			string text2;
			attributes.TryGetString("ProductLine", out text2);
			string text3;
			attributes.TryGetString("Version", out text3);
			string text4;
			attributes.TryGetString("Language", out text4);
			if (attributes2 == null)
			{
				return 1;
			}
			string text5;
			attributes2.TryGetString("Vendor", out text5);
			string text6;
			attributes2.TryGetString("ProductLine", out text6);
			string text7;
			attributes2.TryGetString("Version", out text7);
			string text8;
			attributes2.TryGetString("Language", out text8);
			if (((string.IsNullOrEmpty(text) && string.IsNullOrEmpty(text5)) || (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text5) && text == text5)) && ((string.IsNullOrEmpty(text2) && string.IsNullOrEmpty(text6)) || (!string.IsNullOrEmpty(text2) && !string.IsNullOrEmpty(text6) && text2 == text6)) && ((string.IsNullOrEmpty(text4) && string.IsNullOrEmpty(text8)) || (!string.IsNullOrEmpty(text4) && !string.IsNullOrEmpty(text8) && text4 == text8)))
			{
				pfDidCompare = true;
				return SAPICategories.CompareVersions(text3, text7);
			}
			return -1;
		}
		private static int CompareVersions(string sV1, string sV2)
		{
			ushort[] array = new ushort[4];
			ushort[] array2 = new ushort[4];
			bool flag = SAPICategories.ParseVersion(sV1, array);
			bool flag2 = SAPICategories.ParseVersion(sV2, array2);
			if (!flag && !flag2)
			{
				return 0;
			}
			if (flag && !flag2)
			{
				return 1;
			}
			if (!flag && flag2)
			{
				return -1;
			}
			for (int i = 0; i < 4; i++)
			{
				if (array[i] > array2[i])
				{
					return 1;
				}
				if (array[i] < array2[i])
				{
					return -1;
				}
			}
			return 0;
		}
		private static bool ParseVersion(string s, ushort[] Version)
		{
			bool flag = true;
			Version[0] = (Version[1] = (Version[2] = (Version[3] = 0)));
			if (string.IsNullOrEmpty(s))
			{
				flag = false;
			}
			else
			{
				int num = 0;
				int num2 = 0;
				while (num2 < 4 && num < s.Length)
				{
					int num3 = s.IndexOf('.', num);
					string text = s.Substring(num, num3);
					ushort num4;
					if (!ushort.TryParse(text, out num4) || num4 > 9999)
					{
						flag = false;
						break;
					}
					Version[num2] = num4;
					num = num3 + 1;
					num2++;
				}
				if (flag && num != s.Length)
				{
					flag = false;
				}
			}
			return flag;
		}
		private static ObjectToken GetHighestTokenVersion(ObjectToken token, ObjectToken tokenSeed, string[] criterias)
		{
			bool flag = tokenSeed.MatchesAttributes(criterias);
			if (flag)
			{
				bool flag2;
				int num = SAPICategories.CompareTokenVersions(tokenSeed, token, out flag2);
				if (flag2 && num > 0)
				{
					token = tokenSeed;
				}
			}
			return token;
		}
		private const string SpeechRegistryKey = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\";
		internal const string CurrentUserVoices = "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\Voices";
		internal const string Recognizers = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers";
		internal const string Voices = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Voices";
		internal const string AudioIn = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\AudioInput";
		private const string _defaultTokenIdValueName = "DefaultTokenId";
		private static readonly string[] asVersionDefault = new string[] { "VersionDefault" };
	}
}

ISpNotifySink.cs

using System;
using System.Runtime.InteropServices;

namespace System.Speech.Internal.SapiInterop
{
	[Guid("259684DC-37C3-11D2-9603-00C04F8EE628")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[ComImport]
	internal interface ISpNotifySink
	{
		void Notify();
	}
}

ISpGrammarBuilder.cs

using System;
using System.Runtime.InteropServices;

namespace System.Speech.Internal.SapiInterop
{
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("8137828F-591A-4A42-BE58-49EA7EBAAC68")]
	[ComImport]
	internal interface ISpGrammarBuilder
	{
		void Slot1();
		void Slot2();
		void Slot3();
		void Slot4();
		void Slot5();
		void Slot6();
		void Slot7();
		void Slot8();
	}
}

ISpRecoResult.cs

using System;
using System.Runtime.InteropServices;

namespace System.Speech.Internal.SapiInterop
{
	[Guid("20B053BE-E235-43cd-9A2A-8D17A48B7842")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[ComImport]
	internal interface ISpRecoResult : ISpPhrase
	{
		void GetPhrase(out IntPtr ppCoMemPhrase);
		void GetSerializedPhrase(out IntPtr ppCoMemPhrase);
		void GetText(uint ulStart, uint ulCount, [MarshalAs(UnmanagedType.Bool)] bool fUseTextReplacements, [MarshalAs(UnmanagedType.LPWStr)] out string ppszCoMemText, out byte pbDisplayAttributes);
		void Discard(uint dwValueTypes);
		void Slot5();
		void GetAlternates(int ulStartElement, int cElements, int ulRequestCount, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] [Out] IntPtr[] ppPhrases, out int pcPhrasesReturned);
		void GetAudio(uint ulStartElement, uint cElements, out ISpStreamFormat ppStream);
		void Slot8();
		void Serialize(out IntPtr ppCoMemSerializedResult);
		void Slot10();
		void Slot11();
	}
}

SpInprocRecognizer.cs

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.Speech.Internal.SapiInterop
{
	[Guid("41B89B6B-9399-11D2-9623-00C04F8EE628")]
	[ComImport]
	internal class SpInprocRecognizer
	{
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
		public extern SpInprocRecognizer();
	}
}

CfgGrammar.cs

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Speech.Internal.SrgsParser;

namespace System.Speech.Internal.SrgsCompiler
{
	internal sealed class CfgGrammar
	{
		internal CfgGrammar()
		{
		}
		internal static CfgGrammar.CfgHeader ConvertCfgHeader(StreamMarshaler streamHelper)
		{
			CfgGrammar.CfgSerializedHeader cfgSerializedHeader = null;
			return CfgGrammar.ConvertCfgHeader(streamHelper, true, true, out cfgSerializedHeader);
		}
		internal static CfgGrammar.CfgHeader ConvertCfgHeader(StreamMarshaler streamHelper, bool includeAllGrammarData, bool loadSymbols, out CfgGrammar.CfgSerializedHeader cfgSerializedHeader)
		{
			cfgSerializedHeader = new CfgGrammar.CfgSerializedHeader(streamHelper.Stream);
			CfgGrammar.CfgHeader cfgHeader = default(CfgGrammar.CfgHeader);
			cfgHeader.FormatId = cfgSerializedHeader.FormatId;
			cfgHeader.GrammarGUID = cfgSerializedHeader.GrammarGUID;
			cfgHeader.langId = cfgSerializedHeader.LangID;
			cfgHeader.pszGlobalTags = cfgSerializedHeader.pszSemanticInterpretationGlobals;
			cfgHeader.cArcsInLargestState = cfgSerializedHeader.cArcsInLargestState;
			cfgHeader.rules = CfgGrammar.Load<CfgRule>(streamHelper, cfgSerializedHeader.pRules, cfgSerializedHeader.cRules);
			if (includeAllGrammarData || loadSymbols)
			{
				cfgHeader.pszSymbols = CfgGrammar.LoadStringBlob(streamHelper, cfgSerializedHeader.pszSymbols, cfgSerializedHeader.cchSymbols);
			}
			if (includeAllGrammarData)
			{
				cfgHeader.pszWords = CfgGrammar.LoadStringBlob(streamHelper, cfgSerializedHeader.pszWords, cfgSerializedHeader.cchWords);
				cfgHeader.arcs = CfgGrammar.Load<CfgArc>(streamHelper, cfgSerializedHeader.pArcs, cfgSerializedHeader.cArcs);
				cfgHeader.tags = CfgGrammar.Load<CfgSemanticTag>(streamHelper, cfgSerializedHeader.tags, cfgSerializedHeader.cTags);
				cfgHeader.weights = CfgGrammar.Load<float>(streamHelper, cfgSerializedHeader.pWeights, cfgSerializedHeader.cArcs);
			}
			if ((ulong)cfgSerializedHeader.pszWords < (ulong)((long)Marshal.SizeOf(typeof(CfgGrammar.CfgSerializedHeader))))
			{
				cfgHeader.ulRootRuleIndex = uint.MaxValue;
				cfgHeader.GrammarOptions = GrammarOptions.KeyValuePairs;
				cfgHeader.BasePath = null;
				cfgHeader.GrammarMode = GrammarType.VoiceGrammar;
			}
			else
			{
				cfgHeader.ulRootRuleIndex = cfgSerializedHeader.ulRootRuleIndex;
				cfgHeader.GrammarOptions = cfgSerializedHeader.GrammarOptions;
				cfgHeader.GrammarMode = (GrammarType)cfgSerializedHeader.GrammarMode;
				if (includeAllGrammarData)
				{
					cfgHeader.scripts = CfgGrammar.Load<CfgScriptRef>(streamHelper, cfgSerializedHeader.pScripts, cfgSerializedHeader.cScripts);
				}
				if (cfgSerializedHeader.cBasePath > 0U)
				{
					streamHelper.Stream.Position = (long)(cfgSerializedHeader.pRules + (uint)(cfgHeader.rules.Length * Marshal.SizeOf(typeof(CfgRule))));
					cfgHeader.BasePath = streamHelper.ReadNullTerminatedString();
				}
			}
			CfgGrammar.CheckValidCfgFormat(cfgSerializedHeader, cfgHeader, includeAllGrammarData);
			return cfgHeader;
		}
		internal static ScriptRef[] LoadScriptRefs(StreamMarshaler streamHelper, CfgGrammar.CfgSerializedHeader pFH)
		{
			if (pFH.FormatId != CfgGrammar._SPGDF_ContextFree)
			{
				return null;
			}
			if ((ulong)pFH.pszWords < (ulong)((long)Marshal.SizeOf(typeof(CfgGrammar.CfgSerializedHeader))))
			{
				return null;
			}
			StringBlob stringBlob = CfgGrammar.LoadStringBlob(streamHelper, pFH.pszSymbols, pFH.cchSymbols);
			CfgScriptRef[] array = CfgGrammar.Load<CfgScriptRef>(streamHelper, pFH.pScripts, pFH.cScripts);
			ScriptRef[] array2 = new ScriptRef[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				CfgScriptRef cfgScriptRef = array[i];
				array2[i] = new ScriptRef(stringBlob[cfgScriptRef._idRule], stringBlob[cfgScriptRef._idMethod], cfgScriptRef._method);
			}
			return array2;
		}
		internal static ScriptRef[] LoadIL(Stream stream)
		{
			ScriptRef[] array;
			using (StreamMarshaler streamMarshaler = new StreamMarshaler(stream))
			{
				CfgGrammar.CfgSerializedHeader cfgSerializedHeader = new CfgGrammar.CfgSerializedHeader();
				streamMarshaler.ReadStream(cfgSerializedHeader);
				array = CfgGrammar.LoadScriptRefs(streamMarshaler, cfgSerializedHeader);
			}
			return array;
		}
		internal static bool LoadIL(Stream stream, out byte[] assemblyContent, out byte[] assemblyDebugSymbols, out ScriptRef[] scripts)
		{
			byte[] array;
			assemblyDebugSymbols = (array = null);
			assemblyContent = array;
			scripts = null;
			using (StreamMarshaler streamMarshaler = new StreamMarshaler(stream))
			{
				CfgGrammar.CfgSerializedHeader cfgSerializedHeader = new CfgGrammar.CfgSerializedHeader();
				streamMarshaler.ReadStream(cfgSerializedHeader);
				scripts = CfgGrammar.LoadScriptRefs(streamMarshaler, cfgSerializedHeader);
				if (scripts == null)
				{
					return false;
				}
				if (cfgSerializedHeader.cIL == 0)
				{
					return false;
				}
				assemblyContent = CfgGrammar.Load<byte>(streamMarshaler, cfgSerializedHeader.pIL, cfgSerializedHeader.cIL);
				assemblyDebugSymbols = ((cfgSerializedHeader.cPDB > 0) ? CfgGrammar.Load<byte>(streamMarshaler, cfgSerializedHeader.pPDB, cfgSerializedHeader.cPDB) : null);
			}
			return true;
		}
		private static void CheckValidCfgFormat(CfgGrammar.CfgSerializedHeader pFH, CfgGrammar.CfgHeader header, bool includeAllGrammarData)
		{
			if (pFH.pszWords < 100U)
			{
				XmlParser.ThrowSrgsException(SRID.UnsupportedFormat, new object[0]);
			}
			int pszWords = (int)pFH.pszWords;
			CfgGrammar.CheckSetOffsets(pFH.pszWords, pFH.cchWords * 2, ref pszWords, pFH.ulTotalSerializedSize);
			CfgGrammar.CheckSetOffsets(pFH.pszSymbols, pFH.cchSymbols * 2, ref pszWords, pFH.ulTotalSerializedSize);
			if (pFH.cRules > 0)
			{
				CfgGrammar.CheckSetOffsets(pFH.pRules, pFH.cRules * Marshal.SizeOf(typeof(CfgRule)), ref pszWords, pFH.ulTotalSerializedSize);
			}
			if (pFH.cArcs > 0)
			{
				CfgGrammar.CheckSetOffsets(pFH.pArcs, pFH.cArcs * Marshal.SizeOf(typeof(CfgArc)), ref pszWords, pFH.ulTotalSerializedSize);
			}
			if (pFH.pWeights > 0U)
			{
				CfgGrammar.CheckSetOffsets(pFH.pWeights, pFH.cArcs * Marshal.SizeOf(typeof(float)), ref pszWords, pFH.ulTotalSerializedSize);
			}
			if (pFH.cTags > 0)
			{
				CfgGrammar.CheckSetOffsets(pFH.tags, pFH.cTags * Marshal.SizeOf(typeof(CfgSemanticTag)), ref pszWords, pFH.ulTotalSerializedSize);
				if (includeAllGrammarData)
				{
					for (int i = 0; i < header.tags.Length; i++)
					{
						int startArcIndex = (int)header.tags[i].StartArcIndex;
						int endArcIndex = (int)header.tags[i].EndArcIndex;
						int num = header.arcs.Length;
						if (startArcIndex == 0 || startArcIndex >= num || endArcIndex == 0 || endArcIndex >= num || (header.tags[i].PropVariantType != VarEnum.VT_EMPTY && header.tags[i].PropVariantType == VarEnum.VT_BSTR && header.tags[i].PropVariantType == VarEnum.VT_BOOL && header.tags[i].PropVariantType == VarEnum.VT_R8 && header.tags[i].PropVariantType == VarEnum.VT_I4))
						{
							XmlParser.ThrowSrgsException(SRID.UnsupportedFormat, new object[0]);
						}
					}
				}
			}
			if (pFH.cScripts > 0)
			{
				CfgGrammar.CheckSetOffsets(pFH.pScripts, pFH.cScripts * Marshal.SizeOf(typeof(CfgScriptRef)), ref pszWords, pFH.ulTotalSerializedSize);
			}
			if (pFH.cIL > 0)
			{
				CfgGrammar.CheckSetOffsets(pFH.pIL, pFH.cIL * Marshal.SizeOf(typeof(byte)), ref pszWords, pFH.ulTotalSerializedSize);
			}
			if (pFH.cPDB > 0)
			{
				CfgGrammar.CheckSetOffsets(pFH.pPDB, pFH.cPDB * Marshal.SizeOf(typeof(byte)), ref pszWords, pFH.ulTotalSerializedSize);
			}
		}
		private static void CheckSetOffsets(uint offset, int size, ref int start, uint max)
		{
			if (offset < (uint)start || (start = (int)(offset + (uint)size)) > (int)max)
			{
				XmlParser.ThrowSrgsException(SRID.UnsupportedFormat, new object[0]);
			}
		}
		private static StringBlob LoadStringBlob(StreamMarshaler streamHelper, uint iPos, int c)
		{
			char[] array = new char[c];
			streamHelper.Position = iPos;
			streamHelper.ReadArrayChar(array, c);
			return new StringBlob(array);
		}
		private static T[] Load<T>(StreamMarshaler streamHelper, uint iPos, int c)
		{
			T[] array = new T[c];
			if (c > 0)
			{
				streamHelper.Position = iPos;
				streamHelper.ReadArray<T>(array, c);
			}
			return array;
		}
		internal static uint NextHandle
		{
			get
			{
				return CfgGrammar._lastHandle += 1U;
			}
		}
		internal const int INFINITE = -1;
		internal const int SPTEXTBUFFERTRANSITION = 4194303;
		internal const int SPWILDCARDTRANSITION = 4194302;
		internal const int SPDICTATIONTRANSITION = 4194301;
		internal const int MAX_TRANSITIONS_COUNT = 256;
		internal const float DEFAULT_WEIGHT = 1f;
		internal const int SP_LOW_CONFIDENCE = -1;
		internal const int SP_NORMAL_CONFIDENCE = 0;
		internal const int SP_HIGH_CONFIDENCE = 1;
		private const int SP_SPCFGSERIALIZEDHEADER_500 = 100;
		internal static Guid _SPGDF_ContextFree = new Guid(1306301037, 27879, 19904, 153, 167, 175, 158, 107, 106, 78, 145);
		internal static readonly Rule SPRULETRANS_TEXTBUFFER = new Rule(-1);
		internal static readonly Rule SPRULETRANS_WILDCARD = new Rule(-2);
		internal static readonly Rule SPRULETRANS_DICTATION = new Rule(-3);
		private static uint _lastHandle;
		internal struct CfgHeader
		{
			internal Guid FormatId;
			internal Guid GrammarGUID;
			internal ushort langId;
			internal ushort pszGlobalTags;
			internal int cArcsInLargestState;
			internal StringBlob pszWords;
			internal StringBlob pszSymbols;
			internal CfgRule[] rules;
			internal CfgArc[] arcs;
			internal float[] weights;
			internal CfgSemanticTag[] tags;
			internal CfgScriptRef[] scripts;
			internal uint ulRootRuleIndex;
			internal GrammarOptions GrammarOptions;
			internal GrammarType GrammarMode;
			internal string BasePath;
		}
		[StructLayout(LayoutKind.Sequential)]
		internal class CfgSerializedHeader
		{
			internal CfgSerializedHeader()
			{
			}
			internal CfgSerializedHeader(Stream stream)
			{
				BinaryReader binaryReader = new BinaryReader(stream);
				this.ulTotalSerializedSize = binaryReader.ReadUInt32();
				if (this.ulTotalSerializedSize < 100U || this.ulTotalSerializedSize > 2147483647U)
				{
					XmlParser.ThrowSrgsException(SRID.UnsupportedFormat, new object[0]);
				}
				this.FormatId = new Guid(binaryReader.ReadBytes(16));
				if (this.FormatId != CfgGrammar._SPGDF_ContextFree)
				{
					XmlParser.ThrowSrgsException(SRID.UnsupportedFormat, new object[0]);
				}
				this.GrammarGUID = new Guid(binaryReader.ReadBytes(16));
				this.LangID = binaryReader.ReadUInt16();
				this.pszSemanticInterpretationGlobals = binaryReader.ReadUInt16();
				this.cArcsInLargestState = binaryReader.ReadInt32();
				this.cchWords = binaryReader.ReadInt32();
				this.cWords = binaryReader.ReadInt32();
				this.pszWords = binaryReader.ReadUInt32();
				if (this.pszWords < 100U || this.pszWords > this.ulTotalSerializedSize)
				{
					XmlParser.ThrowSrgsException(SRID.UnsupportedFormat, new object[0]);
				}
				this.cchSymbols = binaryReader.ReadInt32();
				this.pszSymbols = binaryReader.ReadUInt32();
				this.cRules = binaryReader.ReadInt32();
				this.pRules = binaryReader.ReadUInt32();
				this.cArcs = binaryReader.ReadInt32();
				this.pArcs = binaryReader.ReadUInt32();
				this.pWeights = binaryReader.ReadUInt32();
				this.cTags = binaryReader.ReadInt32();
				this.tags = binaryReader.ReadUInt32();
				this.ulReservered1 = binaryReader.ReadUInt32();
				this.ulReservered2 = binaryReader.ReadUInt32();
				if (this.pszWords > 100U)
				{
					this.cScripts = binaryReader.ReadInt32();
					this.pScripts = binaryReader.ReadUInt32();
					this.cIL = binaryReader.ReadInt32();
					this.pIL = binaryReader.ReadUInt32();
					this.cPDB = binaryReader.ReadInt32();
					this.pPDB = binaryReader.ReadUInt32();
					this.ulRootRuleIndex = binaryReader.ReadUInt32();
					this.GrammarOptions = (GrammarOptions)binaryReader.ReadUInt32();
					this.cBasePath = binaryReader.ReadUInt32();
					this.GrammarMode = binaryReader.ReadUInt32();
					this.ulReservered3 = binaryReader.ReadUInt32();
					this.ulReservered4 = binaryReader.ReadUInt32();
				}
			}
			internal static bool IsCfg(Stream stream, out int cfgLength)
			{
				cfgLength = 0;
				BinaryReader binaryReader = new BinaryReader(stream);
				uint num = binaryReader.ReadUInt32();
				if (num < 100U || num > 2147483647U)
				{
					return false;
				}
				Guid guid = new Guid(binaryReader.ReadBytes(16));
				if (guid != CfgGrammar._SPGDF_ContextFree)
				{
					return false;
				}
				cfgLength = (int)num;
				return true;
			}
			internal uint ulTotalSerializedSize;
			internal Guid FormatId;
			internal Guid GrammarGUID;
			internal ushort LangID;
			internal ushort pszSemanticInterpretationGlobals;
			internal int cArcsInLargestState;
			internal int cchWords;
			internal int cWords;
			internal uint pszWords;
			internal int cchSymbols;
			internal uint pszSymbols;
			internal int cRules;
			internal uint pRules;
			internal int cArcs;
			internal uint pArcs;
			internal uint pWeights;
			internal int cTags;
			internal uint tags;
			internal uint ulReservered1;
			internal uint ulReservered2;
			internal int cScripts;
			internal uint pScripts;
			internal int cIL;
			internal uint pIL;
			internal int cPDB;
			internal uint pPDB;
			internal uint ulRootRuleIndex;
			internal GrammarOptions GrammarOptions;
			internal uint cBasePath;
			internal uint GrammarMode;
			internal uint ulReservered3;
			internal uint ulReservered4;
		}
		internal class CfgProperty
		{
			internal string _pszName;
			internal uint _ulId;
			internal VarEnum _comType;
			internal object _comValue;
		}
	}
}

CfgRule.cs

using System;
using System.Speech.Internal.SrgsParser;

namespace System.Speech.Internal.SrgsCompiler
{
	internal struct CfgRule
	{
		internal CfgRule(int id, int nameOffset, uint flag)
		{
			this._flag = flag;
			this._nameOffset = nameOffset;
			this._id = id;
		}
		internal CfgRule(int id, int nameOffset, SPCFGRULEATTRIBUTES attributes)
		{
			this._flag = 0U;
			this._nameOffset = nameOffset;
			this._id = id;
			this.TopLevel = (attributes & SPCFGRULEATTRIBUTES.SPRAF_TopLevel) != (SPCFGRULEATTRIBUTES)0;
			this.DefaultActive = (attributes & SPCFGRULEATTRIBUTES.SPRAF_Active) != (SPCFGRULEATTRIBUTES)0;
			this.PropRule = (attributes & SPCFGRULEATTRIBUTES.SPRAF_Interpreter) != (SPCFGRULEATTRIBUTES)0;
			this.Export = (attributes & SPCFGRULEATTRIBUTES.SPRAF_Export) != (SPCFGRULEATTRIBUTES)0;
			this.Dynamic = (attributes & SPCFGRULEATTRIBUTES.SPRAF_Dynamic) != (SPCFGRULEATTRIBUTES)0;
			this.Import = (attributes & SPCFGRULEATTRIBUTES.SPRAF_Import) != (SPCFGRULEATTRIBUTES)0;
		}
		internal bool TopLevel
		{
			get
			{
				return (this._flag & 1U) != 0U;
			}
			set
			{
				if (value)
				{
					this._flag |= 1U;
					return;
				}
				this._flag &= 4294967294U;
			}
		}
		internal bool DefaultActive
		{
			set
			{
				if (value)
				{
					this._flag |= 2U;
					return;
				}
				this._flag &= 4294967293U;
			}
		}
		internal bool PropRule
		{
			set
			{
				if (value)
				{
					this._flag |= 4U;
					return;
				}
				this._flag &= 4294967291U;
			}
		}
		internal bool Import
		{
			get
			{
				return (this._flag & 8U) != 0U;
			}
			set
			{
				if (value)
				{
					this._flag |= 8U;
					return;
				}
				this._flag &= 4294967287U;
			}
		}
		internal bool Export
		{
			get
			{
				return (this._flag & 16U) != 0U;
			}
			set
			{
				if (value)
				{
					this._flag |= 16U;
					return;
				}
				this._flag &= 4294967279U;
			}
		}
		internal bool HasResources
		{
			get
			{
				return (this._flag & 32U) != 0U;
			}
		}
		internal bool Dynamic
		{
			get
			{
				return (this._flag & 64U) != 0U;
			}
			set
			{
				if (value)
				{
					this._flag |= 64U;
					return;
				}
				this._flag &= 4294967231U;
			}
		}
		internal bool HasDynamicRef
		{
			get
			{
				return (this._flag & 128U) != 0U;
			}
			set
			{
				if (value)
				{
					this._flag |= 128U;
					return;
				}
				this._flag &= 4294967167U;
			}
		}
		internal uint FirstArcIndex
		{
			get
			{
				return (this._flag >> 8) & 4194303U;
			}
			set
			{
				if (value > 4194303U)
				{
					XmlParser.ThrowSrgsException(SRID.TooManyArcs, new object[0]);
				}
				this._flag &= 3221225727U;
				this._flag |= value << 8;
			}
		}
		internal bool DirtyRule
		{
			set
			{
				if (value)
				{
					this._flag |= 2147483648U;
					return;
				}
				this._flag &= 2147483647U;
			}
		}
		internal uint _flag;
		internal int _nameOffset;
		internal int _id;
	}
}


SrgsCompiler.cs

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Speech.Internal.SrgsParser;
using System.Speech.Recognition.SrgsGrammar;
using System.Text;
using System.Xml;

namespace System.Speech.Internal.SrgsCompiler
{
	internal static class SrgsCompiler
	{
		internal static void CompileStream(XmlReader[] xmlReaders, string filename, Stream stream, bool fOutputCfg, Uri originalUri, string[] referencedAssemblies, string keyFile)
		{
			int num = xmlReaders.Length;
			List<CustomGrammar.CfgResource> list = new List<CustomGrammar.CfgResource>();
			CustomGrammar customGrammar = new CustomGrammar();
			for (int i = 0; i < num; i++)
			{
				string text = null;
				Uri uri = originalUri;
				if (uri == null && xmlReaders[i].BaseURI != null && xmlReaders[i].BaseURI.Length > 0)
				{
					uri = new Uri(xmlReaders[i].BaseURI);
				}
				if (uri != null && (!uri.IsAbsoluteUri || uri.IsFile))
				{
					text = Path.GetDirectoryName(uri.IsAbsoluteUri ? uri.AbsolutePath : uri.OriginalString);
				}
				StringBuilder stringBuilder = new StringBuilder();
				ISrgsParser srgsParser = new XmlParser(xmlReaders[i], uri);
				CultureInfo cultureInfo;
				object obj = SrgsCompiler.CompileStream(i + 1, srgsParser, text, filename, stream, fOutputCfg, stringBuilder, list, out cultureInfo, referencedAssemblies, keyFile);
				if (!fOutputCfg)
				{
					customGrammar.Combine((CustomGrammar)obj, stringBuilder.ToString());
				}
			}
			if (!fOutputCfg)
			{
				customGrammar.CreateAssembly(filename, list);
			}
		}
		internal static void CompileStream(SrgsDocument srgsGrammar, string filename, Stream stream, bool fOutputCfg, string[] referencedAssemblies, string keyFile)
		{
			ISrgsParser srgsParser = new SrgsDocumentParser(srgsGrammar.Grammar);
			List<CustomGrammar.CfgResource> list = new List<CustomGrammar.CfgResource>();
			StringBuilder stringBuilder = new StringBuilder();
			srgsGrammar.Grammar.Validate();
			CultureInfo cultureInfo;
			object obj = SrgsCompiler.CompileStream(1, srgsParser, null, filename, stream, fOutputCfg, stringBuilder, list, out cultureInfo, referencedAssemblies, keyFile);
			if (!fOutputCfg)
			{
				CustomGrammar customGrammar = new CustomGrammar();
				customGrammar.Combine((CustomGrammar)obj, stringBuilder.ToString());
				customGrammar.CreateAssembly(filename, list);
			}
		}
		private static object CompileStream(int iCfg, ISrgsParser srgsParser, string srgsPath, string filename, Stream stream, bool fOutputCfg, StringBuilder innerCode, object cfgResources, out CultureInfo culture, string[] referencedAssemblies, string keyFile)
		{
			Backend backend = new Backend();
			CustomGrammar customGrammar = new CustomGrammar();
			SrgsElementCompilerFactory srgsElementCompilerFactory = new SrgsElementCompilerFactory(backend, customGrammar);
			srgsParser.ElementFactory = srgsElementCompilerFactory;
			srgsParser.Parse();
			backend.Optimize();
			culture = ((backend.LangId == 21514) ? new CultureInfo("es-us") : new CultureInfo(backend.LangId));
			if (customGrammar._codebehind.Count > 0 && !string.IsNullOrEmpty(srgsPath))
			{
				for (int i = 0; i < customGrammar._codebehind.Count; i++)
				{
					if (!File.Exists(customGrammar._codebehind[i]))
					{
						customGrammar._codebehind[i] = srgsPath + "\\" + customGrammar._codebehind[i];
					}
				}
			}
			if (referencedAssemblies != null)
			{
				foreach (string text in referencedAssemblies)
				{
					customGrammar._assemblyReferences.Add(text);
				}
			}
			customGrammar._keyFile = keyFile;
			backend.ScriptRefs = customGrammar._scriptRefs;
			if (!fOutputCfg)
			{
				CustomGrammar.CfgResource cfgResource = new CustomGrammar.CfgResource();
				cfgResource.data = SrgsCompiler.BuildCfg(backend).ToArray();
				cfgResource.name = iCfg.ToString(CultureInfo.InvariantCulture) + ".CFG";
				((List<CustomGrammar.CfgResource>)cfgResources).Add(cfgResource);
				innerCode.Append(customGrammar.CreateAssembly(iCfg, filename, culture));
			}
			else
			{
				if (customGrammar._scriptRefs.Count > 0 && !customGrammar.HasScript)
				{
					XmlParser.ThrowSrgsException(SRID.NoScriptsForRules, new object[0]);
				}
				SrgsCompiler.CreateAssembly(backend, customGrammar);
				if (!string.IsNullOrEmpty(filename))
				{
					stream = new FileStream(filename, FileMode.Create, FileAccess.Write);
				}
				try
				{
					using (StreamMarshaler streamMarshaler = new StreamMarshaler(stream))
					{
						backend.Commit(streamMarshaler);
					}
				}
				finally
				{
					if (!string.IsNullOrEmpty(filename))
					{
						stream.Close();
					}
				}
			}
			return customGrammar;
		}
		private static MemoryStream BuildCfg(Backend backend)
		{
			MemoryStream memoryStream = new MemoryStream();
			using (StreamMarshaler streamMarshaler = new StreamMarshaler(memoryStream))
			{
				backend.IL = null;
				backend.PDB = null;
				backend.Commit(streamMarshaler);
			}
			return memoryStream;
		}
		private static void CreateAssembly(Backend backend, CustomGrammar cg)
		{
			if (cg.HasScript)
			{
				byte[] array;
				byte[] array2;
				cg.CreateAssembly(out array, out array2);
				backend.IL = array;
				backend.PDB = array2;
			}
		}
	}
}

GrammarOptions.cs

using System;

namespace System.Speech.Internal.SrgsCompiler
{
	[Flags]
	internal enum GrammarOptions
	{
		KeyValuePairs = 0,
		MssV1 = 1,
		KeyValuePairSrgs = 2,
		IpaPhoneme = 4,
		W3cV1 = 8,
		STG = 16,
		TagFormat = 11,
		SemanticInterpretation = 9
	}
}


CreateTokenCallback.cs

using System;

namespace System.Speech.Internal.SrgsParser
{
	internal delegate IToken CreateTokenCallback(IElement parent, string content, string pronumciation, string display, float reqConfidence);
}

ISrgsParser.cs

using System;

namespace System.Speech.Internal.SrgsParser
{
	internal interface ISrgsParser
	{
		void Parse();
		IElementFactory ElementFactory { set; }
	}
}

SrgsDocumentParser.cs

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Speech.Recognition;
using System.Speech.Recognition.SrgsGrammar;

namespace System.Speech.Internal.SrgsParser
{
	internal class SrgsDocumentParser : ISrgsParser
	{
		internal SrgsDocumentParser(SrgsGrammar grammar)
		{
			this._grammar = grammar;
		}
		public void Parse()
		{
			try
			{
				this.ProcessGrammarElement(this._grammar, this._parser.Grammar);
			}
			catch
			{
				this._parser.RemoveAllRules();
				throw;
			}
		}
		public IElementFactory ElementFactory
		{
			set
			{
				this._parser = value;
			}
		}
		private void ProcessGrammarElement(SrgsGrammar source, IGrammar grammar)
		{
			grammar.Culture = source.Culture;
			grammar.Mode = source.Mode;
			if (source.Root != null)
			{
				grammar.Root = source.Root.Id;
			}
			grammar.TagFormat = source.TagFormat;
			grammar.XmlBase = source.XmlBase;
			grammar.GlobalTags = source.GlobalTags;
			grammar.PhoneticAlphabet = source.PhoneticAlphabet;
			foreach (SrgsRule srgsRule in source.Rules)
			{
				IRule rule = this.ParseRule(grammar, srgsRule);
				rule.PostParse(grammar);
			}
			grammar.AssemblyReferences = source.AssemblyReferences;
			grammar.CodeBehind = source.CodeBehind;
			grammar.Debug = source.Debug;
			grammar.ImportNamespaces = source.ImportNamespaces;
			grammar.Language = ((source.Language == null) ? "C#" : source.Language);
			grammar.Namespace = source.Namespace;
			this._parser.AddScript(grammar, source.Script, null, -1);
			grammar.PostParse(null);
		}
		private IRule ParseRule(IGrammar grammar, SrgsRule srgsRule)
		{
			string id = srgsRule.Id;
			bool flag = srgsRule.OnInit != null || srgsRule.OnParse != null || srgsRule.OnError != null || srgsRule.OnRecognition != null;
			IRule rule = grammar.CreateRule(id, (srgsRule.Scope == SrgsRuleScope.Public) ? RulePublic.True : RulePublic.False, srgsRule.Dynamic, flag);
			if (srgsRule.OnInit != null)
			{
				rule.CreateScript(grammar, id, srgsRule.OnInit, RuleMethodScript.onInit);
			}
			if (srgsRule.OnParse != null)
			{
				rule.CreateScript(grammar, id, srgsRule.OnParse, RuleMethodScript.onParse);
			}
			if (srgsRule.OnError != null)
			{
				rule.CreateScript(grammar, id, srgsRule.OnError, RuleMethodScript.onError);
			}
			if (srgsRule.OnRecognition != null)
			{
				rule.CreateScript(grammar, id, srgsRule.OnRecognition, RuleMethodScript.onRecognition);
			}
			if (srgsRule.Script.Length > 0)
			{
				this._parser.AddScript(grammar, id, srgsRule.Script);
			}
			rule.BaseClass = srgsRule.BaseClass;
			foreach (SrgsElement srgsElement in this.GetSortedTagElements(srgsRule.Elements))
			{
				this.ProcessChildNodes(srgsElement, rule, rule);
			}
			return rule;
		}
		private IRuleRef ParseRuleRef(SrgsRuleRef srgsRuleRef, IElement parent)
		{
			bool flag = true;
			IRuleRef ruleRef;
			if (srgsRuleRef == SrgsRuleRef.Null)
			{
				ruleRef = this._parser.Null;
			}
			else if (srgsRuleRef == SrgsRuleRef.Void)
			{
				ruleRef = this._parser.Void;
			}
			else if (srgsRuleRef == SrgsRuleRef.Garbage)
			{
				ruleRef = this._parser.Garbage;
			}
			else
			{
				ruleRef = this._parser.CreateRuleRef(parent, srgsRuleRef.Uri, srgsRuleRef.SemanticKey, srgsRuleRef.Params);
				flag = false;
			}
			if (flag)
			{
				this._parser.InitSpecialRuleRef(parent, ruleRef);
			}
			ruleRef.PostParse(parent);
			return ruleRef;
		}
		private IOneOf ParseOneOf(SrgsOneOf srgsOneOf, IElement parent, IRule rule)
		{
			IOneOf oneOf = this._parser.CreateOneOf(parent, rule);
			foreach (SrgsItem srgsItem in srgsOneOf.Items)
			{
				this.ProcessChildNodes(srgsItem, oneOf, rule);
			}
			oneOf.PostParse(parent);
			return oneOf;
		}
		private IItem ParseItem(SrgsItem srgsItem, IElement parent, IRule rule)
		{
			IItem item = this._parser.CreateItem(parent, rule, srgsItem.MinRepeat, srgsItem.MaxRepeat, srgsItem.RepeatProbability, srgsItem.Weight);
			foreach (SrgsElement srgsElement in this.GetSortedTagElements(srgsItem.Elements))
			{
				this.ProcessChildNodes(srgsElement, item, rule);
			}
			item.PostParse(parent);
			return item;
		}
		private IToken ParseToken(SrgsToken srgsToken, IElement parent)
		{
			return this._parser.CreateToken(parent, srgsToken.Text, srgsToken.Pronunciation, srgsToken.Display, -1f);
		}
		private void ParseText(IElement parent, string sChars, string pronunciation, string display, float reqConfidence)
		{
			XmlParser.ParseText(parent, sChars, pronunciation, display, reqConfidence, new CreateTokenCallback(this._parser.CreateToken));
		}
		private ISubset ParseSubset(SrgsSubset srgsSubset, IElement parent)
		{
			MatchMode matchMode = MatchMode.Subsequence;
			switch (srgsSubset.MatchingMode)
			{
			case SubsetMatchingMode.Subsequence:
				matchMode = MatchMode.Subsequence;
				break;
			case SubsetMatchingMode.OrderedSubset:
				matchMode = MatchMode.OrderedSubset;
				break;
			case SubsetMatchingMode.SubsequenceContentRequired:
				matchMode = MatchMode.SubsequenceContentRequired;
				break;
			case SubsetMatchingMode.OrderedSubsetContentRequired:
				matchMode = MatchMode.OrderedSubsetContentRequired;
				break;
			}
			return this._parser.CreateSubset(parent, srgsSubset.Text, matchMode);
		}
		private ISemanticTag ParseSemanticTag(SrgsSemanticInterpretationTag srgsTag, IElement parent)
		{
			ISemanticTag semanticTag = this._parser.CreateSemanticTag(parent);
			semanticTag.Content(parent, srgsTag.Script, 0);
			semanticTag.PostParse(parent);
			return semanticTag;
		}
		private IPropertyTag ParseNameValueTag(SrgsNameValueTag srgsTag, IElement parent)
		{
			IPropertyTag propertyTag = this._parser.CreatePropertyTag(parent);
			propertyTag.NameValue(parent, srgsTag.Name, srgsTag.Value);
			propertyTag.PostParse(parent);
			return propertyTag;
		}
		private void ProcessChildNodes(SrgsElement srgsElement, IElement parent, IRule rule)
		{
			Type type = srgsElement.GetType();
			IElement element = null;
			IRule rule2 = parent as IRule;
			IItem item = parent as IItem;
			if (type == typeof(SrgsRuleRef))
			{
				element = this.ParseRuleRef((SrgsRuleRef)srgsElement, parent);
			}
			else if (type == typeof(SrgsOneOf))
			{
				element = this.ParseOneOf((SrgsOneOf)srgsElement, parent, rule);
			}
			else if (type == typeof(SrgsItem))
			{
				element = this.ParseItem((SrgsItem)srgsElement, parent, rule);
			}
			else if (type == typeof(SrgsToken))
			{
				element = this.ParseToken((SrgsToken)srgsElement, parent);
			}
			else if (type == typeof(SrgsNameValueTag))
			{
				element = this.ParseNameValueTag((SrgsNameValueTag)srgsElement, parent);
			}
			else if (type == typeof(SrgsSemanticInterpretationTag))
			{
				element = this.ParseSemanticTag((SrgsSemanticInterpretationTag)srgsElement, parent);
			}
			else if (type == typeof(SrgsSubset))
			{
				element = this.ParseSubset((SrgsSubset)srgsElement, parent);
			}
			else if (type == typeof(SrgsText))
			{
				SrgsText srgsText = (SrgsText)srgsElement;
				string text = srgsText.Text;
				IElementText elementText = this._parser.CreateText(parent, text);
				this.ParseText(parent, text, null, null, -1f);
				if (rule2 != null)
				{
					this._parser.AddElement(rule2, elementText);
				}
				else if (item != null)
				{
					this._parser.AddElement(item, elementText);
				}
				else
				{
					XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[0]);
				}
			}
			else
			{
				XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[0]);
			}
			IOneOf oneOf = parent as IOneOf;
			if (oneOf != null)
			{
				IItem item2 = element as IItem;
				if (item2 != null)
				{
					this._parser.AddItem(oneOf, item2);
					return;
				}
				XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[0]);
				return;
			}
			else
			{
				if (rule2 != null)
				{
					this._parser.AddElement(rule2, element);
					return;
				}
				if (item != null)
				{
					this._parser.AddElement(item, element);
					return;
				}
				XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[0]);
				return;
			}
		}
		private IEnumerable<SrgsElement> GetSortedTagElements(Collection<SrgsElement> elements)
		{
			if (this._grammar.TagFormat == SrgsTagFormat.KeyValuePairs)
			{
				List<SrgsElement> list = new List<SrgsElement>();
				foreach (SrgsElement srgsElement in elements)
				{
					if (!(srgsElement is SrgsNameValueTag))
					{
						list.Add(srgsElement);
					}
				}
				foreach (SrgsElement srgsElement2 in elements)
				{
					if (srgsElement2 is SrgsNameValueTag)
					{
						list.Add(srgsElement2);
					}
				}
				return list;
			}
			return elements;
		}
		private SrgsGrammar _grammar;
		private IElementFactory _parser;
	}
}

XmlParser.cs

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Speech.Recognition.SrgsGrammar;
using System.Text;
using System.Xml;

namespace System.Speech.Internal.SrgsParser
{
	internal class XmlParser : ISrgsParser
	{
		internal XmlParser(XmlReader reader, Uri uri)
		{
			this._reader = reader;
			this._xmlTextReader = reader as XmlTextReader;
			if (uri == null && this._xmlTextReader != null && this._xmlTextReader.BaseURI.Length > 0)
			{
				try
				{
					uri = new Uri(this._xmlTextReader.BaseURI);
				}
				catch (UriFormatException)
				{
				}
			}
			if (uri != null)
			{
				this._filename = ((!uri.IsAbsoluteUri || !uri.IsFile) ? uri.OriginalString : uri.LocalPath);
				int num = this._filename.LastIndexOfAny(XmlParser._SlashBackSlash);
				this._shortFilename = ((num >= 0) ? this._filename.Substring(num + 1) : this._filename);
			}
		}
		public void Parse()
		{
			try
			{
				bool flag = false;
				while (this._reader.Read())
				{
					if (this._reader.NodeType == XmlNodeType.Element && this._reader.LocalName == "grammar")
					{
						if (this._reader.NamespaceURI != "http://www.w3.org/2001/06/grammar")
						{
							XmlParser.ThrowSrgsException(SRID.InvalidSrgsNamespace, new object[0]);
						}
						if (flag)
						{
							XmlParser.ThrowSrgsException(SRID.GrammarDefTwice, new object[0]);
						}
						else
						{
							this.ParseGrammar(this._reader, this._parser.Grammar);
							flag = true;
						}
					}
				}
				if (!flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidSrgs, new object[0]);
				}
			}
			catch (XmlException ex)
			{
				this._parser.RemoveAllRules();
				XmlParser.ThrowSrgsExceptionWithPosition(this._filename, this._reader, SR.Get(SRID.InvalidXmlFormat, new object[0]), ex);
			}
			catch (FormatException ex2)
			{
				this._parser.RemoveAllRules();
				XmlParser.ThrowSrgsExceptionWithPosition(this._filename, this._reader, ex2.Message, ex2.InnerException);
			}
			catch
			{
				this._parser.RemoveAllRules();
				throw;
			}
		}
		internal static void ParseText(IElement parent, string sChars, string pronunciation, string display, float reqConfidence, CreateTokenCallback createTokens)
		{
			sChars = sChars.Trim(Helpers._achTrimChars);
			char[] array = sChars.ToCharArray();
			int length = sChars.Length;
			int num;
			for (int i = 0; i < array.Length; i = num + 1)
			{
				if (array[i] == ' ')
				{
					num = i;
				}
				else
				{
					if (array[i] == '"')
					{
						i = (num = i + 1);
						while (num < length && array[num] != '"')
						{
							num++;
						}
						if (num >= length || array[num] != '"')
						{
							XmlParser.ThrowSrgsException(SRID.InvalidQuotedString, new object[0]);
						}
						if (num + 1 != length && array[num + 1] != ' ')
						{
							XmlParser.ThrowSrgsException(SRID.InvalidQuotedString, new object[0]);
						}
					}
					else
					{
						num = i + 1;
						while (num < length && array[num] != ' ')
						{
							num++;
						}
					}
					string text = sChars.Substring(i, num - i);
					if (text.IndexOf('"') != -1)
					{
						XmlParser.ThrowSrgsException(SRID.InvalidTokenString, new object[0]);
					}
					if (createTokens != null)
					{
						createTokens(parent, text, pronunciation, display, reqConfidence);
					}
				}
			}
		}
		internal static void ThrowSrgsException(SRID id, params object[] args)
		{
			throw new FormatException(SR.Get(id, args));
		}
		internal static void ThrowSrgsExceptionWithPosition(string filename, XmlReader xmlReader, string sError, Exception innerException)
		{
			XmlTextReader xmlTextReader = xmlReader as XmlTextReader;
			if (xmlTextReader != null)
			{
				string text = SR.Get(SRID.Line, new object[0]);
				string text2 = SR.Get(SRID.Position, new object[0]);
				int lineNumber = xmlTextReader.LineNumber;
				int linePosition = xmlTextReader.LinePosition;
				if (filename == null)
				{
					sError += string.Format(CultureInfo.InvariantCulture, " [{0}={1}, {2}={3}]", new object[] { text, lineNumber, text2, linePosition });
				}
				else
				{
					sError = string.Format(CultureInfo.InvariantCulture, "{0}({1},{2}): error : {3}", new object[] { filename, lineNumber, linePosition, sError });
				}
			}
			throw new FormatException(sError, innerException);
		}
		public IElementFactory ElementFactory
		{
			set
			{
				this._parser = value;
			}
		}
		private void ParseGrammar(XmlReader reader, IGrammar grammar)
		{
			string text = null;
			string text2 = null;
			string text3 = null;
			string text4 = null;
			GrammarType grammarType = GrammarType.VoiceGrammar;
			while (reader.MoveToNextAttribute())
			{
				bool flag = false;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null)
				{
					if (!(namespaceURI == ""))
					{
						string localName2;
						if (!(namespaceURI == "http://www.w3.org/XML/1998/namespace"))
						{
							if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
							{
								string localName;
								if ((localName = reader.LocalName) != null)
								{
									if (localName == "alphabet")
									{
										XmlParser.CheckForDuplicates(ref text, reader);
										string text5;
										switch (text5 = text)
										{
										case "ipa":
											grammar.PhoneticAlphabet = AlphabetType.Ipa;
											goto IL_0523;
										case "sapi":
										case "x-sapi":
										case "x-microsoft-sapi":
											grammar.PhoneticAlphabet = AlphabetType.Sapi;
											goto IL_0523;
										case "ups":
										case "x-ups":
										case "x-microsoft-ups":
											grammar.PhoneticAlphabet = AlphabetType.Ups;
											goto IL_0523;
										}
										XmlParser.ThrowSrgsException(SRID.UnsupportedPhoneticAlphabet, new object[] { reader.Value });
										goto IL_0523;
									}
									if (!(localName == "language"))
									{
										if (localName == "namespace")
										{
											XmlParser.CheckForDuplicates(ref text3, reader);
											if (string.IsNullOrEmpty(text3))
											{
												XmlParser.ThrowSrgsException(SRID.NoName1, new object[] { "namespace" });
											}
											grammar.Namespace = text3;
											goto IL_0523;
										}
										if (localName == "codebehind")
										{
											if (reader.Value.Length == 0)
											{
												XmlParser.ThrowSrgsException(SRID.NoName1, new object[] { "codebehind" });
											}
											grammar.CodeBehind.Add(reader.Value);
											goto IL_0523;
										}
										if (localName == "debug")
										{
											bool flag2;
											if (bool.TryParse(reader.Value, out flag2))
											{
												grammar.Debug = flag2;
												goto IL_0523;
											}
											goto IL_0523;
										}
									}
									else
									{
										XmlParser.CheckForDuplicates(ref text2, reader);
										if (text2 == "C#" || text2 == "VB.Net")
										{
											grammar.Language = text2;
											goto IL_0523;
										}
										XmlParser.ThrowSrgsException(SRID.UnsupportedLanguage, new object[] { reader.Value });
										goto IL_0523;
									}
								}
								flag = true;
							}
						}
						else if ((localName2 = reader.LocalName) != null)
						{
							if (!(localName2 == "lang"))
							{
								if (!(localName2 == "base"))
								{
									goto IL_0523;
								}
							}
							else
							{
								string value = reader.Value;
								try
								{
									grammar.Culture = (this._langId = new CultureInfo(value));
									goto IL_0523;
								}
								catch (ArgumentException)
								{
									if (string.Compare("es-us", value, StringComparison.OrdinalIgnoreCase) == 0)
									{
										Helpers.CombineCulture("es-ES", "en-US", new CultureInfo("es"), 21514);
										grammar.Culture = (this._langId = new CultureInfo(value));
									}
									else
									{
										int num2 = reader.Value.IndexOf("-", StringComparison.Ordinal);
										if (num2 <= 0)
										{
											throw;
										}
										grammar.Culture = (this._langId = new CultureInfo(reader.Value.Substring(0, num2)));
									}
									goto IL_0523;
								}
							}
							grammar.XmlBase = new Uri(reader.Value);
						}
					}
					else
					{
						string localName3;
						if ((localName3 = reader.LocalName) != null)
						{
							if (!(localName3 == "root"))
							{
								if (!(localName3 == "version"))
								{
									if (localName3 == "tag-format")
									{
										string value2;
										if ((value2 = reader.Value) != null)
										{
											if (value2 == "semantics/1.0")
											{
												grammar.TagFormat = SrgsTagFormat.W3cV1;
												this._hasTagFormat = true;
												goto IL_0523;
											}
											if (value2 == "semantics-ms/1.0")
											{
												grammar.TagFormat = SrgsTagFormat.MssV1;
												this._hasTagFormat = true;
												goto IL_0523;
											}
											if (value2 == "properties-ms/1.0")
											{
												grammar.TagFormat = SrgsTagFormat.KeyValuePairs;
												this._hasTagFormat = true;
												goto IL_0523;
											}
											if (value2 == "")
											{
												goto IL_0523;
											}
										}
										XmlParser.ThrowSrgsException(SRID.InvalidTagFormat, new object[0]);
										goto IL_0523;
									}
									if (localName3 == "mode")
									{
										string value3;
										if ((value3 = reader.Value) != null)
										{
											if (value3 == "voice")
											{
												grammar.Mode = GrammarType.VoiceGrammar;
												goto IL_0523;
											}
											if (value3 == "dtmf")
											{
												grammarType = (grammar.Mode = GrammarType.DtmfGrammar);
												goto IL_0523;
											}
										}
										XmlParser.ThrowSrgsException(SRID.InvalidGrammarMode, new object[0]);
										goto IL_0523;
									}
								}
								else
								{
									XmlParser.CheckForDuplicates(ref text4, reader);
									if (text4 != "1.0")
									{
										XmlParser.ThrowSrgsException(SRID.InvalidVersion, new object[0]);
										goto IL_0523;
									}
									goto IL_0523;
								}
							}
							else
							{
								if (grammar.Root == null)
								{
									grammar.Root = reader.Value;
									goto IL_0523;
								}
								XmlParser.ThrowSrgsException(SRID.RootRuleAlreadyDefined, new object[0]);
								goto IL_0523;
							}
						}
						flag = true;
					}
				}
				IL_0523:
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidGrammarAttribute, new object[] { reader.Name });
				}
			}
			if (text4 == null)
			{
				XmlParser.ThrowSrgsException(SRID.MissingRequiredAttribute, new object[] { "version", "grammar" });
			}
			if (this._langId == null)
			{
				if (grammarType == GrammarType.VoiceGrammar)
				{
					XmlParser.ThrowSrgsException(SRID.MissingRequiredAttribute, new object[] { "xml:lang", "grammar" });
				}
				else
				{
					this._langId = CultureInfo.CurrentUICulture;
				}
			}
			this.ProcessRulesAndScriptsNodes(reader, grammar);
			this.ValidateScripts();
			foreach (XmlParser.ForwardReference forwardReference in this._scripts)
			{
				this._parser.AddScript(grammar, forwardReference._name, forwardReference._value);
			}
			grammar.PostParse(null);
		}
		private IRule ParseRule(IGrammar grammar, XmlReader reader)
		{
			string text = null;
			string text2 = null;
			string text3 = null;
			RulePublic rulePublic = RulePublic.NotSet;
			RuleDynamic ruleDynamic = RuleDynamic.NotSet;
			string text4 = null;
			string text5 = null;
			string text6 = null;
			string text7 = null;
			string text8 = null;
			while (reader.MoveToNextAttribute())
			{
				bool flag = false;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null)
				{
					if (!(namespaceURI == ""))
					{
						if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
						{
							string localName;
							switch (localName = reader.LocalName)
							{
							case "dynamic":
							{
								XmlParser.CheckForDuplicates(ref text3, reader);
								string text9;
								if ((text9 = text3) != null)
								{
									if (text9 == "true")
									{
										ruleDynamic = RuleDynamic.True;
										goto IL_0244;
									}
									if (text9 == "false")
									{
										ruleDynamic = RuleDynamic.False;
										goto IL_0244;
									}
								}
								XmlParser.ThrowSrgsException(SRID.InvalidDynamicSetting, new object[0]);
								goto IL_0244;
							}
							case "baseclass":
								XmlParser.CheckForDuplicates(ref text4, reader);
								if (string.IsNullOrEmpty(text4))
								{
									XmlParser.ThrowSrgsException(SRID.NoName1, new object[] { "baseclass" });
									goto IL_0244;
								}
								goto IL_0244;
							case "onInit":
								XmlParser.CheckForDuplicates(ref text5, reader);
								text5 = reader.Value;
								goto IL_0244;
							case "onParse":
								XmlParser.CheckForDuplicates(ref text6, reader);
								text6 = reader.Value;
								goto IL_0244;
							case "onError":
								XmlParser.CheckForDuplicates(ref text7, reader);
								text7 = reader.Value;
								goto IL_0244;
							case "onRecognition":
								XmlParser.CheckForDuplicates(ref text8, reader);
								goto IL_0244;
							}
							flag = true;
						}
					}
					else
					{
						string localName2;
						if ((localName2 = reader.LocalName) != null)
						{
							if (localName2 == "id")
							{
								XmlParser.CheckForDuplicates(ref text, reader);
								goto IL_0244;
							}
							if (localName2 == "scope")
							{
								XmlParser.CheckForDuplicates(ref text2, reader);
								string text10;
								if ((text10 = text2) != null)
								{
									if (text10 == "private")
									{
										rulePublic = RulePublic.False;
										goto IL_0244;
									}
									if (text10 == "public")
									{
										rulePublic = RulePublic.True;
										goto IL_0244;
									}
								}
								XmlParser.ThrowSrgsException(SRID.InvalidRuleScope, new object[0]);
								goto IL_0244;
							}
						}
						flag = true;
					}
				}
				IL_0244:
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidRuleAttribute, new object[] { reader.Name });
				}
			}
			if (string.IsNullOrEmpty(text))
			{
				XmlParser.ThrowSrgsException(SRID.NoRuleId, new object[0]);
			}
			if (text5 != null && rulePublic != RulePublic.True)
			{
				XmlParser.ThrowSrgsException(SRID.OnInitOnPublicRule, new object[] { "OnInit", text });
			}
			if (text8 != null && rulePublic != RulePublic.True)
			{
				XmlParser.ThrowSrgsException(SRID.OnInitOnPublicRule, new object[] { "OnRecognition", text });
			}
			XmlParser.ValidateRuleId(text);
			bool flag2 = text5 != null || text6 != null || text7 != null || text8 != null;
			IRule rule = grammar.CreateRule(text, rulePublic, ruleDynamic, flag2);
			if (!string.IsNullOrEmpty(text5))
			{
				rule.CreateScript(grammar, text, text5, RuleMethodScript.onInit);
			}
			if (!string.IsNullOrEmpty(text6))
			{
				rule.CreateScript(grammar, text, text6, RuleMethodScript.onParse);
			}
			if (!string.IsNullOrEmpty(text7))
			{
				rule.CreateScript(grammar, text, text7, RuleMethodScript.onError);
			}
			if (!string.IsNullOrEmpty(text8))
			{
				rule.CreateScript(grammar, text, text8, RuleMethodScript.onRecognition);
			}
			rule.BaseClass = text4;
			this._rules.Add(text);
			if (!this.ProcessChildNodes(reader, rule, rule, "rule") && ruleDynamic != RuleDynamic.True)
			{
				XmlParser.ThrowSrgsException(SRID.InvalidEmptyRule, new object[] { "rule", text });
			}
			return rule;
		}
		private IRuleRef ParseRuleRef(IElement parent, XmlReader reader)
		{
			IRuleRef ruleRef = null;
			string text = null;
			string text2 = null;
			string text3 = null;
			while (reader.MoveToNextAttribute())
			{
				bool flag = false;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) == null)
				{
					goto IL_0181;
				}
				if (!(namespaceURI == ""))
				{
					if (!(namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions"))
					{
						goto IL_0181;
					}
					string localName;
					if ((localName = reader.LocalName) != null)
					{
						if (localName == "semantic-key")
						{
							XmlParser.CheckForDuplicates(ref text, reader);
							goto IL_0184;
						}
						if (localName == "params")
						{
							XmlParser.CheckForDuplicates(ref text2, reader);
							goto IL_0184;
						}
					}
					flag = true;
				}
				else
				{
					string localName2;
					if ((localName2 = reader.LocalName) != null)
					{
						if (localName2 == "uri")
						{
							XmlParser.CheckForDuplicates(ref text3, reader);
							this.ValidateRulerefNotPointingToSelf(text3);
							goto IL_0184;
						}
						if (localName2 == "special")
						{
							if (ruleRef != null)
							{
								XmlParser.ThrowSrgsException(SRID.InvalidAttributeDefinedTwice, new object[] { reader.Value, "special" });
							}
							string value;
							if ((value = reader.Value) == null)
							{
								goto IL_011E;
							}
							if (!(value == "NULL"))
							{
								if (!(value == "VOID"))
								{
									if (!(value == "GARBAGE"))
									{
										goto IL_011E;
									}
									ruleRef = this._parser.Garbage;
								}
								else
								{
									ruleRef = this._parser.Void;
								}
							}
							else
							{
								ruleRef = this._parser.Null;
							}
							IL_012B:
							this._parser.InitSpecialRuleRef(parent, ruleRef);
							goto IL_0184;
							IL_011E:
							XmlParser.ThrowSrgsException(SRID.InvalidSpecialRuleRef, new object[0]);
							goto IL_012B;
						}
						if (localName2 == "type")
						{
							goto IL_0184;
						}
					}
					flag = true;
				}
				IL_0184:
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidRulerefAttribute, new object[] { reader.Name });
					continue;
				}
				continue;
				IL_0181:
				flag = true;
				goto IL_0184;
			}
			this.ProcessChildNodes(reader, null, null, "ruleref");
			if (ruleRef == null)
			{
				if (text3 == null)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidRuleRef, new object[] { "uri" });
				}
				ruleRef = this._parser.CreateRuleRef(parent, new Uri(text3, UriKind.RelativeOrAbsolute), text, text2);
			}
			else
			{
				if (text3 != null)
				{
					XmlParser.ThrowSrgsException(SRID.NoUriForSpecialRuleRef, new object[0]);
				}
				if (!string.IsNullOrEmpty(text) || !string.IsNullOrEmpty(text2))
				{
					XmlParser.ThrowSrgsException(SRID.NoAliasForSpecialRuleRef, new object[0]);
				}
			}
			ruleRef.PostParse(parent);
			return ruleRef;
		}
		private IOneOf ParseOneOf(IElement parent, IRule rule, XmlReader reader)
		{
			IOneOf oneOf = this._parser.CreateOneOf(parent, rule);
			while (reader.MoveToNextAttribute())
			{
				bool flag = false;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null && (namespaceURI == "" || namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions"))
				{
					flag = true;
				}
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidOneOfAttribute, new object[] { reader.Name });
				}
			}
			this.ProcessChildNodes(reader, oneOf, rule, "one-of");
			oneOf.PostParse(parent);
			return oneOf;
		}
		private IItem ParseItem(IElement parent, IRule rule, XmlReader reader)
		{
			float num = 0.5f;
			int num2 = 1;
			int num3 = 1;
			float num4 = 1f;
			while (reader.MoveToNextAttribute())
			{
				bool flag = false;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null)
				{
					if (!(namespaceURI == ""))
					{
						if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
						{
							flag = true;
						}
					}
					else
					{
						string localName;
						if ((localName = reader.LocalName) != null)
						{
							if (localName == "repeat")
							{
								XmlParser.SetRepeatValues(reader.Value, out num2, out num3);
								goto IL_00BA;
							}
							if (localName == "repeat-prob")
							{
								num = Convert.ToSingle(reader.Value, CultureInfo.InvariantCulture);
								goto IL_00BA;
							}
							if (localName == "weight")
							{
								num4 = Convert.ToSingle(reader.Value, CultureInfo.InvariantCulture);
								goto IL_00BA;
							}
						}
						flag = true;
					}
				}
				IL_00BA:
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidItemAttribute, new object[] { reader.Name });
				}
			}
			IItem item = this._parser.CreateItem(parent, rule, num2, num3, num, num4);
			this.ProcessChildNodes(reader, item, rule, "item");
			item.PostParse(parent);
			return item;
		}
		private ISubset ParseSubset(IElement parent, XmlReader reader)
		{
			string text = null;
			MatchMode matchMode = MatchMode.Subsequence;
			while (reader.MoveToNextAttribute())
			{
				bool flag = reader.NamespaceURI.Length == 0;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null && namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
				{
					string localName;
					if ((localName = reader.LocalName) != null && localName == "match")
					{
						XmlParser.CheckForDuplicates(ref text, reader);
						string value;
						if ((value = reader.Value) != null)
						{
							if (value == "subsequence")
							{
								matchMode = MatchMode.Subsequence;
								goto IL_00B0;
							}
							if (value == "ordered-subset")
							{
								matchMode = MatchMode.OrderedSubset;
								goto IL_00B0;
							}
							if (value == "subsequence-content-required")
							{
								matchMode = MatchMode.SubsequenceContentRequired;
								goto IL_00B0;
							}
							if (value == "ordered-subset-content-required")
							{
								matchMode = MatchMode.OrderedSubsetContentRequired;
								goto IL_00B0;
							}
						}
						flag = true;
					}
					else
					{
						flag = true;
					}
				}
				IL_00B0:
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidSubsetAttribute, new object[] { reader.Name });
				}
			}
			string text2 = XmlParser.GetStringContent(reader).Trim();
			if (text2.Length == 0)
			{
				XmlParser.ThrowSrgsException(SRID.InvalidEmptyElement, new object[] { "subset" });
			}
			return this._parser.CreateSubset(parent, text2, matchMode);
		}
		private IToken ParseToken(IElement parent, XmlReader reader)
		{
			string text = null;
			string text2 = null;
			float num = -1f;
			while (reader.MoveToNextAttribute())
			{
				bool flag = false;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null)
				{
					if (!(namespaceURI == ""))
					{
						if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
						{
							string localName;
							if ((localName = reader.LocalName) != null)
							{
								if (!(localName == "pron"))
								{
									if (!(localName == "display"))
									{
										if (localName == "reqconf")
										{
											string value;
											if ((value = reader.Value) != null)
											{
												if (value == "high")
												{
													num = 0.8f;
													goto IL_0185;
												}
												if (value == "normal")
												{
													num = 0.5f;
													goto IL_0185;
												}
												if (value == "low")
												{
													num = 0.2f;
													goto IL_0185;
												}
											}
											XmlParser.ThrowSrgsException(SRID.InvalidReqConfAttribute, new object[] { reader.Name });
											goto IL_0185;
										}
									}
									else
									{
										if (!string.IsNullOrEmpty(text2))
										{
											XmlParser.ThrowSrgsException(SRID.MultipleDisplayString, new object[0]);
											goto IL_0185;
										}
										text2 = reader.Value.Trim(Helpers._achTrimChars);
										if (string.IsNullOrEmpty(text2))
										{
											XmlParser.ThrowSrgsException(SRID.EmptyDisplayString, new object[0]);
											goto IL_0185;
										}
										goto IL_0185;
									}
								}
								else
								{
									if (!string.IsNullOrEmpty(text))
									{
										XmlParser.ThrowSrgsException(SRID.MuliplePronunciationString, new object[0]);
										goto IL_0185;
									}
									text = reader.Value.Trim(Helpers._achTrimChars);
									if (string.IsNullOrEmpty(text))
									{
										XmlParser.ThrowSrgsException(SRID.EmptyPronunciationString, new object[0]);
										goto IL_0185;
									}
									goto IL_0185;
								}
							}
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
				}
				IL_0185:
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidTokenAttribute, new object[] { reader.Name });
				}
			}
			string text3 = XmlParser.GetStringContent(reader).Trim(Helpers._achTrimChars);
			if (string.IsNullOrEmpty(text3))
			{
				XmlParser.ThrowSrgsException(SRID.InvalidEmptyElement, new object[] { "token" });
			}
			if (text3.IndexOf('"') >= 0)
			{
				XmlParser.ThrowSrgsException(SRID.InvalidTokenString, new object[0]);
			}
			return this._parser.CreateToken(parent, text3, text, text2, num);
		}
		private void ParseText(IElement parent, string sChars, string pronunciation, string display, float reqConfidence)
		{
			XmlParser.ParseText(parent, sChars, pronunciation, display, reqConfidence, new CreateTokenCallback(this._parser.CreateToken));
		}
		private IElement ParseTag(IElement parent, XmlReader reader)
		{
			string tagContent = this.GetTagContent(parent, reader);
			if (string.IsNullOrEmpty(tagContent))
			{
				return this._parser.CreateSemanticTag(parent);
			}
			if (this._parser.Grammar.TagFormat != SrgsTagFormat.KeyValuePairs)
			{
				ISemanticTag semanticTag = this._parser.CreateSemanticTag(parent);
				semanticTag.Content(parent, tagContent, 0);
				return semanticTag;
			}
			IPropertyTag propertyTag = this._parser.CreatePropertyTag(parent);
			string text;
			object obj;
			XmlParser.ParsePropertyTag(tagContent, out text, out obj);
			propertyTag.NameValue(parent, text, obj);
			return propertyTag;
		}
		private string GetTagContent(IElement parent, XmlReader reader)
		{
			if (!this._hasTagFormat)
			{
				XmlParser.ThrowSrgsException(SRID.MissingTagFormat, new object[0]);
			}
			while (reader.MoveToNextAttribute())
			{
				bool flag = false;
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null && (namespaceURI == "" || namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions"))
				{
					flag = true;
				}
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidTagAttribute, new object[] { reader.Name });
				}
			}
			return XmlParser.GetStringContent(reader).Trim(Helpers._achTrimChars);
		}
		private static void ParseLexicon(XmlReader reader)
		{
			bool flag = false;
			bool flag2 = false;
			while (reader.MoveToNextAttribute())
			{
				string localName;
				if ((localName = reader.LocalName) == null)
				{
					goto IL_0030;
				}
				if (!(localName == "uri"))
				{
					if (!(localName == "type"))
					{
						goto IL_0030;
					}
				}
				else
				{
					flag2 = true;
				}
				IL_0032:
				if (flag)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidLexiconAttribute, new object[] { reader.Name });
					continue;
				}
				continue;
				IL_0030:
				flag = true;
				goto IL_0032;
			}
			if (!flag2)
			{
				XmlParser.ThrowSrgsException(SRID.MissingRequiredAttribute, new object[] { "uri", "lexicon" });
			}
		}
		private static void ParseMeta(XmlReader reader)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			while (reader.MoveToNextAttribute())
			{
				string localName;
				if ((localName = reader.LocalName) == null)
				{
					goto IL_0055;
				}
				if (!(localName == "name") && !(localName == "http-equiv"))
				{
					if (!(localName == "content"))
					{
						goto IL_0055;
					}
					flag3 = flag;
					flag = true;
				}
				else
				{
					if (flag2)
					{
						XmlParser.ThrowSrgsException(SRID.MetaNameHTTPEquiv, new object[0]);
					}
					flag2 = true;
				}
				IL_0057:
				if (flag3)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidMetaAttribute, new object[] { reader.Name });
					continue;
				}
				continue;
				IL_0055:
				flag3 = true;
				goto IL_0057;
			}
			if (!flag)
			{
				XmlParser.ThrowSrgsException(SRID.MissingRequiredAttribute, new object[] { "content", "meta" });
			}
			if (!flag2)
			{
				XmlParser.ThrowSrgsException(SRID.MissingRequiredAttribute, new object[] { "name or http-equiv", "meta" });
			}
		}
		private void ParseScript(XmlReader reader, IGrammar grammar)
		{
			int num = ((this._filename != null) ? this._xmlTextReader.LineNumber : (-1));
			string text = null;
			while (reader.MoveToNextAttribute())
			{
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null)
				{
					if (!(namespaceURI == ""))
					{
						if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
						{
							string localName;
							if ((localName = reader.LocalName) != null && localName == "rule")
							{
								if (string.IsNullOrEmpty(text))
								{
									text = reader.Value;
								}
								else
								{
									XmlParser.ThrowSrgsException(SRID.RuleAttributeDefinedMultipeTimes, new object[0]);
								}
							}
							else
							{
								XmlParser.ThrowSrgsException(SRID.InvalidScriptAttribute, new object[0]);
							}
						}
					}
					else
					{
						XmlParser.ThrowSrgsException(SRID.InvalidScriptAttribute, new object[0]);
					}
				}
			}
			if (string.IsNullOrEmpty(text))
			{
				this._parser.AddScript(grammar, XmlParser.GetStringContent(reader), this._filename, num);
				return;
			}
			this._scripts.Add(new XmlParser.ForwardReference(text, this._parser.AddScript(grammar, text, XmlParser.GetStringContent(reader), this._filename, num)));
		}
		private static void ParseAssemblyReference(XmlReader reader, IGrammar grammar)
		{
			while (reader.MoveToNextAttribute())
			{
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null)
				{
					if (!(namespaceURI == ""))
					{
						if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
						{
							string localName;
							if ((localName = reader.LocalName) != null && localName == "assembly")
							{
								grammar.AssemblyReferences.Add(reader.Value);
							}
							else
							{
								XmlParser.ThrowSrgsException(SRID.InvalidAssemblyReferenceAttribute, new object[0]);
							}
						}
					}
					else
					{
						XmlParser.ThrowSrgsException(SRID.InvalidScriptAttribute, new object[0]);
					}
				}
			}
		}
		private static void ParseImportNamespace(XmlReader reader, IGrammar grammar)
		{
			while (reader.MoveToNextAttribute())
			{
				string namespaceURI;
				if ((namespaceURI = reader.NamespaceURI) != null)
				{
					if (!(namespaceURI == ""))
					{
						if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
						{
							string localName;
							if ((localName = reader.LocalName) != null && localName == "namespace")
							{
								grammar.ImportNamespaces.Add(reader.Value);
							}
							else
							{
								XmlParser.ThrowSrgsException(SRID.InvalidImportNamespaceAttribute, new object[0]);
							}
						}
					}
					else
					{
						XmlParser.ThrowSrgsException(SRID.InvalidScriptAttribute, new object[0]);
					}
				}
			}
		}
		private bool ProcessChildNodes(XmlReader reader, IElement parent, IRule rule, string parentName)
		{
			bool flag = true;
			List<IPropertyTag> list = null;
			reader.MoveToElement();
			if (!reader.IsEmptyElement)
			{
				reader.Read();
				while (reader.NodeType != XmlNodeType.EndElement)
				{
					bool flag2 = false;
					if (reader.NodeType == XmlNodeType.Element)
					{
						if (parent == null)
						{
							XmlParser.ThrowSrgsException(SRID.InvalidNotEmptyElement, new object[] { parentName });
						}
						IElement element = null;
						string namespaceURI;
						if ((namespaceURI = reader.NamespaceURI) == null)
						{
							goto IL_01F7;
						}
						if (!(namespaceURI == "http://www.w3.org/2001/06/grammar"))
						{
							if (!(namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions"))
							{
								goto IL_01F7;
							}
							string localName;
							if ((localName = reader.LocalName) != null && localName == "subset")
							{
								if (parent is IRule || parent is IItem)
								{
									element = this.ParseSubset(parent, reader);
								}
								else
								{
									flag2 = true;
								}
							}
							else
							{
								flag2 = true;
							}
						}
						else
						{
							string localName2;
							switch (localName2 = reader.LocalName)
							{
							case "example":
								if (!(parent is IRule) || !flag)
								{
									XmlParser.ThrowSrgsException(SRID.InvalidExampleOrdering, new object[0]);
									goto IL_01FD;
								}
								reader.Skip();
								continue;
							case "ruleref":
								element = this.ParseRuleRef(parent, reader);
								goto IL_01FD;
							case "one-of":
								element = this.ParseOneOf(parent, rule, reader);
								goto IL_01FD;
							case "item":
								element = this.ParseItem(parent, rule, reader);
								goto IL_01FD;
							case "token":
								element = this.ParseToken(parent, reader);
								goto IL_01FD;
							case "tag":
							{
								element = this.ParseTag(parent, reader);
								IPropertyTag propertyTag = element as IPropertyTag;
								if (propertyTag != null)
								{
									if (list == null)
									{
										list = new List<IPropertyTag>();
									}
									list.Add(propertyTag);
									goto IL_01FD;
								}
								goto IL_01FD;
							}
							}
							flag2 = true;
						}
						IL_01FD:
						flag2 = this.ParseChildNodeElement(parent, flag2, element);
						flag = false;
						goto IL_024A;
						IL_01F7:
						reader.Skip();
						goto IL_01FD;
					}
					if (reader.NodeType == XmlNodeType.Text || reader.NodeType == XmlNodeType.CDATA)
					{
						if (parent == null)
						{
							XmlParser.ThrowSrgsException(SRID.InvalidNotEmptyElement, new object[] { parentName });
						}
						flag2 = this.ParseChildNodeText(reader, parent);
						flag = false;
					}
					else
					{
						reader.Skip();
					}
					IL_024A:
					if (flag2)
					{
						XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[] { reader.Name });
					}
				}
			}
			reader.Read();
			if (list != null)
			{
				foreach (IPropertyTag propertyTag2 in list)
				{
					propertyTag2.PostParse(parent);
				}
			}
			return !flag;
		}
		private bool ParseChildNodeText(XmlReader reader, IElement parent)
		{
			bool flag = false;
			string value = reader.Value;
			IElementText elementText = this._parser.CreateText(parent, value);
			this.ParseText(parent, value, null, null, -1f);
			if (parent is IOneOf)
			{
				flag = true;
			}
			else
			{
				IRule rule = parent as IRule;
				if (rule != null)
				{
					this._parser.AddElement(rule, elementText);
				}
				else
				{
					IItem item = parent as IItem;
					if (item != null)
					{
						this._parser.AddElement(item, elementText);
					}
					else
					{
						flag = true;
					}
				}
			}
			reader.Read();
			return flag;
		}
		private bool ParseChildNodeElement(IElement parent, bool isInvalidNode, IElement child)
		{
			if (child != null)
			{
				IOneOf oneOf = parent as IOneOf;
				if (oneOf != null)
				{
					IItem item = child as IItem;
					if (item != null)
					{
						this._parser.AddItem(oneOf, item);
					}
					else
					{
						isInvalidNode = true;
					}
				}
				else
				{
					IRule rule = parent as IRule;
					if (rule != null)
					{
						this._parser.AddElement(rule, child);
					}
					else
					{
						IItem item2 = parent as IItem;
						if (item2 != null)
						{
							this._parser.AddElement(item2, child);
						}
						else
						{
							isInvalidNode = true;
						}
					}
				}
			}
			return isInvalidNode;
		}
		private void ProcessRulesAndScriptsNodes(XmlReader reader, IGrammar grammar)
		{
			bool flag = false;
			reader.MoveToElement();
			if (!reader.IsEmptyElement)
			{
				reader.Read();
				while (reader.NodeType != XmlNodeType.EndElement)
				{
					bool flag2 = false;
					if (reader.NodeType == XmlNodeType.Element)
					{
						string namespaceURI;
						if ((namespaceURI = reader.NamespaceURI) != null)
						{
							if (namespaceURI == "http://www.w3.org/2001/06/grammar")
							{
								string localName;
								if ((localName = reader.LocalName) != null)
								{
									if (localName == "lexicon")
									{
										if (flag)
										{
											XmlParser.ThrowSrgsException(SRID.InvalidGrammarOrdering, new object[0]);
										}
										XmlParser.ParseLexicon(reader);
										goto IL_01EF;
									}
									if (localName == "meta")
									{
										if (flag)
										{
											XmlParser.ThrowSrgsException(SRID.InvalidGrammarOrdering, new object[0]);
										}
										XmlParser.ParseMeta(reader);
										goto IL_01EF;
									}
									if (localName == "metadata")
									{
										if (flag)
										{
											XmlParser.ThrowSrgsException(SRID.InvalidGrammarOrdering, new object[0]);
										}
										reader.Skip();
										goto IL_01EF;
									}
									if (localName == "rule")
									{
										IRule rule = this.ParseRule(grammar, reader);
										rule.PostParse(grammar);
										flag = true;
										goto IL_01EF;
									}
									if (localName == "tag")
									{
										if (flag || (this._hasTagFormat && grammar.TagFormat != SrgsTagFormat.W3cV1))
										{
											XmlParser.ThrowSrgsException(SRID.InvalidGrammarOrdering, new object[0]);
										}
										grammar.GlobalTags.Add(this.GetTagContent(grammar, reader));
										goto IL_01EF;
									}
								}
								flag2 = true;
								goto IL_01EF;
							}
							if (namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions")
							{
								string localName2;
								if ((localName2 = reader.LocalName) != null)
								{
									if (localName2 == "script")
									{
										this.ParseScript(reader, grammar);
										flag = true;
										goto IL_01EF;
									}
									if (localName2 == "assemblyReference")
									{
										XmlParser.ParseAssemblyReference(reader, grammar);
										flag = true;
										goto IL_01EF;
									}
									if (localName2 == "importNamespace")
									{
										XmlParser.ParseImportNamespace(reader, grammar);
										flag = true;
										goto IL_01EF;
									}
								}
								flag2 = true;
								goto IL_01EF;
							}
						}
						reader.Skip();
					}
					else
					{
						if (reader.NodeType == XmlNodeType.Text)
						{
							XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[] { "text" });
						}
						reader.Skip();
					}
					IL_01EF:
					if (flag2)
					{
						XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[] { reader.Name });
					}
				}
			}
			reader.Read();
		}
		private static string GetStringContent(XmlReader reader)
		{
			StringBuilder stringBuilder = new StringBuilder();
			reader.MoveToElement();
			if (!reader.IsEmptyElement)
			{
				reader.Read();
				while (reader.NodeType != XmlNodeType.EndElement)
				{
					stringBuilder.Append(reader.ReadString());
					bool flag = false;
					if (reader.NodeType == XmlNodeType.Element)
					{
						string namespaceURI;
						if ((namespaceURI = reader.NamespaceURI) != null && (namespaceURI == "http://www.w3.org/2001/06/grammar" || namespaceURI == "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions"))
						{
							flag = true;
						}
						else
						{
							reader.Skip();
						}
					}
					else if (reader.NodeType != XmlNodeType.EndElement)
					{
						reader.Skip();
					}
					if (flag)
					{
						XmlParser.ThrowSrgsException(SRID.InvalidElement, new object[] { reader.Name });
					}
				}
			}
			reader.Read();
			return stringBuilder.ToString();
		}
		private static void ParsePropertyTag(string sTag, out string name, out object value)
		{
			name = null;
			value = string.Empty;
			int num = sTag.IndexOf('=');
			if (num >= 0)
			{
				name = sTag.Substring(0, num).Trim(Helpers._achTrimChars);
				num++;
			}
			else
			{
				num = 0;
			}
			int length = sTag.Length;
			if (num < length)
			{
				if (sTag[num] == '"')
				{
					num++;
					int num2 = sTag.IndexOf('"', num + 1);
					if (num2 + 1 != length)
					{
						XmlParser.ThrowSrgsException(SRID.IncorrectAttributeValue, new object[]
						{
							name,
							sTag.Substring(num)
						});
					}
					value = sTag.Substring(num, num2 - num);
					return;
				}
				string text = sTag.Substring(num);
				int num3;
				if (int.TryParse(text, out num3))
				{
					value = num3;
					return;
				}
				double num4;
				if (double.TryParse(text, out num4))
				{
					value = num4;
					return;
				}
				bool flag;
				if (bool.TryParse(text, out flag))
				{
					value = flag;
					return;
				}
				XmlParser.ThrowSrgsException(SRID.InvalidNameValueProperty, new object[] { name, text });
			}
		}
		private static void SetRepeatValues(string repeat, out int minRepeat, out int maxRepeat)
		{
			minRepeat = (maxRepeat = 1);
			if (!string.IsNullOrEmpty(repeat))
			{
				int num = repeat.IndexOf("-", StringComparison.Ordinal);
				if (num < 0)
				{
					int num2 = Convert.ToInt32(repeat, CultureInfo.InvariantCulture);
					if (num2 < 0 || num2 > 255)
					{
						XmlParser.ThrowSrgsException(SRID.MinMaxOutOfRange, new object[] { num2, num2 });
					}
					minRepeat = (maxRepeat = num2);
					return;
				}
				if (0 >= num)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidItemRepeatAttribute, new object[] { repeat });
					return;
				}
				minRepeat = Convert.ToInt32(repeat.Substring(0, num), CultureInfo.InvariantCulture);
				if (num < repeat.Length - 1)
				{
					maxRepeat = Convert.ToInt32(repeat.Substring(num + 1), CultureInfo.InvariantCulture);
				}
				else
				{
					maxRepeat = int.MaxValue;
				}
				if (minRepeat < 0 || minRepeat > 255 || (maxRepeat != 2147483647 && (maxRepeat < 0 || maxRepeat > 255)))
				{
					XmlParser.ThrowSrgsException(SRID.MinMaxOutOfRange, new object[] { minRepeat, maxRepeat });
				}
				if (minRepeat > maxRepeat)
				{
					throw new ArgumentException(SR.Get(SRID.MinGreaterThanMax, new object[0]));
				}
			}
			else
			{
				XmlParser.ThrowSrgsException(SRID.InvalidItemAttribute2, new object[0]);
			}
		}
		private static void CheckForDuplicates(ref string dest, XmlReader reader)
		{
			if (!string.IsNullOrEmpty(dest))
			{
				StringBuilder stringBuilder = new StringBuilder(reader.LocalName);
				if (reader.NamespaceURI.Length > 0)
				{
					stringBuilder.Append(reader.NamespaceURI);
					stringBuilder.Append(":");
				}
				XmlParser.ThrowSrgsException(SRID.InvalidAttributeDefinedTwice, new object[] { reader.Value, stringBuilder });
			}
			dest = reader.Value;
		}
		internal static void ValidateRuleId(string id)
		{
			Helpers.ThrowIfEmptyOrNull(id, "id");
			if (!XmlReader.IsName(id) || id == "NULL" || id == "VOID" || id == "GARBAGE" || id.IndexOfAny(XmlParser._invalidRuleIdChars) != -1)
			{
				XmlParser.ThrowSrgsException(SRID.InvalidRuleId, new object[] { id });
			}
		}
		private void ValidateRulerefNotPointingToSelf(string uri)
		{
			if (this._filename != null && uri.IndexOf(this._shortFilename, StringComparison.Ordinal) == 0 && ((uri.Length > this._shortFilename.Length && uri[this._shortFilename.Length] == '#') || uri.Length == this._shortFilename.Length))
			{
				XmlParser.ThrowSrgsException(SRID.InvalidRuleRefSelf, new object[0]);
			}
		}
		private void ValidateScripts()
		{
			foreach (XmlParser.ForwardReference forwardReference in this._scripts)
			{
				if (!this._rules.Contains(forwardReference._name))
				{
					XmlParser.ThrowSrgsException(SRID.InvalidScriptDefinition, new object[] { forwardReference._name });
				}
			}
			List<string> list = new List<string>();
			foreach (string text in this._rules)
			{
				if (list.Contains(text))
				{
					XmlParser.ThrowSrgsException(SRID.RuleAttributeDefinedMultipeTimes, new object[] { text });
				}
				list.Add(text);
			}
		}
		internal const string emptyNamespace = "";
		internal const string xmlNamespace = "http://www.w3.org/XML/1998/namespace";
		internal const string srgsNamespace = "http://www.w3.org/2001/06/grammar";
		internal const string sapiNamespace = "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions";
		private IElementFactory _parser;
		private XmlReader _reader;
		private XmlTextReader _xmlTextReader;
		private string _filename;
		private string _shortFilename;
		private CultureInfo _langId;
		private bool _hasTagFormat;
		private List<string> _rules = new List<string>();
		private List<XmlParser.ForwardReference> _scripts = new List<XmlParser.ForwardReference>();
		private static readonly char[] _invalidRuleIdChars = new char[] { '.', ':', '-', '#' };
		private static readonly char[] _SlashBackSlash = new char[] { '\\', '/' };
		[Serializable]
		internal class ForwardReference
		{
			internal ForwardReference(string name, string value)
			{
				this._name = name;
				this._value = value;
			}
			internal string _name;
			internal string _value;
		}
	}
}

AudioBase.cs

using System;
using System.IO;
using System.Runtime.InteropServices;

namespace System.Speech.Internal.Synthesis
{
	internal abstract class AudioBase
	{
		internal AudioBase()
		{
		}
		internal abstract void Begin(byte[] wfx);
		internal abstract void End();
		internal virtual void Play(IntPtr pBuff, int cb)
		{
			byte[] array = new byte[cb];
			Marshal.Copy(pBuff, array, 0, cb);
			this.Play(array);
		}
		internal virtual void Play(byte[] buffer)
		{
			GCHandle gchandle = GCHandle.Alloc(buffer);
			this.Play(gchandle.AddrOfPinnedObject(), buffer.Length);
			gchandle.Free();
		}
		internal abstract void Pause();
		internal abstract void Resume();
		internal abstract void InjectEvent(TTSEvent ttsEvent);
		internal abstract void WaitUntilDone();
		internal abstract void Abort();
		internal void PlayWaveFile(AudioData audio)
		{
			try
			{
				if (!string.IsNullOrEmpty(audio._mimeType))
				{
					WAVEFORMATEX waveformatex = default(WAVEFORMATEX);
					waveformatex.nChannels = 1;
					waveformatex.nSamplesPerSec = 8000;
					waveformatex.nAvgBytesPerSec = 8000;
					waveformatex.nBlockAlign = 1;
					waveformatex.wBitsPerSample = 8;
					waveformatex.cbSize = 0;
					string mimeType;
					if ((mimeType = audio._mimeType) != null)
					{
						if (!(mimeType == "audio/basic"))
						{
							if (!(mimeType == "audio/x-alaw-basic"))
							{
								goto IL_008D;
							}
							waveformatex.wFormatTag = 6;
						}
						else
						{
							waveformatex.wFormatTag = 7;
						}
						this.Begin(waveformatex.ToBytes());
						try
						{
							byte[] array = new byte[(int)audio._stream.Length];
							audio._stream.Read(array, 0, array.Length);
							this.Play(array);
							goto IL_01C7;
						}
						finally
						{
							this.WaitUntilDone();
							this.End();
						}
						goto IL_00E9;
					}
					IL_008D:
					throw new FormatException(SR.Get(SRID.UnknownMimeFormat, new object[0]));
				}
				IL_00E9:
				BinaryReader binaryReader = new BinaryReader(audio._stream);
				try
				{
					byte[] waveFormat = AudioBase.GetWaveFormat(binaryReader);
					if (waveFormat == null)
					{
						throw new FormatException(SR.Get(SRID.NotValidAudioFile, new object[] { audio._uri.ToString() }));
					}
					this.Begin(waveFormat);
					try
					{
						for (;;)
						{
							AudioBase.DATAHDR datahdr = default(AudioBase.DATAHDR);
							if (audio._stream.Position + 8L >= audio._stream.Length)
							{
								break;
							}
							datahdr._id = binaryReader.ReadUInt32();
							datahdr._len = binaryReader.ReadInt32();
							if (datahdr._id == 1635017060U)
							{
								byte[] array2 = Helpers.ReadStreamToByteArray(audio._stream, datahdr._len);
								this.Play(array2);
							}
							else
							{
								audio._stream.Seek((long)datahdr._len, SeekOrigin.Current);
							}
						}
					}
					finally
					{
						this.WaitUntilDone();
						this.End();
					}
				}
				finally
				{
					((IDisposable)binaryReader).Dispose();
				}
				IL_01C7:;
			}
			finally
			{
				audio.Dispose();
			}
		}
		internal static byte[] GetWaveFormat(BinaryReader br)
		{
			AudioBase.RIFFHDR riffhdr = default(AudioBase.RIFFHDR);
			riffhdr._id = br.ReadUInt32();
			riffhdr._len = br.ReadInt32();
			riffhdr._type = br.ReadUInt32();
			if (riffhdr._id != 1179011410U && riffhdr._type != 1163280727U)
			{
				return null;
			}
			AudioBase.BLOCKHDR blockhdr = default(AudioBase.BLOCKHDR);
			blockhdr._id = br.ReadUInt32();
			blockhdr._len = br.ReadInt32();
			if (blockhdr._id != 544501094U)
			{
				return null;
			}
			byte[] array = br.ReadBytes(blockhdr._len);
			if (blockhdr._len == 16)
			{
				byte[] array2 = new byte[18];
				Array.Copy(array, array2, 16);
				array = array2;
			}
			return array;
		}
		internal static void WriteWaveHeader(Stream stream, WAVEFORMATEX waveEx, long position, int cData)
		{
			AudioBase.RIFFHDR riffhdr = new AudioBase.RIFFHDR(0);
			AudioBase.BLOCKHDR blockhdr = new AudioBase.BLOCKHDR(0);
			AudioBase.DATAHDR datahdr = new AudioBase.DATAHDR(0);
			int num = Marshal.SizeOf(riffhdr);
			int num2 = Marshal.SizeOf(blockhdr);
			int length = waveEx.Length;
			int num3 = Marshal.SizeOf(datahdr);
			int num4 = num + num2 + length + num3;
			using (MemoryStream memoryStream = new MemoryStream())
			{
				BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
				try
				{
					riffhdr._len = num4 + cData - 8;
					binaryWriter.Write(riffhdr._id);
					binaryWriter.Write(riffhdr._len);
					binaryWriter.Write(riffhdr._type);
					blockhdr._len = length;
					binaryWriter.Write(blockhdr._id);
					binaryWriter.Write(blockhdr._len);
					binaryWriter.Write(waveEx.ToBytes());
					datahdr._len = cData;
					binaryWriter.Write(datahdr._id);
					binaryWriter.Write(datahdr._len);
					stream.Seek(position, SeekOrigin.Begin);
					stream.Write(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
				}
				finally
				{
					((IDisposable)binaryWriter).Dispose();
				}
			}
		}
		internal abstract TimeSpan Duration { get; }
		internal virtual long Position
		{
			get
			{
				return 0L;
			}
		}
		internal virtual bool IsAborted
		{
			get
			{
				return this._aborted;
			}
			set
			{
				this._aborted = false;
			}
		}
		internal virtual byte[] WaveFormat
		{
			get
			{
				return null;
			}
		}
		private const uint RIFF_MARKER = 1179011410U;
		private const uint WAVE_MARKER = 1163280727U;
		private const uint FMT_MARKER = 544501094U;
		private const uint DATA_MARKER = 1635017060U;
		protected bool _aborted;
		private struct RIFFHDR
		{
			internal RIFFHDR(int length)
			{
				this._id = 1179011410U;
				this._type = 1163280727U;
				this._len = length;
			}
			internal uint _id;
			internal int _len;
			internal uint _type;
		}
		private struct BLOCKHDR
		{
			internal BLOCKHDR(int length)
			{
				this._id = 544501094U;
				this._len = length;
			}
			internal uint _id;
			internal int _len;
		}
		private struct DATAHDR
		{
			internal DATAHDR(int length)
			{
				this._id = 1635017060U;
				this._len = length;
			}
			internal uint _id;
			internal int _len;
		}
	}
}

ConvertTextFrag.cs

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Speech.Synthesis.TtsEngine;

namespace System.Speech.Internal.Synthesis
{
	internal static class ConvertTextFrag
	{
		internal static bool ToSapi(List<TextFragment> ssmlFrags, ref GCHandle sapiFragLast)
		{
			bool flag = true;
			for (int i = ssmlFrags.Count - 1; i >= 0; i--)
			{
				TextFragment textFragment = ssmlFrags[i];
				if (textFragment.State.Action != TtsEngineAction.StartParagraph && textFragment.State.Action != TtsEngineAction.StartSentence)
				{
					SPVTEXTFRAG spvtextfrag = new SPVTEXTFRAG();
					spvtextfrag.gcNext = (flag ? default(GCHandle) : sapiFragLast);
					spvtextfrag.pNext = (flag ? IntPtr.Zero : sapiFragLast.AddrOfPinnedObject());
					spvtextfrag.gcText = GCHandle.Alloc(textFragment.TextToSpeak, GCHandleType.Pinned);
					spvtextfrag.pTextStart = spvtextfrag.gcText.AddrOfPinnedObject();
					spvtextfrag.ulTextSrcOffset = textFragment.TextOffset;
					spvtextfrag.ulTextLen = textFragment.TextLength;
					SPVSTATE spvstate = default(SPVSTATE);
					FragmentState state = textFragment.State;
					spvstate.eAction = (SPVACTIONS)state.Action;
					spvstate.LangID = (short)state.LangId;
					spvstate.EmphAdj = ((state.Emphasis != 1) ? 0 : 1);
					if (state.Prosody != null)
					{
						spvstate.RateAdj = ConvertTextFrag.SapiRate(state.Prosody.Rate);
						spvstate.Volume = ConvertTextFrag.SapiVolume(state.Prosody.Volume);
						spvstate.PitchAdj.MiddleAdj = ConvertTextFrag.SapiPitch(state.Prosody.Pitch);
					}
					else
					{
						spvstate.Volume = 100;
					}
					spvstate.ePartOfSpeech = SPPARTOFSPEECH.SPPS_Unknown;
					if (spvstate.eAction == SPVACTIONS.SPVA_Silence)
					{
						spvstate.SilenceMSecs = ConvertTextFrag.SapiSilence(state.Duration, (EmphasisBreak)state.Emphasis);
					}
					if (state.Phoneme != null)
					{
						spvstate.eAction = SPVACTIONS.SPVA_Pronounce;
						spvtextfrag.gcPhoneme = GCHandle.Alloc(state.Phoneme, GCHandleType.Pinned);
						spvstate.pPhoneIds = spvtextfrag.gcPhoneme.AddrOfPinnedObject();
					}
					else
					{
						spvtextfrag.gcPhoneme = default(GCHandle);
						spvstate.pPhoneIds = IntPtr.Zero;
					}
					if (state.SayAs != null)
					{
						string format = state.SayAs.Format;
						string text2;
						string text;
						switch (text = (text2 = state.SayAs.InterpretAs))
						{
						case "spellout":
						case "spell-out":
						case "characters":
						case "letters":
							spvstate.eAction = SPVACTIONS.SPVA_SpellOut;
							goto IL_02E7;
						case "time":
						case "date":
							if (!string.IsNullOrEmpty(format))
							{
								text2 = text2 + ':' + format;
							}
							spvstate.Context.pCategory = ConvertTextFrag.SapiCategory(spvtextfrag, text2, null);
							goto IL_02E7;
						}
						spvstate.Context.pCategory = ConvertTextFrag.SapiCategory(spvtextfrag, text2, format);
					}
					IL_02E7:
					spvtextfrag.State = spvstate;
					sapiFragLast = GCHandle.Alloc(spvtextfrag, GCHandleType.Pinned);
					flag = false;
				}
			}
			return !flag;
		}
		private static IntPtr SapiCategory(SPVTEXTFRAG sapiFrag, string interpretAs, string format)
		{
			int num = Array.BinarySearch<string>(ConvertTextFrag._asSayAsFormat, interpretAs);
			string text = ((num >= 0) ? ConvertTextFrag._asContextFormat[num] : format);
			sapiFrag.gcSayAsCategory = GCHandle.Alloc(text, GCHandleType.Pinned);
			return sapiFrag.gcSayAsCategory.AddrOfPinnedObject();
		}
		internal static void FreeTextSegment(ref GCHandle fragment)
		{
			SPVTEXTFRAG spvtextfrag = (SPVTEXTFRAG)fragment.Target;
			if (spvtextfrag.gcNext.IsAllocated)
			{
				ConvertTextFrag.FreeTextSegment(ref spvtextfrag.gcNext);
				spvtextfrag.gcNext.Free();
			}
			if (spvtextfrag.gcPhoneme.IsAllocated)
			{
				spvtextfrag.gcPhoneme.Free();
			}
			if (spvtextfrag.gcSayAsCategory.IsAllocated)
			{
				spvtextfrag.gcSayAsCategory.Free();
			}
			spvtextfrag.gcText.Free();
		}
		private static int SapiVolume(ProsodyNumber volume)
		{
			int num = 100;
			if (volume.SsmlAttributeId != 2147483647)
			{
				switch (volume.SsmlAttributeId)
				{
				case -7:
					num = 100;
					break;
				case -6:
					num = 80;
					break;
				case -5:
					num = 60;
					break;
				case -4:
					num = 40;
					break;
				case -3:
					num = 20;
					break;
				case -2:
					num = 0;
					break;
				}
				num = (int)((double)(volume.IsNumberPercent ? ((float)num * volume.Number) : volume.Number) + 0.5);
			}
			else
			{
				num = (int)((double)volume.Number + 0.5);
			}
			if (num > 100)
			{
				num = 100;
			}
			if (num < 0)
			{
				num = 0;
			}
			return num;
		}
		private static int SapiSilence(int duration, EmphasisBreak emphasis)
		{
			int num = 1000;
			if (duration > 0)
			{
				num = duration;
			}
			else
			{
				switch (emphasis)
				{
				case EmphasisBreak.ExtraStrong:
					num = 3000;
					break;
				case EmphasisBreak.Strong:
					num = 1750;
					break;
				case EmphasisBreak.Medium:
					num = 1000;
					break;
				case EmphasisBreak.Weak:
					num = 250;
					break;
				case EmphasisBreak.ExtraWeak:
					num = 125;
					break;
				case EmphasisBreak.None:
					num = 10;
					break;
				}
			}
			if (num < 0 || num > 65535)
			{
				num = 1000;
			}
			return num;
		}
		private static int SapiRate(ProsodyNumber rate)
		{
			int num = 0;
			if (rate.SsmlAttributeId != 2147483647)
			{
				switch (rate.SsmlAttributeId)
				{
				case 1:
					num = -9;
					break;
				case 2:
					num = -4;
					break;
				case 4:
					num = 4;
					break;
				case 5:
					num = 9;
					break;
				}
				num = (int)((double)(rate.IsNumberPercent ? ConvertTextFrag.ScaleNumber(rate.Number, num, 10) : num) + 0.5);
			}
			else
			{
				num = ConvertTextFrag.ScaleNumber(rate.Number, 0, 10);
			}
			if (num > 10)
			{
				num = 10;
			}
			if (num < -10)
			{
				num = -10;
			}
			return num;
		}
		private static int SapiPitch(ProsodyNumber pitch)
		{
			int num = 0;
			if (pitch.SsmlAttributeId != 2147483647)
			{
				switch (pitch.SsmlAttributeId)
				{
				case 1:
					num = -9;
					break;
				case 2:
					num = -4;
					break;
				case 4:
					num = 4;
					break;
				case 5:
					num = 9;
					break;
				}
				num = (int)((double)(pitch.IsNumberPercent ? ((float)num * pitch.Number) : pitch.Number) + 0.5);
			}
			if (num > 10)
			{
				num = 10;
			}
			if (num < -10)
			{
				num = -10;
			}
			return num;
		}
		private static int ScaleNumber(float value, int currentValue, int max)
		{
			int num;
			if ((double)value >= 0.01)
			{
				num = (int)(Math.Log((double)value) / Math.Log(3.0) * (double)max + 0.5);
				num += currentValue;
				if (num > max)
				{
					num = max;
				}
				else if (num < -max)
				{
					num = -max;
				}
			}
			else
			{
				num = -max;
			}
			return num;
		}
		private static readonly string[] _asSayAsFormat = new string[]
		{
			"acronym", "address", "cardinal", "currency", "date", "date:d", "date:dm", "date:dmy", "date:m", "date:md",
			"date:mdy", "date:my", "date:ym", "date:ymd", "date:y", "digits", "name", "net", "net:email", "net:uri",
			"ordinal", "spellout", "telephone", "time", "time:hms12", "time:hms24"
		};
		private static readonly string[] _asContextFormat = new string[]
		{
			"name", "address", "number_cardinal", "currency", "date_md", "date_dm", "date_dm", "date_dmy", "date_md", "date_md",
			"date_mdy", "date_my", "date_ym", "date_ymd", "date_year", "number_digit", "name", "web_url", "E-mail_address", "web_url",
			"number_ordinal", "", "phone_number", "time", "time", "time"
		};
	}
}

ISsmlParser.cs

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Speech.Synthesis;
using System.Speech.Synthesis.TtsEngine;
using System.Xml;

namespace System.Speech.Internal.Synthesis
{
	internal interface ISsmlParser
	{
		object ProcessSpeak(string sVersion, string sBaseUri, CultureInfo culture, List<SsmlXmlAttribute> extraNamespace);
		void ProcessText(string text, object voice, ref FragmentState fragmentState, int position, bool fIgnore);
		void ProcessAudio(object voice, string sUri, string baseUri, bool fIgnore);
		void ProcessBreak(object voice, ref FragmentState fragmentState, EmphasisBreak eBreak, int time, bool fIgnore);
		void ProcessDesc(CultureInfo culture);
		void ProcessEmphasis(bool noLevel, EmphasisWord word);
		void ProcessMark(object voice, ref FragmentState fragmentState, string name, bool fIgnore);
		object ProcessTextBlock(bool isParagraph, object voice, ref FragmentState fragmentState, CultureInfo culture, bool newCulture, VoiceGender gender, VoiceAge age);
		void EndProcessTextBlock(bool isParagraph);
		void ProcessPhoneme(ref FragmentState fragmentState, AlphabetType alphabet, string ph, char[] phoneIds);
		void ProcessProsody(string pitch, string range, string rate, string volume, string duration, string points);
		void ProcessSayAs(string interpretAs, string format, string detail);
		void ProcessSub(string alias, object voice, ref FragmentState fragmentState, int position, bool fIgnore);
		object ProcessVoice(string name, CultureInfo culture, VoiceGender gender, VoiceAge age, int variant, bool fNewCulture, List<SsmlXmlAttribute> extraNamespace);
		void ProcessLexicon(Uri uri, string type);
		void EndElement();
		void EndSpeakElement();
		void ProcessUnknownElement(object voice, ref FragmentState fragmentState, XmlReader reader);
		void StartProcessUnknownAttributes(object voice, ref FragmentState fragmentState, string element, List<SsmlXmlAttribute> extraAttributes);
		void EndProcessUnknownAttributes(object voice, ref FragmentState fragmentState, string element, List<SsmlXmlAttribute> extraAttributes);
		void ContainsPexml(string pexmlPrefix);
		bool BeginPromptEngineOutput(object voice);
		void EndPromptEngineOutput(object voice);
		bool ProcessPromptEngineDatabase(object voice, string fname, string delta, string idset);
		bool ProcessPromptEngineDiv(object voice);
		bool ProcessPromptEngineId(object voice, string id);
		bool BeginPromptEngineTts(object voice);
		void EndPromptEngineTts(object voice);
		bool BeginPromptEngineWithTag(object voice, string tag);
		void EndPromptEngineWithTag(object voice, string tag);
		bool BeginPromptEngineRule(object voice, string name);
		void EndPromptEngineRule(object voice, string name);
		string Ssml { get; }
	}
}

VoiceSynthesis.cs

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Speech.AudioFormat;
using System.Speech.Internal.ObjectTokens;
using System.Speech.Synthesis;
using System.Speech.Synthesis.TtsEngine;
using System.Text;
using System.Threading;

namespace System.Speech.Internal.Synthesis
{
	internal sealed class VoiceSynthesis : IDisposable
	{
		internal VoiceSynthesis(WeakReference speechSynthesizer)
		{
			this._asyncWorker = new AsyncSerializedWorker(new WaitCallback(this.ProcessPostData), null);
			this._asyncWorkerUI = new AsyncSerializedWorker(null, AsyncOperationManager.CreateOperation(null));
			this._eventStateChanged = new WaitCallback(this.OnStateChanged);
			this._signalWorkerCallback = new WaitCallback(this.SignalWorkerThread);
			this._speechSyntesizer = speechSynthesizer;
			this._resourceLoader = new ResourceLoader();
			this._site = new EngineSite(this._resourceLoader);
			this._evtPendingSpeak.Reset();
			this._waveOut = new AudioDeviceOut(SAPICategories.DefaultDeviceOut(), this._asyncWorker);
			if (VoiceSynthesis._allVoices == null)
			{
				VoiceSynthesis._allVoices = VoiceSynthesis.BuildInstalledVoices(this);
				if (VoiceSynthesis._allVoices.Count == 0)
				{
					VoiceSynthesis._allVoices = null;
					throw new PlatformNotSupportedException(SR.Get(SRID.SynthesizerVoiceFailed, new object[0]));
				}
			}
			this._installedVoices = new List<InstalledVoice>(VoiceSynthesis._allVoices.Count);
			foreach (InstalledVoice installedVoice in VoiceSynthesis._allVoices)
			{
				this._installedVoices.Add(new InstalledVoice(this, installedVoice.VoiceInfo));
			}
			this._site.VoiceRate = (this._defaultRate = (int)VoiceSynthesis.GetDefaultRate());
			this._workerThread = new Thread(new ThreadStart(this.ThreadProc));
			this._workerThread.IsBackground = true;
			this._workerThread.Start();
			this.SetInterest(this._ttsEvents);
		}
		~VoiceSynthesis()
		{
			this.Dispose(false);
		}
		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}
		internal void Speak(Prompt prompt)
		{
			bool done = false;
			EventHandler<StateChangedEventArgs> eventHandler = delegate(object sender, StateChangedEventArgs args)
			{
				if (prompt.IsCompleted && args.State == SynthesizerState.Ready)
				{
					done = true;
					this._workerWaitHandle.Set();
				}
			};
			try
			{
				this._stateChanged = (EventHandler<StateChangedEventArgs>)Delegate.Combine(this._stateChanged, eventHandler);
				this._asyncWorkerUI.AsyncMode = false;
				this._asyncWorkerUI.WorkItemPending += this._signalWorkerCallback;
				this.QueuePrompt(prompt);
				while (!done && !this._isDisposed)
				{
					this._workerWaitHandle.WaitOne();
					this._asyncWorkerUI.ConsumeQueue();
				}
				if (prompt._exception != null)
				{
					throw prompt._exception;
				}
			}
			finally
			{
				this._asyncWorkerUI.AsyncMode = true;
				this._asyncWorkerUI.WorkItemPending -= this._signalWorkerCallback;
				this._stateChanged = (EventHandler<StateChangedEventArgs>)Delegate.Remove(this._stateChanged, eventHandler);
			}
		}
		internal void SpeakAsync(Prompt prompt)
		{
			this.QueuePrompt(prompt);
		}
		internal void OnSpeakStarted(SpeakStartedEventArgs e)
		{
			if (this._speakStarted != null)
			{
				this._asyncWorkerUI.PostOperation(this._speakStarted, new object[]
				{
					this._speechSyntesizer.Target,
					e
				});
			}
		}
		internal void FireSpeakCompleted(object sender, SpeakCompletedEventArgs e)
		{
			if (this._speakCompleted != null && !e.Prompt._syncSpeak)
			{
				this._speakCompleted(sender, e);
			}
			e.Prompt.Synthesizer = null;
		}
		internal void OnSpeakCompleted(SpeakCompletedEventArgs e)
		{
			e.Prompt.IsCompleted = true;
			this._asyncWorkerUI.PostOperation(new EventHandler<SpeakCompletedEventArgs>(this.FireSpeakCompleted), new object[]
			{
				this._speechSyntesizer.Target,
				e
			});
		}
		internal void OnSpeakProgress(SpeakProgressEventArgs e)
		{
			if (this._speakProgress != null)
			{
				string text = string.Empty;
				if (e.Prompt._media == SynthesisMediaType.Ssml)
				{
					int characterCount = e.CharacterCount;
					text = this.RemoveEscapeString(e.Prompt._text, e.CharacterPosition, characterCount, out characterCount);
					e.CharacterCount = characterCount;
				}
				else
				{
					text = e.Prompt._text.Substring(e.CharacterPosition, e.CharacterCount);
				}
				e.Text = text;
				this._asyncWorkerUI.PostOperation(this._speakProgress, new object[]
				{
					this._speechSyntesizer.Target,
					e
				});
			}
		}
		private string RemoveEscapeString(string text, int start, int length, out int newLength)
		{
			newLength = length;
			int num = text.LastIndexOf('>', start);
			int num2 = num;
			StringBuilder stringBuilder = new StringBuilder(text.Substring(0, num2));
			do
			{
				int num3 = -1;
				int num4 = int.MaxValue;
				for (int i = 0; i < this.xmlEscapeStrings.Length; i++)
				{
					int num5;
					if ((num5 = text.IndexOf(this.xmlEscapeStrings[i], num2, StringComparison.Ordinal)) >= 0 && num4 > num5)
					{
						num4 = num5;
						num3 = i;
					}
				}
				if (num3 < 0)
				{
					num4 = text.Length;
				}
				else if (num4 >= num)
				{
					newLength += this.xmlEscapeStrings[num3].Length - 1;
				}
				else
				{
					num4 += this.xmlEscapeStrings[num3].Length;
					num3 = -1;
				}
				int num6 = num4 - num2;
				stringBuilder.Append(text.Substring(num2, num6));
				if (num3 >= 0)
				{
					stringBuilder.Append(this.xmlEscapeChars[num3]);
					int length2 = this.xmlEscapeStrings[num3].Length;
					num4 += length2;
				}
				num2 = num4;
			}
			while (start + length > stringBuilder.Length);
			return stringBuilder.ToString().Substring(start, length);
		}
		internal void OnBookmarkReached(BookmarkReachedEventArgs e)
		{
			if (this._bookmarkReached != null)
			{
				this._asyncWorkerUI.PostOperation(this._bookmarkReached, new object[]
				{
					this._speechSyntesizer.Target,
					e
				});
			}
		}
		internal void OnVoiceChange(VoiceChangeEventArgs e)
		{
			if (this._voiceChange != null)
			{
				this._asyncWorkerUI.PostOperation(this._voiceChange, new object[]
				{
					this._speechSyntesizer.Target,
					e
				});
			}
		}
		internal void OnPhonemeReached(PhonemeReachedEventArgs e)
		{
			if (this._phonemeReached != null)
			{
				this._asyncWorkerUI.PostOperation(this._phonemeReached, new object[]
				{
					this._speechSyntesizer.Target,
					e
				});
			}
		}
		private void OnVisemeReached(VisemeReachedEventArgs e)
		{
			if (this._visemeReached != null)
			{
				this._asyncWorkerUI.PostOperation(this._visemeReached, new object[]
				{
					this._speechSyntesizer.Target,
					e
				});
			}
		}
		private void OnStateChanged(object o)
		{
			lock (this._thisObjectLock)
			{
				StateChangedEventArgs stateChangedEventArgs = (StateChangedEventArgs)o;
				if (this._stateChanged != null)
				{
					this._asyncWorkerUI.PostOperation(this._stateChanged, new object[]
					{
						this._speechSyntesizer.Target,
						stateChangedEventArgs
					});
				}
			}
		}
		internal void AddEvent<T>(TtsEventId ttsEvent, ref EventHandler<T> internalEventHandler, EventHandler<T> eventHandler) where T : PromptEventArgs
		{
			lock (this._thisObjectLock)
			{
				Helpers.ThrowIfNull(eventHandler, "eventHandler");
				bool flag = internalEventHandler == null;
				internalEventHandler = (EventHandler<T>)Delegate.Combine(internalEventHandler, eventHandler);
				if (flag)
				{
					this._ttsEvents |= 1 << (int)ttsEvent;
					this.SetInterest(this._ttsEvents);
				}
			}
		}
		internal void RemoveEvent<T>(TtsEventId ttsEvent, ref EventHandler<T> internalEventHandler, EventHandler<T> eventHandler) where T : EventArgs
		{
			lock (this._thisObjectLock)
			{
				Helpers.ThrowIfNull(eventHandler, "eventHandler");
				internalEventHandler = (EventHandler<T>)Delegate.Remove(internalEventHandler, eventHandler);
				if (internalEventHandler == null)
				{
					this._ttsEvents &= ~(1 << (int)ttsEvent);
					this.SetInterest(this._ttsEvents);
				}
			}
		}
		internal void SetOutput(Stream stream, SpeechAudioFormatInfo formatInfo, bool headerInfo)
		{
			lock (this._pendingSpeakQueue)
			{
				if (this.State == SynthesizerState.Speaking)
				{
					throw new InvalidOperationException(SR.Get(SRID.SynthesizerSetOutputSpeaking, new object[0]));
				}
				if (this.State == SynthesizerState.Paused)
				{
					throw new InvalidOperationException(SR.Get(SRID.SynthesizerSyncSetOutputWhilePaused, new object[0]));
				}
				lock (this._processingSpeakLock)
				{
					if (stream == null)
					{
						this._waveOut = new AudioDeviceOut(SAPICategories.DefaultDeviceOut(), this._asyncWorker);
					}
					else
					{
						this._waveOut = new AudioFileOut(stream, formatInfo, headerInfo, this._asyncWorker);
					}
				}
			}
		}
		internal void Abort()
		{
			lock (this._pendingSpeakQueue)
			{
				lock (this._site)
				{
					if (this._currentPrompt != null)
					{
						this._site.Abort();
						this._waveOut.Abort();
					}
				}
				lock (this._processingSpeakLock)
				{
					VoiceSynthesis.Parameters[] array = this._pendingSpeakQueue.ToArray();
					foreach (VoiceSynthesis.Parameters parameters in array)
					{
						VoiceSynthesis.ParametersSpeak parametersSpeak = parameters._parameter as VoiceSynthesis.ParametersSpeak;
						if (parametersSpeak != null)
						{
							parametersSpeak._prompt._exception = new OperationCanceledException(SR.Get(SRID.PromptAsyncOperationCancelled, new object[0]));
						}
					}
					this._evtPendingSpeak.Set();
				}
			}
		}
		internal void Abort(Prompt prompt)
		{
			lock (this._pendingSpeakQueue)
			{
				bool flag = false;
				foreach (VoiceSynthesis.Parameters parameters in this._pendingSpeakQueue)
				{
					VoiceSynthesis.ParametersSpeak parametersSpeak = parameters._parameter as VoiceSynthesis.ParametersSpeak;
					if (parametersSpeak._prompt == prompt)
					{
						parametersSpeak._prompt._exception = new OperationCanceledException(SR.Get(SRID.PromptAsyncOperationCancelled, new object[0]));
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					lock (this._site)
					{
						if (this._currentPrompt == prompt)
						{
							this._site.Abort();
							this._waveOut.Abort();
						}
					}
					lock (this._processingSpeakLock)
					{
					}
				}
			}
		}
		internal void Pause()
		{
			lock (this._waveOut)
			{
				if (this._waveOut != null)
				{
					this._waveOut.Pause();
				}
				lock (this._pendingSpeakQueue)
				{
					if (this._pendingSpeakQueue.Count > 0 && this.State == SynthesizerState.Ready)
					{
						this.OnStateChanged(SynthesizerState.Speaking);
					}
					this.OnStateChanged(SynthesizerState.Paused);
				}
			}
		}
		internal void Resume()
		{
			lock (this._waveOut)
			{
				if (this._waveOut != null)
				{
					this._waveOut.Resume();
				}
				lock (this._pendingSpeakQueue)
				{
					if (this._pendingSpeakQueue.Count > 0 || this._currentPrompt != null)
					{
						this.OnStateChanged(SynthesizerState.Speaking);
					}
					else
					{
						if (this.State == SynthesizerState.Paused)
						{
							this.OnStateChanged(SynthesizerState.Speaking);
						}
						this.OnStateChanged(SynthesizerState.Ready);
					}
				}
			}
		}
		internal void AddLexicon(Uri uri, string mediaType)
		{
			LexiconEntry lexiconEntry = new LexiconEntry(uri, mediaType);
			lock (this._processingSpeakLock)
			{
				foreach (LexiconEntry lexiconEntry2 in this._lexicons)
				{
					if (lexiconEntry2._uri.Equals(uri))
					{
						throw new InvalidOperationException(SR.Get(SRID.DuplicatedEntry, new object[0]));
					}
				}
				this._lexicons.Add(lexiconEntry);
			}
		}
		internal void RemoveLexicon(Uri uri)
		{
			lock (this._processingSpeakLock)
			{
				foreach (LexiconEntry lexiconEntry in this._lexicons)
				{
					if (lexiconEntry._uri.Equals(uri))
					{
						this._lexicons.Remove(lexiconEntry);
						return;
					}
				}
				throw new InvalidOperationException(SR.Get(SRID.FileNotFound, new object[] { uri.ToString() }));
			}
		}
		internal TTSVoice GetEngine(string name, CultureInfo culture, VoiceGender gender, VoiceAge age, int variant, bool switchContext)
		{
			TTSVoice ttsvoice = ((this._currentVoice != null) ? this._currentVoice : this.GetVoice(switchContext));
			return this.GetEngineWithVoice(ttsvoice, null, name, culture, gender, age, variant, switchContext);
		}
		internal ReadOnlyCollection<InstalledVoice> GetInstalledVoices(CultureInfo culture)
		{
			if (culture == null || culture == CultureInfo.InvariantCulture)
			{
				return new ReadOnlyCollection<InstalledVoice>(this._installedVoices);
			}
			Collection<InstalledVoice> collection = new Collection<InstalledVoice>();
			foreach (InstalledVoice installedVoice in this._installedVoices)
			{
				if (culture.Equals(installedVoice.VoiceInfo.Culture))
				{
					collection.Add(installedVoice);
				}
			}
			return new ReadOnlyCollection<InstalledVoice>(collection);
		}
		internal Prompt Prompt
		{
			get
			{
				Prompt currentPrompt;
				lock (this._pendingSpeakQueue)
				{
					currentPrompt = this._currentPrompt;
				}
				return currentPrompt;
			}
		}
		internal SynthesizerState State
		{
			get
			{
				return this._synthesizerState;
			}
		}
		internal int Rate
		{
			get
			{
				return this._site.VoiceRate;
			}
			set
			{
				EngineSite site = this._site;
				this._defaultRate = value;
				site.VoiceRate = value;
			}
		}
		internal int Volume
		{
			get
			{
				return this._site.VoiceVolume;
			}
			set
			{
				this._site.VoiceVolume = value;
			}
		}
		internal TTSVoice Voice
		{
			set
			{
				lock (this._defaultVoiceLock)
				{
					if (this._currentVoice == this._defaultVoice && value == null)
					{
						this._defaultVoiceInitialized = false;
					}
					this._currentVoice = value;
				}
			}
		}
		internal TTSVoice CurrentVoice(bool switchContext)
		{
			TTSVoice currentVoice;
			lock (this._defaultVoiceLock)
			{
				if (this._currentVoice == null)
				{
					this.GetVoice(switchContext);
				}
				currentVoice = this._currentVoice;
			}
			return currentVoice;
		}
		private void ThreadProc()
		{
			do
			{
				this._evtPendingSpeak.WaitOne();
				VoiceSynthesis.Parameters parameters;
				lock (this._pendingSpeakQueue)
				{
					if (this._pendingSpeakQueue.Count > 0)
					{
						parameters = this._pendingSpeakQueue.Dequeue();
						VoiceSynthesis.ParametersSpeak parametersSpeak = parameters._parameter as VoiceSynthesis.ParametersSpeak;
						if (parametersSpeak != null)
						{
							lock (this._site)
							{
								if (this._currentPrompt == null && this.State != SynthesizerState.Paused)
								{
									this.OnStateChanged(SynthesizerState.Speaking);
								}
								this._currentPrompt = parametersSpeak._prompt;
								this._waveOut.IsAborted = false;
								goto IL_0096;
							}
						}
						this._currentPrompt = null;
					}
					else
					{
						parameters = null;
					}
					IL_0096:;
				}
				if (parameters != null)
				{
					switch (parameters._action)
					{
					case VoiceSynthesis.Action.GetVoice:
						try
						{
							try
							{
								this._pendingVoice = null;
								this._pendingException = null;
								this._pendingVoice = this.GetProxyEngine((VoiceInfo)parameters._parameter);
							}
							catch (Exception ex)
							{
								this._pendingException = ex;
							}
							goto IL_023F;
						}
						finally
						{
							this._evtPendingGetProxy.Set();
						}
						break;
					case VoiceSynthesis.Action.SpeakText:
						break;
					default:
						goto IL_023F;
					}
					VoiceSynthesis.ParametersSpeak parametersSpeak2 = (VoiceSynthesis.ParametersSpeak)parameters._parameter;
					try
					{
						this.InjectEvent(TtsEventId.StartInputStream, parametersSpeak2._prompt, parametersSpeak2._prompt._exception, null);
						if (parametersSpeak2._prompt._exception == null)
						{
							List<LexiconEntry> list = new List<LexiconEntry>();
							TTSVoice ttsvoice = ((this._currentVoice != null) ? this._currentVoice : this.GetVoice(false));
							SpeakInfo speakInfo = new SpeakInfo(this, ttsvoice);
							if (parametersSpeak2._textToSpeak != null)
							{
								if (!parametersSpeak2._isXml)
								{
									TextFragment textFragment = new TextFragment(new FragmentState
									{
										Action = TtsEngineAction.Speak,
										Prosody = new Prosody()
									}, string.Copy(parametersSpeak2._textToSpeak));
									speakInfo.AddText(ttsvoice, textFragment);
								}
								else
								{
									TextFragmentEngine textFragmentEngine = new TextFragmentEngine(speakInfo, parametersSpeak2._textToSpeak, false, this._resourceLoader, list);
									SsmlParser.Parse(parametersSpeak2._textToSpeak, textFragmentEngine, speakInfo.Voice);
								}
							}
							else
							{
								speakInfo.AddAudio(new AudioData(parametersSpeak2._audioFile, this._resourceLoader));
							}
							list.AddRange(this._lexicons);
							this.SpeakText(speakInfo, parametersSpeak2._prompt, list);
						}
						this.ChangeStateToReady(parametersSpeak2._prompt, parametersSpeak2._prompt._exception);
					}
					catch (Exception ex2)
					{
						this.ChangeStateToReady(parametersSpeak2._prompt, ex2);
					}
				}
				IL_023F:
				lock (this._pendingSpeakQueue)
				{
					if (this._pendingSpeakQueue.Count == 0)
					{
						this._evtPendingSpeak.Reset();
					}
				}
			}
			while (!this._fExitWorkerThread);
			this._synthesizerState = SynthesizerState.Ready;
		}
		private void AddSpeakParameters(VoiceSynthesis.Parameters param)
		{
			lock (this._pendingSpeakQueue)
			{
				this._pendingSpeakQueue.Enqueue(param);
				if (this._pendingSpeakQueue.Count == 1)
				{
					this._evtPendingSpeak.Set();
				}
			}
		}
		private void SpeakText(SpeakInfo speakInfo, Prompt prompt, List<LexiconEntry> lexicons)
		{
			VoiceInfo voiceInfo = null;
			SpeechSeg speechSeg;
			while ((speechSeg = speakInfo.RemoveFirst()) != null)
			{
				TTSVoice voice = speechSeg.Voice;
				if (voice != null && (voiceInfo == null || !voiceInfo.Equals(voice.VoiceInfo)))
				{
					voiceInfo = voice.VoiceInfo;
					this.InjectEvent(TtsEventId.VoiceChange, prompt, null, voiceInfo);
				}
				lock (this._processingSpeakLock)
				{
					if (speechSeg.IsText)
					{
						lock (this._site)
						{
							if (this._waveOut.IsAborted)
							{
								this._waveOut.IsAborted = false;
								throw new OperationCanceledException(SR.Get(SRID.PromptAsyncOperationCancelled, new object[0]));
							}
							this._site.InitRun(this._waveOut, this._defaultRate, prompt);
							this._waveOut.Begin(voice.WaveFormat(this._waveOut.WaveFormat));
						}
						try
						{
							voice.UpdateLexicons(lexicons);
							this._site.SetEventsInterest(this._ttsInterest);
							byte[] array = voice.WaveFormat(this._waveOut.WaveFormat);
							ITtsEngineProxy ttsEngine = voice.TtsEngine;
							if ((this._ttsInterest & 64) != 0 && ttsEngine.EngineAlphabet != AlphabetType.Ipa)
							{
								this._site.EventMapper = new PhonemeEventMapper(this._site, PhonemeEventMapper.PhonemeConversion.SapiToIpa, ttsEngine.AlphabetConverter);
							}
							else
							{
								this._site.EventMapper = null;
							}
							this._site.LastException = null;
							ttsEngine.Speak(speechSeg.FragmentList, array);
							goto IL_0189;
						}
						finally
						{
							this._waveOut.WaitUntilDone();
							this._waveOut.End();
						}
					}
					this._waveOut.PlayWaveFile(speechSeg.Audio);
					speechSeg.Audio.Dispose();
					IL_0189:
					lock (this._site)
					{
						this._currentPrompt = null;
						if (this._waveOut.IsAborted || this._site.LastException != null)
						{
							this._waveOut.IsAborted = false;
							if (this._site.LastException != null)
							{
								Exception lastException = this._site.LastException;
								this._site.LastException = null;
								throw lastException;
							}
							throw new OperationCanceledException(SR.Get(SRID.PromptAsyncOperationCancelled, new object[0]));
						}
					}
				}
			}
		}
		private static uint GetDefaultRate()
		{
			uint num = 0U;
			using (ObjectTokenCategory objectTokenCategory = ObjectTokenCategory.Create("HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Speech\\Voices"))
			{
				if (objectTokenCategory != null)
				{
					objectTokenCategory.TryGetDWORD("DefaultTTSRate", ref num);
				}
			}
			return num;
		}
		private void InjectEvent(TtsEventId evtId, Prompt prompt, Exception exception, VoiceInfo voiceInfo)
		{
			if (evtId == TtsEventId.EndInputStream)
			{
				if (this._site.EventMapper != null)
				{
					this._site.EventMapper.FlushEvent();
				}
				prompt._exception = exception;
			}
			int num = 1 << (int)evtId;
			if ((num & this._ttsInterest) != 0)
			{
				TTSEvent ttsevent = new TTSEvent(evtId, prompt, exception, voiceInfo);
				this._asyncWorker.Post(ttsevent);
			}
		}
		private void OnStateChanged(SynthesizerState state)
		{
			if (this._synthesizerState != state)
			{
				SynthesizerState synthesizerState = this._synthesizerState;
				this._synthesizerState = state;
				if (this._eventStateChanged != null)
				{
					this._asyncWorker.PostOperation(this._eventStateChanged, new object[]
					{
						new StateChangedEventArgs(state, synthesizerState)
					});
				}
			}
		}
		private void ChangeStateToReady(Prompt prompt, Exception exception)
		{
			lock (this._waveOut)
			{
				lock (this._pendingSpeakQueue)
				{
					if (this._pendingSpeakQueue.Count == 0)
					{
						this._currentPrompt = null;
						if (this.State != SynthesizerState.Paused)
						{
							SynthesizerState synthesizerState = this._synthesizerState;
							this._synthesizerState = SynthesizerState.Ready;
							this.InjectEvent(TtsEventId.EndInputStream, prompt, exception, null);
							if (this._eventStateChanged != null)
							{
								this._asyncWorker.PostOperation(this._eventStateChanged, new object[]
								{
									new StateChangedEventArgs(this._synthesizerState, synthesizerState)
								});
							}
						}
						else
						{
							this.InjectEvent(TtsEventId.EndInputStream, prompt, exception, null);
						}
					}
					else
					{
						this.InjectEvent(TtsEventId.EndInputStream, prompt, exception, null);
					}
				}
			}
		}
		private TTSVoice GetVoice(VoiceInfo voiceInfo, bool switchContext)
		{
			TTSVoice ttsvoice = null;
			lock (this._voiceDictionary)
			{
				if (!this._voiceDictionary.TryGetValue(voiceInfo, out ttsvoice))
				{
					if (switchContext)
					{
						this.ExecuteOnBackgroundThread(VoiceSynthesis.Action.GetVoice, voiceInfo);
						ttsvoice = ((this._pendingException == null) ? this._pendingVoice : null);
					}
					else
					{
						ttsvoice = this.GetProxyEngine(voiceInfo);
					}
				}
			}
			return ttsvoice;
		}
		private void ExecuteOnBackgroundThread(VoiceSynthesis.Action action, object parameter)
		{
			lock (this._pendingSpeakQueue)
			{
				this._evtPendingGetProxy.Reset();
				this._pendingSpeakQueue.Enqueue(new VoiceSynthesis.Parameters(action, parameter));
				if (this._pendingSpeakQueue.Count == 1)
				{
					this._evtPendingSpeak.Set();
				}
			}
			this._evtPendingGetProxy.WaitOne();
		}
		private TTSVoice GetEngineWithVoice(TTSVoice defaultVoice, VoiceInfo defaultVoiceId, string name, CultureInfo culture, VoiceGender gender, VoiceAge age, int variant, bool switchContext)
		{
			TTSVoice ttsvoice = null;
			lock (this._enabledVoicesLock)
			{
				if (!string.IsNullOrEmpty(name))
				{
					ttsvoice = this.MatchVoice(name, variant, switchContext);
				}
				if (ttsvoice == null)
				{
					InstalledVoice installedVoice = null;
					if (defaultVoice != null || defaultVoiceId != null)
					{
						installedVoice = InstalledVoice.Find(this._installedVoices, (defaultVoice != null) ? defaultVoice.VoiceInfo : defaultVoiceId);
						if (installedVoice != null && installedVoice.Enabled && variant == 1)
						{
							VoiceInfo voiceInfo = installedVoice.VoiceInfo;
							if (installedVoice.Enabled && voiceInfo.Culture.Equals(culture) && (gender == VoiceGender.NotSet || gender == VoiceGender.Neutral || gender == voiceInfo.Gender) && (age == VoiceAge.NotSet || age == voiceInfo.Age))
							{
								ttsvoice = defaultVoice;
							}
						}
					}
					while (ttsvoice == null && this._installedVoices.Count > 0)
					{
						if (installedVoice == null)
						{
							installedVoice = InstalledVoice.FirstEnabled(this._installedVoices, CultureInfo.CurrentUICulture);
						}
						if (installedVoice == null)
						{
							break;
						}
						ttsvoice = this.MatchVoice(culture, gender, age, variant, switchContext, ref installedVoice);
					}
				}
				if (ttsvoice == null)
				{
					if (defaultVoice == null)
					{
						throw new InvalidOperationException(SR.Get(SRID.SynthesizerVoiceFailed, new object[0]));
					}
					ttsvoice = defaultVoice;
				}
			}
			return ttsvoice;
		}
		private TTSVoice MatchVoice(string name, int variant, bool switchContext)
		{
			TTSVoice ttsvoice = null;
			VoiceInfo voiceInfo = null;
			int num = variant;
			foreach (InstalledVoice installedVoice in this._installedVoices)
			{
				int num2;
				if (installedVoice.Enabled && (num2 = name.IndexOf(installedVoice.VoiceInfo.Name, StringComparison.Ordinal)) >= 0)
				{
					int num3 = num2 + installedVoice.VoiceInfo.Name.Length;
					if ((num2 == 0 || name[num2 - 1] == ' ') && (num3 == name.Length || name[num3] == ' '))
					{
						voiceInfo = installedVoice.VoiceInfo;
						if (num-- == 1)
						{
							break;
						}
					}
				}
			}
			if (voiceInfo != null)
			{
				ttsvoice = this.GetVoice(voiceInfo, switchContext);
			}
			return ttsvoice;
		}
		private TTSVoice MatchVoice(CultureInfo culture, VoiceGender gender, VoiceAge age, int variant, bool switchContext, ref InstalledVoice viDefault)
		{
			TTSVoice ttsvoice = null;
			List<InstalledVoice> list = new List<InstalledVoice>(this._installedVoices);
			for (int i = list.Count - 1; i >= 0; i--)
			{
				if (!list[i].Enabled)
				{
					list.RemoveAt(i);
				}
			}
			while (ttsvoice == null && list.Count > 0)
			{
				InstalledVoice installedVoice = VoiceSynthesis.MatchVoice(viDefault, culture, gender, age, variant, list);
				if (installedVoice != null)
				{
					ttsvoice = this.GetVoice(installedVoice.VoiceInfo, switchContext);
					if (ttsvoice != null)
					{
						break;
					}
					list.Remove(installedVoice);
					installedVoice.SetEnabledFlag(false, switchContext);
					if (installedVoice == viDefault)
					{
						viDefault = null;
						break;
					}
					break;
				}
			}
			return ttsvoice;
		}
		private static InstalledVoice MatchVoice(InstalledVoice defaultTokenInfo, CultureInfo culture, VoiceGender gender, VoiceAge age, int variant, List<InstalledVoice> tokensInfo)
		{
			InstalledVoice installedVoice = defaultTokenInfo;
			int num = VoiceSynthesis.CalcMatchValue(culture, gender, age, installedVoice.VoiceInfo);
			int num2 = -1;
			for (int i = 0; i < tokensInfo.Count; i++)
			{
				InstalledVoice installedVoice2 = tokensInfo[i];
				if (installedVoice2.Enabled)
				{
					int num3 = VoiceSynthesis.CalcMatchValue(culture, gender, age, installedVoice2.VoiceInfo);
					if (installedVoice2.Equals(defaultTokenInfo))
					{
						num2 = i;
					}
					if (num3 > num)
					{
						installedVoice = installedVoice2;
						num = num3;
					}
					if (num3 == 7 && (variant == 1 || num2 >= 0))
					{
						break;
					}
				}
			}
			if (variant > 1)
			{
				tokensInfo[num2] = tokensInfo[0];
				tokensInfo[0] = defaultTokenInfo;
				int num4 = variant;
				do
				{
					foreach (InstalledVoice installedVoice3 in tokensInfo)
					{
						if (installedVoice3.Enabled && VoiceSynthesis.CalcMatchValue(culture, gender, age, installedVoice3.VoiceInfo) == num)
						{
							variant--;
							installedVoice = installedVoice3;
						}
						if (variant == 0)
						{
							break;
						}
					}
					if (variant > 0)
					{
						variant = num4 % (num4 - variant);
					}
				}
				while (variant > 0);
			}
			return installedVoice;
		}
		private static int CalcMatchValue(CultureInfo culture, VoiceGender gender, VoiceAge age, VoiceInfo voiceInfo)
		{
			int num;
			if (voiceInfo != null)
			{
				num = 0;
				CultureInfo culture2 = voiceInfo.Culture;
				if (culture != null && Helpers.CompareInvariantCulture(culture2, culture))
				{
					if (culture.Equals(culture2))
					{
						num |= 4;
					}
					if (gender == VoiceGender.NotSet || voiceInfo.Gender == gender)
					{
						num |= 2;
					}
					if (age == VoiceAge.NotSet || voiceInfo.Age == age)
					{
						num |= 1;
					}
				}
			}
			else
			{
				num = -1;
			}
			return num;
		}
		private TTSVoice GetProxyEngine(VoiceInfo voiceInfo)
		{
			ITtsEngineProxy ttsEngineProxy = this.GetSsmlEngine(voiceInfo);
			if (ttsEngineProxy == null)
			{
				ttsEngineProxy = this.GetComEngine(voiceInfo);
			}
			TTSVoice ttsvoice = null;
			if (ttsEngineProxy != null)
			{
				ttsvoice = new TTSVoice(ttsEngineProxy, voiceInfo);
				this._voiceDictionary.Add(voiceInfo, ttsvoice);
			}
			return ttsvoice;
		}
		private ITtsEngineProxy GetSsmlEngine(VoiceInfo voiceInfo)
		{
			ITtsEngineProxy ttsEngineProxy = null;
			try
			{
				Assembly assembly;
				if (!string.IsNullOrEmpty(voiceInfo.AssemblyName) && (assembly = Assembly.Load(voiceInfo.AssemblyName)) != null)
				{
					Type[] types = assembly.GetTypes();
					TtsEngineSsml ttsEngineSsml = null;
					foreach (Type type in types)
					{
						if (type.IsSubclassOf(typeof(TtsEngineSsml)))
						{
							string[] array2 = new string[] { voiceInfo.Clsid };
							ttsEngineSsml = assembly.CreateInstance(type.ToString(), false, BindingFlags.Default, null, array2, CultureInfo.CurrentUICulture, null) as TtsEngineSsml;
							break;
						}
					}
					if (ttsEngineSsml != null)
					{
						ttsEngineProxy = new TtsProxySsml(ttsEngineSsml, this._site, voiceInfo.Culture.LCID);
					}
				}
			}
			catch (ArgumentException)
			{
			}
			catch (IOException)
			{
			}
			catch (BadImageFormatException)
			{
			}
			return ttsEngineProxy;
		}
		private ITtsEngineProxy GetComEngine(VoiceInfo voiceInfo)
		{
			ITtsEngineProxy ttsEngineProxy = null;
			try
			{
				ObjectToken objectToken = ObjectToken.Open(null, voiceInfo.RegistryKeyPath, false);
				if (objectToken != null)
				{
					object obj = objectToken.CreateObjectFromToken<object>("CLSID");
					if (obj != null)
					{
						ITtsEngineSsml ttsEngineSsml = obj as ITtsEngineSsml;
						if (ttsEngineSsml != null)
						{
							ttsEngineProxy = new TtsProxyCom(ttsEngineSsml, this.ComEngineSite, voiceInfo.Culture.LCID);
						}
						else
						{
							ITtsEngine ttsEngine = obj as ITtsEngine;
							if (ttsEngine != null)
							{
								ttsEngineProxy = new TtsProxySapi(ttsEngine, this.ComEngineSite, voiceInfo.Culture.LCID);
							}
						}
					}
				}
			}
			catch (ArgumentException)
			{
			}
			catch (IOException)
			{
			}
			catch (BadImageFormatException)
			{
			}
			catch (COMException)
			{
			}
			catch (FormatException)
			{
			}
			return ttsEngineProxy;
		}
		private TTSVoice GetVoice(bool switchContext)
		{
			lock (this._defaultVoiceLock)
			{
				if (!this._defaultVoiceInitialized)
				{
					this._defaultVoice = null;
					ObjectToken objectToken = SAPICategories.DefaultToken("Voices");
					if (objectToken != null)
					{
						VoiceGender voiceGender = VoiceGender.NotSet;
						VoiceAge voiceAge = VoiceAge.NotSet;
						SsmlParserHelpers.TryConvertGender(objectToken.Gender.ToLowerInvariant(), out voiceGender);
						SsmlParserHelpers.TryConvertAge(objectToken.Age.ToLowerInvariant(), out voiceAge);
						this._defaultVoice = this.GetEngineWithVoice(null, new VoiceInfo(objectToken), objectToken.TokenName(), objectToken.Culture, voiceGender, voiceAge, 1, switchContext);
						objectToken = null;
					}
					if (this._defaultVoice == null)
					{
						VoiceInfo voiceInfo = ((objectToken != null) ? new VoiceInfo(objectToken) : null);
						this._defaultVoice = this.GetEngineWithVoice(null, voiceInfo, null, CultureInfo.CurrentUICulture, VoiceGender.NotSet, VoiceAge.NotSet, 1, switchContext);
					}
					this._defaultVoiceInitialized = true;
					this._currentVoice = this._defaultVoice;
				}
			}
			return this._defaultVoice;
		}
		private static List<InstalledVoice> BuildInstalledVoices(VoiceSynthesis voiceSynthesizer)
		{
			List<InstalledVoice> list = new List<InstalledVoice>();
			using (ObjectTokenCategory objectTokenCategory = ObjectTokenCategory.Create("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Voices"))
			{
				if (objectTokenCategory != null)
				{
					foreach (ObjectToken objectToken in objectTokenCategory.FindMatchingTokens(null, null))
					{
						if (objectToken != null && objectToken.Attributes != null)
						{
							list.Add(new InstalledVoice(voiceSynthesizer, new VoiceInfo(objectToken)));
						}
					}
				}
			}
			return list;
		}
		private void SignalWorkerThread(object ignored)
		{
			if (!this._asyncWorkerUI.AsyncMode)
			{
				this._workerWaitHandle.Set();
			}
		}
		private void ProcessPostData(object arg)
		{
			TTSEvent ttsevent = arg as TTSEvent;
			if (ttsevent == null)
			{
				return;
			}
			lock (this._thisObjectLock)
			{
				if (!this._isDisposed)
				{
					this.DispatchEvent(ttsevent);
				}
			}
		}
		private void DispatchEvent(TTSEvent ttsEvent)
		{
			Prompt prompt = ttsEvent.Prompt;
			TtsEventId id = ttsEvent.Id;
			prompt._exception = ttsEvent.Exception;
			switch (id)
			{
			case TtsEventId.StartInputStream:
				this.OnSpeakStarted(new SpeakStartedEventArgs(prompt));
				return;
			case TtsEventId.EndInputStream:
				this.OnSpeakCompleted(new SpeakCompletedEventArgs(prompt));
				return;
			case TtsEventId.VoiceChange:
			{
				VoiceInfo voice = ttsEvent.Voice;
				this.OnVoiceChange(new VoiceChangeEventArgs(prompt, voice));
				return;
			}
			case TtsEventId.Bookmark:
				this.OnBookmarkReached(new BookmarkReachedEventArgs(prompt, ttsEvent.Bookmark, ttsEvent.AudioPosition));
				return;
			case TtsEventId.WordBoundary:
				this.OnSpeakProgress(new SpeakProgressEventArgs(prompt, ttsEvent.AudioPosition, (int)ttsEvent.LParam, (int)ttsEvent.WParam));
				return;
			case TtsEventId.Phoneme:
				this.OnPhonemeReached(new PhonemeReachedEventArgs(prompt, ttsEvent.Phoneme, ttsEvent.AudioPosition, ttsEvent.PhonemeDuration, ttsEvent.PhonemeEmphasis, ttsEvent.NextPhoneme));
				return;
			case TtsEventId.SentenceBoundary:
				return;
			case TtsEventId.Viseme:
				this.OnVisemeReached(new VisemeReachedEventArgs(prompt, (int)ttsEvent.LParam & 65535, ttsEvent.AudioPosition, TimeSpan.FromMilliseconds(ttsEvent.WParam >> 16), (SynthesizerEmphasis)((uint)(int)ttsEvent.LParam >> 16), (int)(ttsEvent.WParam & 65535U)));
				return;
			default:
				throw new InvalidOperationException(SR.Get(SRID.SynthesizerUnknownEvent, new object[0]));
			}
		}
		private void Dispose(bool disposing)
		{
			if (!this._isDisposed)
			{
				lock (this._thisObjectLock)
				{
					this._fExitWorkerThread = true;
					this.Abort();
					int num = 0;
					while (num < 20 && this.State != SynthesizerState.Ready)
					{
						Thread.Sleep(100);
						num++;
					}
					if (disposing)
					{
						this._evtPendingSpeak.Set();
						this._workerThread.Join();
						foreach (KeyValuePair<VoiceInfo, TTSVoice> keyValuePair in this._voiceDictionary)
						{
							if (keyValuePair.Value != null)
							{
								keyValuePair.Value.TtsEngine.ReleaseInterface();
							}
						}
						this._voiceDictionary.Clear();
						this._evtPendingSpeak.Close();
						this._evtPendingGetProxy.Close();
						this._workerWaitHandle.Close();
					}
					if (this._iSite != IntPtr.Zero)
					{
						Marshal.Release(this._iSite);
					}
					this._isDisposed = true;
				}
			}
		}
		private void QueuePrompt(Prompt prompt)
		{
			switch (prompt._media)
			{
			case SynthesisMediaType.Text:
				this.Speak(prompt._text, prompt, false);
				return;
			case SynthesisMediaType.Ssml:
				this.Speak(prompt._text, prompt, true);
				return;
			case SynthesisMediaType.WaveAudio:
				this.SpeakStream(prompt._audio, prompt);
				return;
			default:
				throw new ArgumentException(SR.Get(SRID.SynthesizerUnknownMediaType, new object[0]));
			}
		}
		private void Speak(string textToSpeak, Prompt prompt, bool fIsXml)
		{
			Helpers.ThrowIfNull(textToSpeak, "textToSpeak");
			if (this._isDisposed)
			{
				throw new ObjectDisposedException("VoiceSynthesis");
			}
			this.AddSpeakParameters(new VoiceSynthesis.Parameters(VoiceSynthesis.Action.SpeakText, new VoiceSynthesis.ParametersSpeak(textToSpeak, prompt, fIsXml, null)));
		}
		private void SpeakStream(Uri audio, Prompt prompt)
		{
			this.AddSpeakParameters(new VoiceSynthesis.Parameters(VoiceSynthesis.Action.SpeakText, new VoiceSynthesis.ParametersSpeak(null, prompt, false, audio)));
		}
		private void SetInterest(int ttsInterest)
		{
			this._ttsInterest = ttsInterest;
			lock (this._pendingSpeakQueue)
			{
				this._site.SetEventsInterest(this._ttsInterest);
			}
		}
		private IntPtr ComEngineSite
		{
			get
			{
				if (this._iSite == IntPtr.Zero)
				{
					this._siteSapi = new EngineSiteSapi(this._site, this._resourceLoader);
					this._iSite = Marshal.GetComInterfaceForObject(this._siteSapi, typeof(ISpEngineSite));
				}
				return this._iSite;
			}
		}
		private const string defaultVoiceRate = "DefaultTTSRate";
		private const bool _pexml = false;
		internal EventHandler<StateChangedEventArgs> _stateChanged;
		internal EventHandler<SpeakStartedEventArgs> _speakStarted;
		internal EventHandler<SpeakCompletedEventArgs> _speakCompleted;
		internal EventHandler<SpeakProgressEventArgs> _speakProgress;
		internal EventHandler<BookmarkReachedEventArgs> _bookmarkReached;
		internal EventHandler<VoiceChangeEventArgs> _voiceChange;
		internal EventHandler<PhonemeReachedEventArgs> _phonemeReached;
		internal EventHandler<VisemeReachedEventArgs> _visemeReached;
		private WaitCallback _eventStateChanged;
		private WaitCallback _signalWorkerCallback;
		private readonly ResourceLoader _resourceLoader;
		private readonly EngineSite _site;
		private EngineSiteSapi _siteSapi;
		private IntPtr _iSite;
		private int _ttsInterest;
		private ManualResetEvent _evtPendingSpeak = new ManualResetEvent(false);
		private ManualResetEvent _evtPendingGetProxy = new ManualResetEvent(false);
		private Exception _pendingException;
		private Queue<VoiceSynthesis.Parameters> _pendingSpeakQueue = new Queue<VoiceSynthesis.Parameters>();
		private TTSVoice _pendingVoice;
		private Thread _workerThread;
		private bool _fExitWorkerThread;
		private object _processingSpeakLock = new object();
		private Dictionary<VoiceInfo, TTSVoice> _voiceDictionary = new Dictionary<VoiceInfo, TTSVoice>();
		private List<InstalledVoice> _installedVoices;
		private static List<InstalledVoice> _allVoices;
		private object _enabledVoicesLock = new object();
		private TTSVoice _defaultVoice;
		private TTSVoice _currentVoice;
		private bool _defaultVoiceInitialized;
		private object _defaultVoiceLock = new object();
		private AudioBase _waveOut;
		private int _defaultRate;
		private bool _isDisposed;
		private List<LexiconEntry> _lexicons = new List<LexiconEntry>();
		private SynthesizerState _synthesizerState;
		private Prompt _currentPrompt;
		private AsyncSerializedWorker _asyncWorker;
		private AsyncSerializedWorker _asyncWorkerUI;
		private int _ttsEvents = 6;
		private object _thisObjectLock = new object();
		private AutoResetEvent _workerWaitHandle = new AutoResetEvent(false);
		private WeakReference _speechSyntesizer;
		private readonly string[] xmlEscapeStrings = new string[] { "&quot;", "&apos;", "&amp;", "&lt;", "&gt;" };
		private readonly char[] xmlEscapeChars = new char[] { '"', '\'', '&', '<', '>' };
		private enum Action
		{
			GetVoice,
			SpeakText
		}
		private class Parameters
		{
			internal Parameters(VoiceSynthesis.Action action, object parameter)
			{
				this._action = action;
				this._parameter = parameter;
			}
			internal VoiceSynthesis.Action _action;
			internal object _parameter;
		}
		private class ParametersSpeak
		{
			internal ParametersSpeak(string textToSpeak, Prompt prompt, bool isXml, Uri audioFile)
			{
				this._textToSpeak = textToSpeak;
				this._prompt = prompt;
				this._isXml = isXml;
				this._audioFile = audioFile;
			}
			internal string _textToSpeak;
			internal Prompt _prompt;
			internal bool _isXml;
			internal Uri _audioFile;
		}
	}
}

AlphabetConverter.cs

using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Text;

namespace System.Speech.Internal
{
	internal class AlphabetConverter
	{
		internal AlphabetConverter(int langId)
		{
			this._currentLangId = -1;
			this.SetLanguageId(langId);
		}
		internal char[] SapiToIpa(char[] phonemes)
		{
			return this.Convert(phonemes, true);
		}
		internal char[] IpaToSapi(char[] phonemes)
		{
			return this.Convert(phonemes, false);
		}
		internal bool IsPrefix(string phonemes, bool isSapi)
		{
			return this._phoneMap.IsPrefix(phonemes, isSapi);
		}
		internal bool IsConvertibleUnit(string phonemes, bool isSapi)
		{
			return this._phoneMap.ConvertPhoneme(phonemes, isSapi) != null;
		}
		internal int SetLanguageId(int langId)
		{
			if (langId < 0)
			{
				throw new ArgumentException(SR.Get(SRID.MustBeGreaterThanZero, new object[0]), "langId");
			}
			if (langId == this._currentLangId)
			{
				return this._currentLangId;
			}
			int currentLangId = this._currentLangId;
			int num = 0;
			while (num < AlphabetConverter._langIds.Length && AlphabetConverter._langIds[num] != langId)
			{
				num++;
			}
			if (num == AlphabetConverter._langIds.Length)
			{
				this._currentLangId = langId;
				this._phoneMap = null;
			}
			else
			{
				lock (AlphabetConverter._staticLock)
				{
					if (AlphabetConverter._phoneMaps[num] == null)
					{
						AlphabetConverter._phoneMaps[num] = this.CreateMap(AlphabetConverter._resourceNames[num]);
					}
					this._phoneMap = AlphabetConverter._phoneMaps[num];
					this._currentLangId = langId;
				}
			}
			return currentLangId;
		}
		private char[] Convert(char[] phonemes, bool isSapi)
		{
			if (this._phoneMap == null || phonemes.Length == 0)
			{
				return (char[])phonemes.Clone();
			}
			StringBuilder stringBuilder = new StringBuilder();
			string text = new string(phonemes);
			string text2 = null;
			int num;
			int i = (num = 0);
			int num2 = -1;
			while (i < text.Length)
			{
				string text3 = text.Substring(num, i - num + 1);
				if (this._phoneMap.IsPrefix(text3, isSapi))
				{
					string text4 = this._phoneMap.ConvertPhoneme(text3, isSapi);
					if (text4 != null)
					{
						text2 = text4;
						num2 = i;
					}
				}
				else
				{
					if (text2 == null)
					{
						break;
					}
					stringBuilder.Append(text2);
					i = num2;
					num = num2 + 1;
					text2 = null;
				}
				i++;
			}
			if (text2 != null && num2 == phonemes.Length - 1)
			{
				stringBuilder.Append(text2);
				return stringBuilder.ToString().ToCharArray();
			}
			return null;
		}
		private AlphabetConverter.PhoneMapData CreateMap(string resourceName)
		{
			Assembly assembly = Assembly.GetAssembly(base.GetType());
			Stream manifestResourceStream = assembly.GetManifestResourceStream(resourceName);
			if (manifestResourceStream == null)
			{
				throw new FileLoadException(SR.Get(SRID.CannotLoadResourceFromManifest, new object[] { resourceName, assembly.FullName }));
			}
			return new AlphabetConverter.PhoneMapData(new BufferedStream(manifestResourceStream));
		}
		private int _currentLangId;
		private AlphabetConverter.PhoneMapData _phoneMap;
		private static int[] _langIds = new int[] { 2052, 1028, 1031, 1033, 1034, 1036, 1041 };
		private static string[] _resourceNames = new string[] { "upstable_chs.upsmap", "upstable_cht.upsmap", "upstable_deu.upsmap", "upstable_enu.upsmap", "upstable_esp.upsmap", "upstable_fra.upsmap", "upstable_jpn.upsmap" };
		private static AlphabetConverter.PhoneMapData[] _phoneMaps = new AlphabetConverter.PhoneMapData[7];
		private static object _staticLock = new object();
		internal class PhoneMapData
		{
			internal PhoneMapData(Stream input)
			{
				using (BinaryReader binaryReader = new BinaryReader(input, Encoding.Unicode))
				{
					int num = binaryReader.ReadInt32();
					this.convertTable = new AlphabetConverter.PhoneMapData.ConversionUnit[num];
					for (int i = 0; i < num; i++)
					{
						this.convertTable[i] = new AlphabetConverter.PhoneMapData.ConversionUnit();
						this.convertTable[i].sapi = AlphabetConverter.PhoneMapData.ReadPhoneString(binaryReader);
						this.convertTable[i].ups = AlphabetConverter.PhoneMapData.ReadPhoneString(binaryReader);
						this.convertTable[i].isDefault = binaryReader.ReadInt32() != 0;
					}
					this.prefixSapiTable = this.InitializePrefix(true);
					this.prefixUpsTable = this.InitializePrefix(false);
				}
			}
			internal bool IsPrefix(string prefix, bool isSapi)
			{
				if (isSapi)
				{
					return this.prefixSapiTable.ContainsKey(prefix);
				}
				return this.prefixUpsTable.ContainsKey(prefix);
			}
			internal string ConvertPhoneme(string phoneme, bool isSapi)
			{
				AlphabetConverter.PhoneMapData.ConversionUnit conversionUnit;
				if (isSapi)
				{
					conversionUnit = (AlphabetConverter.PhoneMapData.ConversionUnit)this.prefixSapiTable[phoneme];
				}
				else
				{
					conversionUnit = (AlphabetConverter.PhoneMapData.ConversionUnit)this.prefixUpsTable[phoneme];
				}
				if (conversionUnit == null)
				{
					return null;
				}
				if (!isSapi)
				{
					return conversionUnit.sapi;
				}
				return conversionUnit.ups;
			}
			private Hashtable InitializePrefix(bool isSapi)
			{
				Hashtable hashtable = Hashtable.Synchronized(new Hashtable());
				for (int i = 0; i < this.convertTable.Length; i++)
				{
					string text;
					if (isSapi)
					{
						text = this.convertTable[i].sapi;
					}
					else
					{
						text = this.convertTable[i].ups;
					}
					int num = 0;
					while (num + 1 < text.Length)
					{
						string text2 = text.Substring(0, num + 1);
						if (!hashtable.ContainsKey(text2))
						{
							hashtable[text2] = null;
						}
						num++;
					}
					if (this.convertTable[i].isDefault || hashtable[text] == null)
					{
						hashtable[text] = this.convertTable[i];
					}
				}
				return hashtable;
			}
			private static string ReadPhoneString(BinaryReader reader)
			{
				int num = (int)(reader.ReadInt16() / 2);
				char[] array = reader.ReadChars(num);
				return new string(array, 0, num - 1);
			}
			private Hashtable prefixSapiTable;
			private Hashtable prefixUpsTable;
			private AlphabetConverter.PhoneMapData.ConversionUnit[] convertTable;
			private class ConversionUnit
			{
				public string sapi;
				public string ups;
				public bool isDefault;
			}
		}
	}
}

AsyncSerializedWorker.cs

using System;
using System.Collections;
using System.ComponentModel;
using System.Threading;

namespace System.Speech.Internal
{
	internal class AsyncSerializedWorker : IAsyncDispatch
	{
		internal AsyncSerializedWorker(WaitCallback defaultCallback, AsyncOperation asyncOperation)
		{
			this._asyncOperation = asyncOperation;
			this._workerPostCallback = new SendOrPostCallback(this.WorkerProc);
			this.Initialize(defaultCallback);
		}
		private void Initialize(WaitCallback defaultCallback)
		{
			this._queue = new Queue();
			this._hasPendingPost = false;
			this._workerCallback = new WaitCallback(this.WorkerProc);
			this._defaultCallback = defaultCallback;
			this._isAsyncMode = true;
			this._isEnabled = true;
		}
		public void Post(object evt)
		{
			this.AddItem(new AsyncWorkItem(this.DefaultCallback, new object[] { evt }));
		}
		public void Post(object[] evt)
		{
			lock (this._queue.SyncRoot)
			{
				if (this.Enabled)
				{
					for (int i = 0; i < evt.Length; i++)
					{
						this.AddItem(new AsyncWorkItem(this.DefaultCallback, new object[] { evt[i] }));
					}
				}
			}
		}
		public void PostOperation(Delegate callback, params object[] parameters)
		{
			this.AddItem(new AsyncWorkItem(callback, parameters));
		}
		internal bool Enabled
		{
			get
			{
				bool isEnabled;
				lock (this._queue.SyncRoot)
				{
					isEnabled = this._isEnabled;
				}
				return isEnabled;
			}
			set
			{
				lock (this._queue.SyncRoot)
				{
					this._isEnabled = value;
				}
			}
		}
		internal void Purge()
		{
			lock (this._queue.SyncRoot)
			{
				this._queue.Clear();
			}
		}
		internal WaitCallback DefaultCallback
		{
			get
			{
				WaitCallback defaultCallback;
				lock (this._queue.SyncRoot)
				{
					defaultCallback = this._defaultCallback;
				}
				return defaultCallback;
			}
		}
		internal AsyncWorkItem NextWorkItem()
		{
			AsyncWorkItem asyncWorkItem;
			lock (this._queue.SyncRoot)
			{
				if (this._queue.Count == 0)
				{
					asyncWorkItem = null;
				}
				else
				{
					AsyncWorkItem asyncWorkItem2 = (AsyncWorkItem)this._queue.Dequeue();
					if (this._queue.Count == 0)
					{
						this._hasPendingPost = false;
					}
					asyncWorkItem = asyncWorkItem2;
				}
			}
			return asyncWorkItem;
		}
		internal void ConsumeQueue()
		{
			AsyncWorkItem asyncWorkItem;
			while ((asyncWorkItem = this.NextWorkItem()) != null)
			{
				asyncWorkItem.Invoke();
			}
		}
		internal bool AsyncMode
		{
			get
			{
				bool isAsyncMode;
				lock (this._queue.SyncRoot)
				{
					isAsyncMode = this._isAsyncMode;
				}
				return isAsyncMode;
			}
			set
			{
				bool flag = false;
				lock (this._queue.SyncRoot)
				{
					if (this._isAsyncMode != value)
					{
						this._isAsyncMode = value;
						if (this._queue.Count > 0)
						{
							flag = true;
						}
					}
				}
				if (flag)
				{
					this.OnWorkItemPending();
				}
			}
		}
		internal event WaitCallback WorkItemPending;

		private void AddItem(AsyncWorkItem item)
		{
			bool flag = true;
			lock (this._queue.SyncRoot)
			{
				if (this.Enabled)
				{
					this._queue.Enqueue(item);
					if (!this._hasPendingPost || !this._isAsyncMode)
					{
						flag = false;
						this._hasPendingPost = true;
					}
				}
			}
			if (!flag)
			{
				this.OnWorkItemPending();
			}
		}
		private void WorkerProc(object ignored)
		{
			for (;;)
			{
				AsyncWorkItem asyncWorkItem;
				lock (this._queue.SyncRoot)
				{
					if (this._queue.Count <= 0 || !this._isAsyncMode)
					{
						if (this._queue.Count == 0)
						{
							this._hasPendingPost = false;
						}
						break;
					}
					asyncWorkItem = (AsyncWorkItem)this._queue.Dequeue();
				}
				asyncWorkItem.Invoke();
			}
		}
		private void OnWorkItemPending()
		{
			if (this._hasPendingPost)
			{
				if (this.AsyncMode)
				{
					if (this._asyncOperation == null)
					{
						ThreadPool.QueueUserWorkItem(this._workerCallback, null);
						return;
					}
					this._asyncOperation.Post(this._workerPostCallback, null);
					return;
				}
				else if (this.WorkItemPending != null)
				{
					this.WorkItemPending(null);
				}
			}
		}
		private AsyncOperation _asyncOperation;
		private SendOrPostCallback _workerPostCallback;
		private Queue _queue;
		private bool _hasPendingPost;
		private bool _isAsyncMode;
		private WaitCallback _workerCallback;
		private WaitCallback _defaultCallback;
		private bool _isEnabled;
	}
}

Helpers.cs

using System;
using System.Globalization;
using System.IO;

namespace System.Speech.Internal
{
	internal static class Helpers
	{
		internal static void ThrowIfEmptyOrNull(string s, string paramName)
		{
			if (!string.IsNullOrEmpty(s))
			{
				return;
			}
			if (s == null)
			{
				throw new ArgumentNullException(paramName);
			}
			throw new ArgumentException(SR.Get(SRID.StringCanNotBeEmpty, new object[] { paramName }), paramName);
		}
		internal static void ThrowIfNull(object value, string paramName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(paramName);
			}
		}
		internal static bool CompareInvariantCulture(CultureInfo culture1, CultureInfo culture2)
		{
			if (culture1.Equals(culture2))
			{
				return true;
			}
			while (!culture1.IsNeutralCulture)
			{
				culture1 = culture1.Parent;
			}
			while (!culture2.IsNeutralCulture)
			{
				culture2 = culture2.Parent;
			}
			return culture1.Equals(culture2);
		}
		internal static void CopyStream(Stream inputStream, Stream outputStream, int bytesToCopy)
		{
			int num = ((bytesToCopy > 4096) ? 4096 : bytesToCopy);
			byte[] array = new byte[num];
			while (bytesToCopy > 0)
			{
				int num2 = inputStream.Read(array, 0, num);
				if (num2 <= 0)
				{
					throw new EndOfStreamException(SR.Get(SRID.StreamEndedUnexpectedly, new object[0]));
				}
				outputStream.Write(array, 0, num2);
				bytesToCopy -= num2;
			}
		}
		internal static byte[] ReadStreamToByteArray(Stream inputStream, int bytesToCopy)
		{
			byte[] array = new byte[bytesToCopy];
			Helpers.BlockingRead(inputStream, array, 0, bytesToCopy);
			return array;
		}
		internal static void BlockingRead(Stream stream, byte[] buffer, int offset, int count)
		{
			while (count > 0)
			{
				int num = stream.Read(buffer, offset, count);
				if (num <= 0)
				{
					throw new EndOfStreamException();
				}
				count -= num;
				offset += num;
			}
		}
		internal static void CombineCulture(string language, string location, CultureInfo parentCulture, int layoutId)
		{
			CultureInfo cultureInfo = new CultureInfo(language);
			RegionInfo regionInfo = new RegionInfo(location);
			string text = cultureInfo.TwoLetterISOLanguageName + "-" + regionInfo.TwoLetterISORegionName;
			CultureAndRegionInfoBuilder cultureAndRegionInfoBuilder = new CultureAndRegionInfoBuilder(text, CultureAndRegionModifiers.None);
			cultureAndRegionInfoBuilder.LoadDataFromRegionInfo(regionInfo);
			cultureAndRegionInfoBuilder.LoadDataFromCultureInfo(cultureInfo);
			cultureAndRegionInfoBuilder.IetfLanguageTag = text;
			cultureAndRegionInfoBuilder.Parent = parentCulture;
			cultureAndRegionInfoBuilder.ThreeLetterISOLanguageName = cultureInfo.ThreeLetterISOLanguageName;
			cultureAndRegionInfoBuilder.TwoLetterISOLanguageName = cultureInfo.TwoLetterISOLanguageName;
			cultureAndRegionInfoBuilder.ThreeLetterWindowsLanguageName = cultureInfo.ThreeLetterWindowsLanguageName;
			cultureAndRegionInfoBuilder.RegionNativeName = regionInfo.NativeName;
			string text2 = cultureInfo.EnglishName.Substring(0, cultureInfo.EnglishName.IndexOf("(", StringComparison.Ordinal) - 1);
			string text3 = cultureInfo.NativeName.Substring(0, cultureInfo.NativeName.IndexOf("(", StringComparison.Ordinal) - 1);
			cultureAndRegionInfoBuilder.CultureEnglishName = text2 + " (" + cultureAndRegionInfoBuilder.RegionEnglishName + ")";
			cultureAndRegionInfoBuilder.CultureNativeName = text3 + " (" + cultureAndRegionInfoBuilder.RegionNativeName + ")";
			cultureAndRegionInfoBuilder.CurrencyNativeName = regionInfo.CurrencyNativeName;
			cultureAndRegionInfoBuilder.NumberFormat.PositiveInfinitySymbol = cultureInfo.NumberFormat.PositiveInfinitySymbol;
			cultureAndRegionInfoBuilder.NumberFormat.NegativeInfinitySymbol = cultureInfo.NumberFormat.NegativeInfinitySymbol;
			cultureAndRegionInfoBuilder.NumberFormat.NaNSymbol = cultureInfo.NumberFormat.NaNSymbol;
			DateTimeFormatInfo gregorianDateTimeFormat = cultureAndRegionInfoBuilder.GregorianDateTimeFormat;
			DateTimeFormatInfo dateTimeFormat = cultureInfo.DateTimeFormat;
			dateTimeFormat.Calendar = new GregorianCalendar();
			cultureAndRegionInfoBuilder.KeyboardLayoutId = layoutId;
			gregorianDateTimeFormat.AbbreviatedDayNames = dateTimeFormat.AbbreviatedDayNames;
			gregorianDateTimeFormat.AbbreviatedMonthGenitiveNames = dateTimeFormat.AbbreviatedMonthGenitiveNames;
			gregorianDateTimeFormat.AbbreviatedMonthNames = dateTimeFormat.AbbreviatedMonthNames;
			gregorianDateTimeFormat.DayNames = dateTimeFormat.DayNames;
			gregorianDateTimeFormat.MonthGenitiveNames = dateTimeFormat.MonthGenitiveNames;
			gregorianDateTimeFormat.MonthNames = dateTimeFormat.MonthNames;
			gregorianDateTimeFormat.ShortestDayNames = dateTimeFormat.ShortestDayNames;
			cultureAndRegionInfoBuilder.Register();
		}
		internal const int _sizeOfChar = 2;
		internal static readonly char[] _achTrimChars = new char[] { ' ', '\t', '\n', '\r' };
	}
}

ResourceLoader.cs

using System;
using System.IO;
using System.Net;

namespace System.Speech.Internal
{
	internal class ResourceLoader
	{
		internal Stream LoadFile(Uri uri, out string mimeType, out Uri baseUri, out string localPath)
		{
			localPath = null;
			Stream stream = null;
			if (!uri.IsAbsoluteUri || uri.IsFile)
			{
				string text = (uri.IsAbsoluteUri ? uri.LocalPath : uri.OriginalString);
				try
				{
					stream = new FileStream(text, FileMode.Open, FileAccess.Read, FileShare.Read);
				}
				catch
				{
					if (Directory.Exists(text))
					{
						throw new InvalidOperationException(SR.Get(SRID.CannotReadFromDirectory, new object[] { text }));
					}
					throw;
				}
				baseUri = null;
			}
			else
			{
				try
				{
					stream = ResourceLoader.DownloadData(uri, out baseUri);
				}
				catch (WebException ex)
				{
					throw new IOException(ex.Message, ex);
				}
			}
			mimeType = null;
			return stream;
		}
		internal void UnloadFile(string localPath)
		{
		}
		internal Stream LoadFile(Uri uri, out string localPath, out Uri redirectedUri)
		{
			string text;
			return this.LoadFile(uri, out text, out redirectedUri, out localPath);
		}
		private static Stream DownloadData(Uri uri, out Uri redirectedUri)
		{
			WebRequest webRequest = WebRequest.Create(uri);
			webRequest.Credentials = CredentialCache.DefaultCredentials;
			Stream stream;
			using (HttpWebResponse httpWebResponse = (HttpWebResponse)webRequest.GetResponse())
			{
				using (httpWebResponse.GetResponseStream())
				{
					redirectedUri = httpWebResponse.ResponseUri;
					using (WebClient webClient = new WebClient())
					{
						webClient.UseDefaultCredentials = true;
						stream = new MemoryStream(webClient.DownloadData(redirectedUri));
					}
				}
			}
			return stream;
		}
	}
}

AssemblyInfo.cs

using System;
using System.Diagnostics;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;

[assembly: AssemblyVersion("3.0.0.0")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly: NeutralResourcesLanguage("en")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft (R) Windows (R) Operating System")]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: AssemblyDelaySign(true)]
[assembly: AssemblyKeyFile("d:\\sp1qfe.public.x86fre\\internal\\strongnamekeys\\fake\\windows.snk")]
[assembly: AssemblyFileVersion("6.0.6001.17014")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: PermissionSet(SecurityAction.RequestOptional, Unrestricted = true)]
[assembly: SecurityPermission(SecurityAction.RequestOptional, Unrestricted = true)]
[assembly: RegistryPermission(SecurityAction.RequestOptional, Unrestricted = true)]
[assembly: EnvironmentPermission(SecurityAction.RequestOptional, Unrestricted = true)]
[assembly: FileIOPermission(SecurityAction.RequestOptional, Unrestricted = true)]

SrgsDocument.cs

using System;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Speech.Internal;
using System.Speech.Internal.SrgsCompiler;
using System.Speech.Internal.SrgsParser;
using System.Xml;

namespace System.Speech.Recognition.SrgsGrammar
{
	[Serializable]
	public class SrgsDocument
	{
		public SrgsDocument()
		{
			this._grammar = new SrgsGrammar();
		}
		public SrgsDocument(string path)
		{
			Helpers.ThrowIfEmptyOrNull(path, "path");
			using (XmlTextReader xmlTextReader = new XmlTextReader(path))
			{
				this.Load(xmlTextReader);
			}
		}
		public SrgsDocument(XmlReader srgsGrammar)
		{
			Helpers.ThrowIfNull(srgsGrammar, "srgsGrammar");
			this.Load(srgsGrammar);
		}
		public SrgsDocument(GrammarBuilder builder)
		{
			Helpers.ThrowIfNull(builder, "builder");
			this._grammar = new SrgsGrammar();
			this._grammar.Culture = builder.Culture;
			IElementFactory elementFactory = new SrgsElementFactory(this._grammar);
			builder.CreateGrammar(elementFactory);
		}
		public SrgsDocument(SrgsRule grammarRootRule)
			: this()
		{
			Helpers.ThrowIfNull(grammarRootRule, "grammarRootRule");
			this.Root = grammarRootRule;
			this.Rules.Add(new SrgsRule[] { grammarRootRule });
		}
		public void WriteSrgs(XmlWriter srgsGrammar)
		{
			Helpers.ThrowIfNull(srgsGrammar, "srgsGrammar");
			this._grammar.Validate();
			this._grammar.WriteSrgs(srgsGrammar);
		}
		public Uri XmlBase
		{
			get
			{
				return this._grammar.XmlBase;
			}
			set
			{
				this._grammar.XmlBase = value;
			}
		}
		public CultureInfo Culture
		{
			get
			{
				return this._grammar.Culture;
			}
			set
			{
				Helpers.ThrowIfNull(value, "value");
				if (value.Equals(CultureInfo.InvariantCulture))
				{
					throw new ArgumentException(SR.Get(SRID.InvariantCultureInfo, new object[0]), "value");
				}
				this._grammar.Culture = value;
			}
		}
		public SrgsRule Root
		{
			get
			{
				return this._grammar.Root;
			}
			set
			{
				this._grammar.Root = value;
			}
		}
		public SrgsGrammarMode Mode
		{
			get
			{
				if (this._grammar.Mode != GrammarType.VoiceGrammar)
				{
					return SrgsGrammarMode.Dtmf;
				}
				return SrgsGrammarMode.Voice;
			}
			set
			{
				this._grammar.Mode = ((value == SrgsGrammarMode.Voice) ? GrammarType.VoiceGrammar : GrammarType.DtmfGrammar);
			}
		}
		public SrgsPhoneticAlphabet PhoneticAlphabet
		{
			get
			{
				return (SrgsPhoneticAlphabet)this._grammar.PhoneticAlphabet;
			}
			set
			{
				this._grammar.PhoneticAlphabet = (AlphabetType)value;
				this._grammar.HasPhoneticAlphabetBeenSet = true;
			}
		}
		public SrgsRulesCollection Rules
		{
			get
			{
				return this._grammar.Rules;
			}
		}
		public string Language
		{
			get
			{
				return this._grammar.Language;
			}
			set
			{
				this._grammar.Language = value;
			}
		}
		public string Namespace
		{
			get
			{
				return this._grammar.Namespace;
			}
			set
			{
				this._grammar.Namespace = value;
			}
		}
		public Collection<string> CodeBehind
		{
			get
			{
				return this._grammar.CodeBehind;
			}
		}
		public bool Debug
		{
			get
			{
				return this._grammar.Debug;
			}
			set
			{
				this._grammar.Debug = value;
			}
		}
		public string Script
		{
			get
			{
				return this._grammar.Script;
			}
			set
			{
				Helpers.ThrowIfEmptyOrNull(value, "value");
				this._grammar.Script = value;
			}
		}
		public Collection<string> ImportNamespaces
		{
			get
			{
				return this._grammar.ImportNamespaces;
			}
		}
		public Collection<string> AssemblyReferences
		{
			get
			{
				return this._grammar.AssemblyReferences;
			}
		}
		internal void Load(XmlReader srgsGrammar)
		{
			this._grammar = new SrgsGrammar();
			this._grammar.PhoneticAlphabet = AlphabetType.Sapi;
			new XmlParser(srgsGrammar, null)
			{
				ElementFactory = new SrgsElementFactory(this._grammar)
			}.Parse();
			if (!string.IsNullOrEmpty(srgsGrammar.BaseURI))
			{
				this._baseUri = new Uri(srgsGrammar.BaseURI);
			}
		}
		internal static GrammarOptions TagFormat2GrammarOptions(SrgsTagFormat value)
		{
			GrammarOptions grammarOptions = GrammarOptions.KeyValuePairs;
			switch (value)
			{
			case SrgsTagFormat.MssV1:
				grammarOptions = GrammarOptions.MssV1;
				break;
			case SrgsTagFormat.W3cV1:
				grammarOptions = GrammarOptions.W3cV1;
				break;
			case SrgsTagFormat.KeyValuePairs:
				grammarOptions = GrammarOptions.KeyValuePairSrgs;
				break;
			}
			return grammarOptions;
		}
		internal static SrgsTagFormat GrammarOptions2TagFormat(GrammarOptions value)
		{
			SrgsTagFormat srgsTagFormat = SrgsTagFormat.Default;
			GrammarOptions grammarOptions = value & GrammarOptions.TagFormat;
			switch (grammarOptions)
			{
			case GrammarOptions.KeyValuePairs:
			case GrammarOptions.KeyValuePairSrgs:
				srgsTagFormat = SrgsTagFormat.KeyValuePairs;
				break;
			case GrammarOptions.MssV1:
				srgsTagFormat = SrgsTagFormat.MssV1;
				break;
			default:
				if (grammarOptions == GrammarOptions.W3cV1)
				{
					srgsTagFormat = SrgsTagFormat.W3cV1;
				}
				break;
			}
			return srgsTagFormat;
		}
		internal SrgsTagFormat TagFormat
		{
			set
			{
				this._grammar.TagFormat = value;
			}
		}
		internal Uri BaseUri
		{
			get
			{
				return this._baseUri;
			}
		}
		internal SrgsGrammar Grammar
		{
			get
			{
				return this._grammar;
			}
		}
		private SrgsGrammar _grammar;
		private Uri _baseUri;
	}
}

SrgsGrammar.cs

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Speech.Internal;
using System.Speech.Internal.SrgsParser;
using System.Xml;

namespace System.Speech.Recognition.SrgsGrammar
{
	[Serializable]
	internal sealed class SrgsGrammar : IGrammar, IElement
	{
		internal SrgsGrammar()
		{
			this._rules = new SrgsRulesCollection();
		}
		internal void WriteSrgs(XmlWriter writer)
		{
			writer.WriteStartElement("grammar", "http://www.w3.org/2001/06/grammar");
			writer.WriteAttributeString("xml", "lang", null, this._culture.ToString());
			if (this._root != null)
			{
				writer.WriteAttributeString("root", this._root.Id);
			}
			this.WriteSTGAttributes(writer);
			if (this._isModeSet)
			{
				switch (this._mode)
				{
				case SrgsGrammarMode.Voice:
					writer.WriteAttributeString("mode", "voice");
					break;
				case SrgsGrammarMode.Dtmf:
					writer.WriteAttributeString("mode", "dtmf");
					break;
				}
			}
			string text = null;
			switch (this._tagFormat)
			{
			case SrgsTagFormat.MssV1:
				text = "semantics-ms/1.0";
				break;
			case SrgsTagFormat.W3cV1:
				text = "semantics/1.0";
				break;
			case SrgsTagFormat.KeyValuePairs:
				text = "properties-ms/1.0";
				break;
			}
			if (text != null)
			{
				writer.WriteAttributeString("tag-format", text);
			}
			if (this._hasPhoneticAlphabetBeenSet || (this._phoneticAlphabet != SrgsPhoneticAlphabet.Sapi && this.HasPronunciation))
			{
				string text2 = ((this._phoneticAlphabet == SrgsPhoneticAlphabet.Ipa) ? "ipa" : ((this._phoneticAlphabet == SrgsPhoneticAlphabet.Ups) ? "x-microsoft-ups" : "x-microsoft-sapi"));
				writer.WriteAttributeString("sapi", "alphabet", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", text2);
			}
			if (this._xmlBase != null)
			{
				writer.WriteAttributeString("xml:base", this._xmlBase.ToString());
			}
			writer.WriteAttributeString("version", "1.0");
			writer.WriteAttributeString("xmlns", "http://www.w3.org/2001/06/grammar");
			if (this._isSapiExtensionUsed)
			{
				writer.WriteAttributeString("xmlns", "sapi", null, "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions");
			}
			foreach (SrgsRule srgsRule in this._rules)
			{
				srgsRule.Validate(this);
			}
			foreach (string text3 in this._globalTags)
			{
				writer.WriteElementString("tag", text3);
			}
			this.WriteGrammarElements(writer);
			writer.WriteEndElement();
		}
		internal void Validate()
		{
			this.HasPronunciation = (this.HasSapiExtension = false);
			foreach (SrgsRule srgsRule in this._rules)
			{
				srgsRule.Validate(this);
			}
			this._isSapiExtensionUsed |= this.HasPronunciation;
			this._fContainsCode |= this._language != null || this._script.Length > 0 || this._usings.Count > 0 || this._assemblyReferences.Count > 0 || this._codebehind.Count > 0 || this._namespace != null || this._fDebug;
			this._isSapiExtensionUsed |= this._fContainsCode;
			if (!this.HasPronunciation)
			{
				this.PhoneticAlphabet = AlphabetType.Sapi;
			}
			if (this._root != null && !this._rules.Contains(this._root))
			{
				XmlParser.ThrowSrgsException(SRID.RootNotDefined, new object[] { this._root.Id });
			}
			if (this._globalTags.Count > 0)
			{
				this._tagFormat = SrgsTagFormat.W3cV1;
			}
			if (this._fContainsCode)
			{
				if (this._tagFormat == SrgsTagFormat.Default)
				{
					this._tagFormat = SrgsTagFormat.KeyValuePairs;
				}
				if (this._tagFormat != SrgsTagFormat.KeyValuePairs)
				{
					XmlParser.ThrowSrgsException(SRID.InvalidSemanticProcessingType, new object[0]);
				}
			}
		}
		IRule IGrammar.CreateRule(string id, RulePublic publicRule, RuleDynamic dynamic, bool hasScript)
		{
			SrgsRule srgsRule = new SrgsRule(id);
			if (publicRule != RulePublic.NotSet)
			{
				srgsRule.Scope = ((publicRule == RulePublic.True) ? SrgsRuleScope.Public : SrgsRuleScope.Private);
			}
			srgsRule.Dynamic = dynamic;
			return srgsRule;
		}
		void IElement.PostParse(IElement parent)
		{
			if (this._sRoot != null)
			{
				bool flag = false;
				foreach (SrgsRule srgsRule in this.Rules)
				{
					if (srgsRule.Id == this._sRoot)
					{
						this.Root = srgsRule;
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					XmlParser.ThrowSrgsException(SRID.RootNotDefined, new object[] { this._sRoot });
				}
			}
			foreach (XmlParser.ForwardReference forwardReference in this._scriptsForwardReference)
			{
				SrgsRule srgsRule2 = this.Rules[forwardReference._name];
				if (srgsRule2 != null)
				{
					srgsRule2.Script += forwardReference._value;
				}
				else
				{
					XmlParser.ThrowSrgsException(SRID.InvalidScriptDefinition, new object[0]);
				}
			}
			this.Validate();
		}
		internal void AddScript(string rule, string code)
		{
			if (rule == null)
			{
				this._script += code;
				return;
			}
			this._scriptsForwardReference.Add(new XmlParser.ForwardReference(rule, code));
		}
		string IGrammar.Root
		{
			get
			{
				return this._sRoot;
			}
			set
			{
				this._sRoot = value;
			}
		}
		public Uri XmlBase
		{
			get
			{
				return this._xmlBase;
			}
			set
			{
				this._xmlBase = value;
			}
		}
		public CultureInfo Culture
		{
			get
			{
				return this._culture;
			}
			set
			{
				Helpers.ThrowIfNull(value, "value");
				this._culture = value;
			}
		}
		public GrammarType Mode
		{
			get
			{
				if (this._mode != SrgsGrammarMode.Voice)
				{
					return GrammarType.DtmfGrammar;
				}
				return GrammarType.VoiceGrammar;
			}
			set
			{
				this._mode = ((value == GrammarType.VoiceGrammar) ? SrgsGrammarMode.Voice : SrgsGrammarMode.Dtmf);
				this._isModeSet = true;
			}
		}
		public AlphabetType PhoneticAlphabet
		{
			get
			{
				return (AlphabetType)this._phoneticAlphabet;
			}
			set
			{
				this._phoneticAlphabet = (SrgsPhoneticAlphabet)value;
			}
		}
		public SrgsRule Root
		{
			get
			{
				return this._root;
			}
			set
			{
				this._root = value;
			}
		}
		public SrgsTagFormat TagFormat
		{
			get
			{
				return this._tagFormat;
			}
			set
			{
				this._tagFormat = value;
			}
		}
		public Collection<string> GlobalTags
		{
			get
			{
				return this._globalTags;
			}
			set
			{
				this._globalTags = value;
			}
		}
		public string Language
		{
			get
			{
				return this._language;
			}
			set
			{
				this._language = value;
			}
		}
		public string Namespace
		{
			get
			{
				return this._namespace;
			}
			set
			{
				this._namespace = value;
			}
		}
		public Collection<string> CodeBehind
		{
			get
			{
				return this._codebehind;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}
		public bool Debug
		{
			get
			{
				return this._fDebug;
			}
			set
			{
				this._fDebug = value;
			}
		}
		public string Script
		{
			get
			{
				return this._script;
			}
			set
			{
				Helpers.ThrowIfEmptyOrNull(value, "value");
				this._script = value;
			}
		}
		public Collection<string> ImportNamespaces
		{
			get
			{
				return this._usings;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}
		public Collection<string> AssemblyReferences
		{
			get
			{
				return this._assemblyReferences;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}
		internal SrgsRulesCollection Rules
		{
			get
			{
				return this._rules;
			}
		}
		internal bool HasPronunciation
		{
			get
			{
				return this._hasPronunciation;
			}
			set
			{
				this._hasPronunciation = value;
			}
		}
		internal bool HasPhoneticAlphabetBeenSet
		{
			set
			{
				this._hasPhoneticAlphabetBeenSet = value;
			}
		}
		internal bool HasSapiExtension
		{
			get
			{
				return this._isSapiExtensionUsed;
			}
			set
			{
				this._isSapiExtensionUsed = value;
			}
		}
		private void WriteSTGAttributes(XmlWriter writer)
		{
			if (this._language != null)
			{
				writer.WriteAttributeString("sapi", "language", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this._language);
			}
			if (this._namespace != null)
			{
				writer.WriteAttributeString("sapi", "namespace", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this._namespace);
			}
			foreach (string text in this._codebehind)
			{
				if (!string.IsNullOrEmpty(text))
				{
					writer.WriteAttributeString("sapi", "codebehind", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", text);
				}
			}
			if (this._fDebug)
			{
				writer.WriteAttributeString("sapi", "debug", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", "True");
			}
		}
		private void WriteGrammarElements(XmlWriter writer)
		{
			foreach (string text in this._assemblyReferences)
			{
				writer.WriteStartElement("sapi", "assemblyReference", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions");
				writer.WriteAttributeString("sapi", "assembly", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", text);
				writer.WriteEndElement();
			}
			foreach (string text2 in this._usings)
			{
				if (!string.IsNullOrEmpty(text2))
				{
					writer.WriteStartElement("sapi", "importNamespace", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions");
					writer.WriteAttributeString("sapi", "namespace", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", text2);
					writer.WriteEndElement();
				}
			}
			this.WriteRules(writer);
			this.WriteGlobalScripts(writer);
		}
		private void WriteRules(XmlWriter writer)
		{
			foreach (SrgsRule srgsRule in this._rules)
			{
				srgsRule.WriteSrgs(writer);
			}
		}
		private void WriteGlobalScripts(XmlWriter writer)
		{
			if (this._script.Length > 0)
			{
				writer.WriteStartElement("sapi", "script", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions");
				writer.WriteCData(this._script);
				writer.WriteEndElement();
			}
		}
		private bool _isSapiExtensionUsed;
		private Uri _xmlBase;
		private CultureInfo _culture = CultureInfo.CurrentUICulture;
		private SrgsGrammarMode _mode;
		private SrgsPhoneticAlphabet _phoneticAlphabet = SrgsPhoneticAlphabet.Ipa;
		private bool _hasPhoneticAlphabetBeenSet;
		private bool _hasPronunciation;
		private SrgsRule _root;
		private SrgsTagFormat _tagFormat;
		private Collection<string> _globalTags = new Collection<string>();
		private bool _isModeSet;
		private SrgsRulesCollection _rules;
		private string _sRoot;
		internal bool _fContainsCode;
		private string _language;
		private Collection<string> _codebehind = new Collection<string>();
		private string _namespace;
		internal bool _fDebug;
		private string _script = string.Empty;
		private List<XmlParser.ForwardReference> _scriptsForwardReference = new List<XmlParser.ForwardReference>();
		private Collection<string> _usings = new Collection<string>();
		private Collection<string> _assemblyReferences = new Collection<string>();
	}
}

SrgsRule.cs

using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Speech.Internal;
using System.Speech.Internal.SrgsParser;
using System.Xml;

namespace System.Speech.Recognition.SrgsGrammar
{
	[DebuggerDisplay("Rule={_id.ToString()} Scope={_scope.ToString()}")]
	[DebuggerTypeProxy(typeof(SrgsRule.SrgsRuleDebugDisplay))]
	[Serializable]
	public class SrgsRule : IRule, IElement
	{
		private SrgsRule()
		{
			this._elements = new SrgsElementList();
		}
		public SrgsRule(string id)
			: this()
		{
			XmlParser.ValidateRuleId(id);
			this.Id = id;
		}
		public SrgsRule(string id, params SrgsElement[] elements)
			: this()
		{
			Helpers.ThrowIfNull(elements, "elements");
			XmlParser.ValidateRuleId(id);
			this.Id = id;
			for (int i = 0; i < elements.Length; i++)
			{
				if (elements[i] == null)
				{
					throw new ArgumentNullException("elements", SR.Get(SRID.ParamsEntryNullIllegal, new object[0]));
				}
				this._elements.Add(elements[i]);
			}
		}
		public void Add(SrgsElement element)
		{
			Helpers.ThrowIfNull(element, "element");
			this.Elements.Add(element);
		}
		public Collection<SrgsElement> Elements
		{
			get
			{
				return this._elements;
			}
		}
		public string Id
		{
			get
			{
				return this._id;
			}
			set
			{
				XmlParser.ValidateRuleId(value);
				this._id = value;
			}
		}
		public SrgsRuleScope Scope
		{
			get
			{
				return this._scope;
			}
			set
			{
				this._scope = value;
				this._isScopeSet = true;
			}
		}
		public string BaseClass
		{
			get
			{
				return this._baseclass;
			}
			set
			{
				this._baseclass = value;
			}
		}
		public string Script
		{
			get
			{
				return this._script;
			}
			set
			{
				Helpers.ThrowIfEmptyOrNull(value, "value");
				this._script = value;
			}
		}
		public string OnInit
		{
			get
			{
				return this._onInit;
			}
			set
			{
				this.ValidateIdentifier(value);
				this._onInit = value;
			}
		}
		public string OnParse
		{
			get
			{
				return this._onParse;
			}
			set
			{
				this.ValidateIdentifier(value);
				this._onParse = value;
			}
		}
		public string OnError
		{
			get
			{
				return this._onError;
			}
			set
			{
				this.ValidateIdentifier(value);
				this._onError = value;
			}
		}
		public string OnRecognition
		{
			get
			{
				return this._onRecognition;
			}
			set
			{
				this.ValidateIdentifier(value);
				this._onRecognition = value;
			}
		}
		internal void WriteSrgs(XmlWriter writer)
		{
			if (this.Elements.Count == 0)
			{
				XmlParser.ThrowSrgsException(SRID.InvalidEmptyRule, new object[] { "rule", this._id });
			}
			writer.WriteStartElement("rule");
			writer.WriteAttributeString("id", this._id);
			if (this._isScopeSet)
			{
				switch (this._scope)
				{
				case SrgsRuleScope.Public:
					writer.WriteAttributeString("scope", "public");
					break;
				case SrgsRuleScope.Private:
					writer.WriteAttributeString("scope", "private");
					break;
				}
			}
			if (this._baseclass != null)
			{
				writer.WriteAttributeString("sapi", "baseclass", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this._baseclass);
			}
			if (this._dynamic != RuleDynamic.NotSet)
			{
				writer.WriteAttributeString("sapi", "dynamic", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", (this._dynamic == RuleDynamic.True) ? "true" : "false");
			}
			if (this.OnInit != null)
			{
				writer.WriteAttributeString("sapi", "onInit", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this.OnInit);
			}
			if (this.OnParse != null)
			{
				writer.WriteAttributeString("sapi", "onParse", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this.OnParse);
			}
			if (this.OnError != null)
			{
				writer.WriteAttributeString("sapi", "onError", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this.OnError);
			}
			if (this.OnRecognition != null)
			{
				writer.WriteAttributeString("sapi", "onRecognition", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this.OnRecognition);
			}
			Type type = null;
			foreach (SrgsElement srgsElement in this._elements)
			{
				Type type2 = srgsElement.GetType();
				if (type2 == typeof(SrgsText) && type2 == type)
				{
					writer.WriteString(" ");
				}
				type = type2;
				srgsElement.WriteSrgs(writer);
			}
			writer.WriteEndElement();
			if (this.HasCode)
			{
				this.WriteScriptElement(writer, this._script);
			}
		}
		internal void Validate(SrgsGrammar grammar)
		{
			bool flag = this.HasCode || this._onInit != null || this._onParse != null || this._onError != null || this._onRecognition != null || this._baseclass != null;
			grammar._fContainsCode = grammar._fContainsCode || flag;
			grammar.HasSapiExtension = grammar.HasSapiExtension || flag;
			if (this._dynamic != RuleDynamic.NotSet)
			{
				grammar.HasSapiExtension = true;
			}
			if (this.OnInit != null && this.Scope != SrgsRuleScope.Public)
			{
				XmlParser.ThrowSrgsException(SRID.OnInitOnPublicRule, new object[] { "OnInit", this.Id });
			}
			if (this.OnRecognition != null && this.Scope != SrgsRuleScope.Public)
			{
				XmlParser.ThrowSrgsException(SRID.OnInitOnPublicRule, new object[] { "OnRecognition", this.Id });
			}
			foreach (SrgsElement srgsElement in this._elements)
			{
				srgsElement.Validate(grammar);
			}
		}
		void IElement.PostParse(IElement grammar)
		{
			((SrgsGrammar)grammar).Rules.Add(new SrgsRule[] { this });
		}
		void IRule.CreateScript(IGrammar grammar, string rule, string method, RuleMethodScript type)
		{
			switch (type)
			{
			case RuleMethodScript.onInit:
				this._onInit = method;
				return;
			case RuleMethodScript.onParse:
				this._onParse = method;
				return;
			case RuleMethodScript.onRecognition:
				this._onRecognition = method;
				return;
			case RuleMethodScript.onError:
				this._onError = method;
				return;
			default:
				return;
			}
		}
		internal RuleDynamic Dynamic
		{
			get
			{
				return this._dynamic;
			}
			set
			{
				this._dynamic = value;
			}
		}
		internal bool HasCode
		{
			get
			{
				return this._script.Length > 0;
			}
		}
		private void WriteScriptElement(XmlWriter writer, string sCode)
		{
			writer.WriteStartElement("sapi", "script", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions");
			writer.WriteAttributeString("sapi", "rule", "http://schemas.microsoft.com/Speech/2002/06/SRGSExtensions", this._id);
			writer.WriteCData(sCode);
			writer.WriteEndElement();
		}
		private void ValidateIdentifier(string s)
		{
			if (s == this._id)
			{
				XmlParser.ThrowSrgsException(SRID.ConstructorNotAllowed, new object[] { this._id });
			}
			if (s != null && (s.IndexOfAny(SrgsRule.invalidChars) >= 0 || s.Length == 0))
			{
				XmlParser.ThrowSrgsException(SRID.InvalidMethodName, new object[0]);
			}
		}
		private SrgsElementList _elements;
		private string _id;
		private SrgsRuleScope _scope = SrgsRuleScope.Private;
		private RuleDynamic _dynamic = RuleDynamic.NotSet;
		private bool _isScopeSet;
		private string _baseclass;
		private string _script = string.Empty;
		private string _onInit;
		private string _onParse;
		private string _onError;
		private string _onRecognition;
		private static readonly char[] invalidChars = new char[]
		{
			'?', '*', '+', '|', '(', ')', '^', '$', '/', ';',
			'.', '=', '<', '>', '[', ']', '{', '}', '\\', ' ',
			'\t', '\r', '\n'
		};
		internal class SrgsRuleDebugDisplay
		{
			public SrgsRuleDebugDisplay(SrgsRule rule)
			{
				this._rule = rule;
			}
			public object Id
			{
				get
				{
					return this._rule.Id;
				}
			}
			public object Scope
			{
				get
				{
					return this._rule.Scope;
				}
			}
			public object BaseClass
			{
				get
				{
					return this._rule.BaseClass;
				}
			}
			public object Script
			{
				get
				{
					return this._rule.Script;
				}
			}
			public object OnInit
			{
				get
				{
					return this._rule.OnInit;
				}
			}
			public object OnParse
			{
				get
				{
					return this._rule.OnParse;
				}
			}
			public object OnError
			{
				get
				{
					return this._rule.OnError;
				}
			}
			public object OnRecognition
			{
				get
				{
					return this._rule.OnRecognition;
				}
			}
			public object Count
			{
				get
				{
					return this._rule._elements.Count;
				}
			}
			[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
			public SrgsElement[] AKeys
			{
				get
				{
					SrgsElement[] array = new SrgsElement[this._rule._elements.Count];
					for (int i = 0; i < this._rule._elements.Count; i++)
					{
						array[i] = this._rule._elements[i];
					}
					return array;
				}
			}
			private SrgsRule _rule;
		}
	}
}

SrgsSemanticInterpretationTag.cs

using System;
using System.Diagnostics;
using System.Speech.Internal;
using System.Speech.Internal.SrgsParser;
using System.Text;
using System.Xml;

namespace System.Speech.Recognition.SrgsGrammar
{
	[DebuggerDisplay("{DebuggerDisplayString ()}")]
	[Serializable]
	public class SrgsSemanticInterpretationTag : SrgsElement, ISemanticTag, IElement
	{
		public SrgsSemanticInterpretationTag()
		{
		}
		public SrgsSemanticInterpretationTag(string script)
		{
			Helpers.ThrowIfNull(script, "script");
			this._script = script;
		}
		public string Script
		{
			get
			{
				return this._script;
			}
			set
			{
				Helpers.ThrowIfNull(value, "value");
				this._script = value;
			}
		}
		internal override void Validate(SrgsGrammar grammar)
		{
			if (grammar.TagFormat == SrgsTagFormat.Default)
			{
				grammar.TagFormat |= SrgsTagFormat.W3cV1;
				return;
			}
			if (grammar.TagFormat == SrgsTagFormat.KeyValuePairs)
			{
				XmlParser.ThrowSrgsException(SRID.SapiPropertiesAndSemantics, new object[0]);
			}
		}
		internal override void WriteSrgs(XmlWriter writer)
		{
			string text = this.Script.Trim(Helpers._achTrimChars);
			writer.WriteStartElement("tag");
			if (!string.IsNullOrEmpty(text))
			{
				writer.WriteString(text);
			}
			writer.WriteEndElement();
		}
		internal override string DebuggerDisplayString()
		{
			StringBuilder stringBuilder = new StringBuilder("SrgsSemanticInterpretationTag '");
			stringBuilder.Append(this._script);
			stringBuilder.Append("'");
			return stringBuilder.ToString();
		}
		void ISemanticTag.Content(IElement parent, string value, int line)
		{
			this.Script = value;
		}
		private string _script = string.Empty;
	}
}

AudioLevelUpdatedEventArgs.cs

using System;

namespace System.Speech.Recognition
{
	public class AudioLevelUpdatedEventArgs : EventArgs
	{
		internal AudioLevelUpdatedEventArgs(int audioLevel)
		{
			this._audioLevel = audioLevel;
		}
		public int AudioLevel
		{
			get
			{
				return this._audioLevel;
			}
		}
		private int _audioLevel;
	}
}

Grammar.cs

using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Speech.Internal;
using System.Speech.Internal.SrgsCompiler;
using System.Speech.Recognition.SrgsGrammar;
using System.Text;

namespace System.Speech.Recognition
{
	[DebuggerDisplay("Grammar: {(_uri != null ? \"uri=\" + _uri.ToString () + \" \" : \"\") + \"rule=\" + _ruleName }")]
	public class Grammar
	{
		internal Grammar(Uri uri, string ruleName, object[] parameters)
		{
			Helpers.ThrowIfNull(uri, "uri");
			this._uri = uri;
			this.InitialGrammarLoad(ruleName, parameters, false);
		}
		public Grammar(string path)
			: this(path, null, null)
		{
		}
		public Grammar(string path, string ruleName)
			: this(path, ruleName, null)
		{
		}
		public Grammar(string path, string ruleName, object[] parameters)
		{
			try
			{
				this._uri = new Uri(path, UriKind.Relative);
			}
			catch (UriFormatException ex)
			{
				throw new ArgumentException(SR.Get(SRID.RecognizerGrammarNotFound, new object[0]), "path", ex);
			}
			this.InitialGrammarLoad(ruleName, parameters, false);
		}
		public Grammar(SrgsDocument srgsDocument)
			: this(srgsDocument, null, null, null)
		{
		}
		public Grammar(SrgsDocument srgsDocument, string ruleName)
			: this(srgsDocument, ruleName, null, null)
		{
		}
		public Grammar(SrgsDocument srgsDocument, string ruleName, object[] parameters)
			: this(srgsDocument, ruleName, null, parameters)
		{
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Grammar(SrgsDocument srgsDocument, string ruleName, Uri baseUri)
			: this(srgsDocument, ruleName, baseUri, null)
		{
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Grammar(SrgsDocument srgsDocument, string ruleName, Uri baseUri, object[] parameters)
		{
			Helpers.ThrowIfNull(srgsDocument, "srgsDocument");
			this._srgsDocument = srgsDocument;
			this._isSrgsDocument = srgsDocument != null;
			this._baseUri = baseUri;
			this.InitialGrammarLoad(ruleName, parameters, false);
		}
		public Grammar(Stream stream)
			: this(stream, null, null, null)
		{
		}
		public Grammar(Stream stream, string ruleName)
			: this(stream, ruleName, null, null)
		{
		}
		public Grammar(Stream stream, string ruleName, object[] parameters)
			: this(stream, ruleName, null, parameters)
		{
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Grammar(Stream stream, string ruleName, Uri baseUri)
			: this(stream, ruleName, baseUri, null)
		{
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Grammar(Stream stream, string ruleName, Uri baseUri, object[] parameters)
		{
			Helpers.ThrowIfNull(stream, "stream");
			if (!stream.CanRead)
			{
				throw new ArgumentException(SR.Get(SRID.StreamMustBeReadable, new object[0]), "stream");
			}
			this._appStream = stream;
			this._baseUri = baseUri;
			this.InitialGrammarLoad(ruleName, parameters, false);
		}
		public Grammar(GrammarBuilder builder)
		{
			Helpers.ThrowIfNull(builder, "builder");
			this._grammarBuilder = builder;
			this.InitialGrammarLoad(null, null, false);
		}
		private Grammar(string onInitParameters, Stream stream, string ruleName)
		{
			this._appStream = stream;
			this._onInitParameters = onInitParameters;
			this.InitialGrammarLoad(ruleName, null, true);
		}
		protected Grammar()
		{
		}
		protected void StgInit(object[] parameters)
		{
			this._parameters = parameters;
			this.LoadAndCompileCfgData(false, true);
		}
		public static Grammar LoadLocalizedGrammarFromType(Type type, params object[] onInitParameters)
		{
			Helpers.ThrowIfNull(type, "type");
			if (type == typeof(Grammar) || !type.IsSubclassOf(typeof(Grammar)))
			{
				throw new ArgumentException(SR.Get(SRID.StrongTypedGrammarNotAGrammar, new object[0]), "type");
			}
			Assembly assembly = Assembly.GetAssembly(type);
			foreach (Type type2 in assembly.GetTypes())
			{
				string text = null;
				if ((type2 == type || type2.IsSubclassOf(type)) && type2.GetField("__cultureId") != null)
				{
					try
					{
						text = (string)type2.InvokeMember("__cultureId", BindingFlags.GetField, null, null, null, null);
					}
					catch (Exception ex)
					{
						if (!(ex is MissingFieldException))
						{
							throw;
						}
					}
					if (Helpers.CompareInvariantCulture(new CultureInfo(int.Parse(text, CultureInfo.InvariantCulture)), CultureInfo.CurrentUICulture))
					{
						try
						{
							return (Grammar)assembly.CreateInstance(type2.FullName, false, BindingFlags.CreateInstance, null, onInitParameters, null, null);
						}
						catch (MissingMemberException)
						{
							throw new ArgumentException(SR.Get(SRID.RuleScriptInvalidParameters, new object[] { type2.Name, type2.Name }));
						}
					}
				}
			}
			return null;
		}
		public bool Enabled
		{
			get
			{
				return this._enabled;
			}
			set
			{
				if (this._grammarState != GrammarState.Unloaded && this._enabled != value)
				{
					this._recognizer.SetGrammarState(this, value);
				}
				this._enabled = value;
			}
		}
		public float Weight
		{
			get
			{
				return this._weight;
			}
			set
			{
				if ((double)value < 0.0 || (double)value > 1.0)
				{
					throw new ArgumentOutOfRangeException("value", SR.Get(SRID.GrammarInvalidWeight, new object[0]));
				}
				if (this._grammarState != GrammarState.Unloaded && !this._weight.Equals(value))
				{
					this._recognizer.SetGrammarWeight(this, value);
				}
				this._weight = value;
			}
		}
		public int Priority
		{
			get
			{
				return this._priority;
			}
			set
			{
				if (value < -128 || value > 127)
				{
					throw new ArgumentOutOfRangeException("value", SR.Get(SRID.GrammarInvalidPriority, new object[0]));
				}
				if (this._grammarState != GrammarState.Unloaded && this._priority != value)
				{
					this._recognizer.SetGrammarPriority(this, value);
				}
				this._priority = value;
			}
		}
		public string Name
		{
			get
			{
				return this._grammarName;
			}
			set
			{
				if (value == null)
				{
					value = string.Empty;
				}
				this._grammarName = value;
			}
		}
		public string RuleName
		{
			get
			{
				return this._ruleName;
			}
		}
		public bool Loaded
		{
			get
			{
				return this._grammarState == GrammarState.Loaded;
			}
		}
		internal Uri Uri
		{
			get
			{
				return this._uri;
			}
		}
		public event EventHandler<SpeechRecognizedEventArgs> SpeechRecognized;
		internal IRecognizerInternal Recognizer
		{
			get
			{
				return this._recognizer;
			}
			set
			{
				this._recognizer = value;
			}
		}
		internal GrammarState State
		{
			get
			{
				return this._grammarState;
			}
			set
			{
				if (value == GrammarState.Unloaded)
				{
					this._loadException = null;
					this._recognizer = null;
					if (this._appDomain != null)
					{
						AppDomain.Unload(this._appDomain);
						this._appDomain = null;
					}
				}
				else if (value != GrammarState.Loaded)
				{
				}
				this._grammarState = value;
			}
		}
		internal Exception LoadException
		{
			get
			{
				return this._loadException;
			}
			set
			{
				this._loadException = value;
			}
		}
		internal byte[] CfgData
		{
			get
			{
				return this._cfgData;
			}
		}
		internal Uri BaseUri
		{
			get
			{
				return this._baseUri;
			}
		}
		internal bool Sapi53Only
		{
			get
			{
				return this._sapi53Only;
			}
		}
		internal uint SapiGrammarId
		{
			get
			{
				return this._sapiGrammarId;
			}
			set
			{
				this._sapiGrammarId = value;
			}
		}
		protected internal virtual bool IsStg
		{
			get
			{
				return this._isStg;
			}
		}
		internal bool IsSrgsDocument
		{
			get
			{
				return this._isSrgsDocument;
			}
		}
		internal InternalGrammarData InternalData
		{
			get
			{
				return this._internalData;
			}
			set
			{
				this._internalData = value;
			}
		}
		internal static Grammar Create(string grammarName, string ruleName, string onInitParameter, out Uri redirectUri)
		{
			redirectUri = null;
			grammarName = grammarName.Trim();
			Uri uri;
			bool flag = Uri.TryCreate(grammarName, UriKind.Absolute, out uri);
			int num = grammarName.IndexOf(".dll", StringComparison.OrdinalIgnoreCase);
			if (!flag || (num > 0 && num == grammarName.Length - 4))
			{
				Assembly assembly;
				if (flag)
				{
					if (!uri.IsFile)
					{
						throw new InvalidOperationException();
					}
					assembly = Assembly.LoadFrom(uri.LocalPath);
				}
				else
				{
					assembly = Assembly.Load(grammarName);
				}
				return Grammar.LoadGrammarFromAssembly(assembly, ruleName, onInitParameter);
			}
			Grammar grammar;
			try
			{
				string text;
				using (Stream stream = Grammar._resourceLoader.LoadFile(uri, out text, out redirectUri))
				{
					try
					{
						grammar = new Grammar(onInitParameter, stream, ruleName);
					}
					finally
					{
						Grammar._resourceLoader.UnloadFile(text);
					}
				}
			}
			catch
			{
				Assembly assembly2 = Assembly.LoadFrom(grammarName);
				grammar = Grammar.LoadGrammarFromAssembly(assembly2, ruleName, onInitParameter);
			}
			return grammar;
		}
		internal void OnRecognitionInternal(SpeechRecognizedEventArgs eventArgs)
		{
			EventHandler<SpeechRecognizedEventArgs> speechRecognized = this.SpeechRecognized;
			if (speechRecognized != null)
			{
				speechRecognized(this, eventArgs);
			}
		}
		internal static bool IsDictationGrammar(Uri uri)
		{
			return !(uri == null) && uri.IsAbsoluteUri && !(uri.Scheme != "grammar") && string.IsNullOrEmpty(uri.Host) && string.IsNullOrEmpty(uri.Authority) && string.IsNullOrEmpty(uri.Query) && !(uri.PathAndQuery != "dictation");
		}
		internal bool IsDictation(Uri uri)
		{
			bool flag = Grammar.IsDictationGrammar(uri);
			if (!flag && this is DictationGrammar)
			{
				throw new ArgumentException(SR.Get(SRID.DictationInvalidTopic, new object[0]), "uri");
			}
			return flag;
		}
		internal Grammar Find(long grammarId)
		{
			if (this._ruleRefs != null)
			{
				foreach (Grammar grammar in this._ruleRefs)
				{
					if (grammarId == (long)((ulong)grammar._sapiGrammarId))
					{
						return grammar;
					}
					Grammar grammar2;
					if ((grammar2 = grammar.Find(grammarId)) != null)
					{
						return grammar2;
					}
				}
			}
			return null;
		}
		internal Grammar Find(string ruleName)
		{
			if (this._ruleRefs != null)
			{
				foreach (Grammar grammar in this._ruleRefs)
				{
					if (ruleName == grammar.RuleName)
					{
						return grammar;
					}
					Grammar grammar2;
					if ((grammar2 = grammar.Find(ruleName)) != null)
					{
						return grammar2;
					}
				}
			}
			return null;
		}
		internal void AddRuleRef(Grammar ruleRef, uint grammarId)
		{
			if (this._ruleRefs == null)
			{
				this._ruleRefs = new Collection<Grammar>();
			}
			this._ruleRefs.Add(ruleRef);
			this._sapiGrammarId = grammarId;
		}
		internal MethodInfo MethodInfo(string method)
		{
			return base.GetType().GetMethod(method, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		}
		protected string ResourceName
		{
			get
			{
				return this._resources;
			}
			set
			{
				Helpers.ThrowIfEmptyOrNull(value, "value");
				this._resources = value;
			}
		}
		private void LoadAndCompileCfgData(bool isImportedGrammar, bool stgInit)
		{
			Stream stream = (this.IsStg ? this.LoadCfgFromResource(stgInit) : this.LoadCfg(isImportedGrammar, stgInit));
			SrgsRule[] array = this.RunOnInit(this.IsStg);
			if (array != null)
			{
				MemoryStream memoryStream = Grammar.CombineCfg(this._ruleName, stream, array);
				stream.Close();
				stream = memoryStream;
			}
			this._cfgData = Helpers.ReadStreamToByteArray(stream, (int)stream.Length);
			stream.Close();
			this._srgsDocument = null;
			this._appStream = null;
		}
		private MemoryStream LoadCfg(bool isImportedGrammar, bool stgInit)
		{
			Uri uri = this.Uri;
			MemoryStream memoryStream = new MemoryStream();
			if (uri != null)
			{
				string text;
				string text2;
				using (Stream stream = Grammar._resourceLoader.LoadFile(uri, out text, out this._baseUri, out text2))
				{
					stream.Position = 0L;
					SrgsGrammarCompiler.CompileXmlOrCopyCfg(stream, memoryStream, uri);
				}
				Grammar._resourceLoader.UnloadFile(text2);
			}
			else if (this._srgsDocument != null)
			{
				SrgsGrammarCompiler.Compile(this._srgsDocument, memoryStream);
				if (this._baseUri == null && this._srgsDocument.BaseUri != null)
				{
					this._baseUri = this._srgsDocument.BaseUri;
				}
			}
			else if (this._grammarBuilder != null)
			{
				this._grammarBuilder.Compile(memoryStream);
			}
			else
			{
				SrgsGrammarCompiler.CompileXmlOrCopyCfg(this._appStream, memoryStream, null);
			}
			memoryStream.Position = 0L;
			this._ruleName = Grammar.CheckRuleName(memoryStream, this._ruleName, isImportedGrammar, stgInit, out this._sapi53Only, out this._semanticTag);
			this.CreateSandbox(memoryStream);
			memoryStream.Position = 0L;
			return memoryStream;
		}
		private static Grammar LoadGrammarFromAssembly(Assembly assembly, string ruleName, string onInitParameters)
		{
			Type typeFromHandle = typeof(Grammar);
			Type type = null;
			foreach (Type type2 in assembly.GetTypes())
			{
				if (type2.IsSubclassOf(typeFromHandle))
				{
					string text = null;
					if (type2.Name == ruleName)
					{
						type = type2;
					}
					if ((type2 == type || (type != null && type2.IsSubclassOf(type))) && type2.GetField("__cultureId") != null)
					{
						try
						{
							text = (string)type2.InvokeMember("__cultureId", BindingFlags.GetField, null, null, null, null);
						}
						catch (Exception ex)
						{
							if (!(ex is MissingFieldException))
							{
								throw;
							}
						}
						if (Helpers.CompareInvariantCulture(new CultureInfo(int.Parse(text, CultureInfo.InvariantCulture)), CultureInfo.CurrentUICulture))
						{
							try
							{
								object[] array = Grammar.MatchInitParameters(type2, onInitParameters, assembly.GetName().Name, ruleName);
								return (Grammar)assembly.CreateInstance(type2.FullName, false, BindingFlags.CreateInstance, null, array, null, null);
							}
							catch (MissingMemberException)
							{
								throw new ArgumentException(SR.Get(SRID.RuleScriptInvalidParameters, new object[] { type2.Name, type2.Name }));
							}
						}
					}
				}
			}
			return null;
		}
		private static object[] MatchInitParameters(Type type, string onInitParameters, string grammar, string rule)
		{
			ConstructorInfo[] constructors = type.GetConstructors();
			Grammar.NameValuePair[] array = Grammar.ParseInitParams(onInitParameters);
			object[] array2 = new object[array.Length];
			bool flag = false;
			int num = 0;
			while (num < constructors.Length && !flag)
			{
				ParameterInfo[] parameters = constructors[num].GetParameters();
				if (parameters.Length <= array.Length)
				{
					flag = true;
					int num2 = 0;
					while (num2 < array.Length && flag)
					{
						Grammar.NameValuePair nameValuePair = array[num2];
						if (nameValuePair._name == null)
						{
							array2[num2] = nameValuePair._value;
						}
						else
						{
							bool flag2 = false;
							for (int i = 0; i < parameters.Length; i++)
							{
								if (parameters[i].Name == nameValuePair._name)
								{
									array2[i] = Grammar.ParseValue(parameters[i].ParameterType, nameValuePair._value);
									flag2 = true;
									break;
								}
							}
							if (!flag2)
							{
								flag = false;
							}
						}
						num2++;
					}
				}
				num++;
			}
			if (!flag)
			{
				throw new FormatException(SR.Get(SRID.CantFindAConstructor, new object[]
				{
					grammar,
					rule,
					Grammar.FormatConstructorParameters(constructors)
				}));
			}
			return array2;
		}
		private static object ParseValue(Type type, string value)
		{
			if (type == typeof(string))
			{
				return value;
			}
			return type.InvokeMember("Parse", BindingFlags.InvokeMethod, null, null, new object[] { value }, CultureInfo.InvariantCulture);
		}
		private static string FormatConstructorParameters(ConstructorInfo[] cis)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < cis.Length; i++)
			{
				stringBuilder.Append((i > 0) ? " or sapi:parms=\"" : "sapi:parms=\"");
				ParameterInfo[] parameters = cis[i].GetParameters();
				for (int j = 0; j < parameters.Length; j++)
				{
					if (j > 0)
					{
						stringBuilder.Append(';');
					}
					ParameterInfo parameterInfo = parameters[j];
					stringBuilder.Append(parameterInfo.Name);
					stringBuilder.Append(':');
					stringBuilder.Append(parameterInfo.ParameterType.Name);
				}
				stringBuilder.Append("\"");
			}
			return stringBuilder.ToString();
		}
		private static Grammar.NameValuePair[] ParseInitParams(string initParameters)
		{
			if (string.IsNullOrEmpty(initParameters))
			{
				return new Grammar.NameValuePair[0];
			}
			string[] array = initParameters.Split(new char[] { ';' }, StringSplitOptions.None);
			Grammar.NameValuePair[] array2 = new Grammar.NameValuePair[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i];
				int num = text.IndexOf(':');
				if (num >= 0)
				{
					array2[i]._name = text.Substring(0, num);
					array2[i]._value = text.Substring(num + 1);
				}
				else
				{
					array2[i]._value = text;
				}
			}
			return array2;
		}
		private void InitialGrammarLoad(string ruleName, object[] parameters, bool isImportedGrammar)
		{
			this._ruleName = ruleName;
			this._parameters = parameters;
			if (!this.IsDictation(this._uri))
			{
				this.LoadAndCompileCfgData(isImportedGrammar, false);
			}
		}
		private void CreateSandbox(MemoryStream stream)
		{
			stream.Position = 0L;
			byte[] array;
			byte[] array2;
			ScriptRef[] array3;
			if (CfgGrammar.LoadIL(stream, out array, out array2, out array3))
			{
				Assembly executingAssembly = Assembly.GetExecutingAssembly();
				this._appDomain = AppDomain.CreateDomain("sandbox");
				this._proxy = (AppDomainGrammarProxy)this._appDomain.CreateInstanceFromAndUnwrap(executingAssembly.GetName().CodeBase, "System.Speech.Internal.SrgsCompiler.AppDomainGrammarProxy");
				this._proxy.Init(this._ruleName, array, array2);
				this._scripts = array3;
			}
		}
		private Stream LoadCfgFromResource(bool stgInit)
		{
			Assembly assembly = Assembly.GetAssembly(base.GetType());
			Stream manifestResourceStream = assembly.GetManifestResourceStream(this.ResourceName);
			if (manifestResourceStream == null)
			{
				throw new FormatException(SR.Get(SRID.RecognizerInvalidBinaryGrammar, new object[0]));
			}
			try
			{
				ScriptRef[] array = CfgGrammar.LoadIL(manifestResourceStream);
				if (array == null)
				{
					throw new ArgumentException(SR.Get(SRID.CannotLoadDotNetSemanticCode, new object[0]));
				}
				this._scripts = array;
			}
			catch (Exception ex)
			{
				throw new ArgumentException(SR.Get(SRID.CannotLoadDotNetSemanticCode, new object[0]), ex);
			}
			manifestResourceStream.Position = 0L;
			this._ruleName = Grammar.CheckRuleName(manifestResourceStream, base.GetType().Name, false, stgInit, out this._sapi53Only, out this._semanticTag);
			this._isStg = true;
			return manifestResourceStream;
		}
		private static MemoryStream CombineCfg(string rule, Stream stream, SrgsRule[] extraRules)
		{
			MemoryStream memoryStream3;
			using (MemoryStream memoryStream = new MemoryStream())
			{
				SrgsDocument srgsDocument = new SrgsDocument();
				srgsDocument.TagFormat = SrgsTagFormat.KeyValuePairs;
				foreach (SrgsRule srgsRule in extraRules)
				{
					srgsDocument.Rules.Add(new SrgsRule[] { srgsRule });
				}
				SrgsGrammarCompiler.Compile(srgsDocument, memoryStream);
				using (StreamMarshaler streamMarshaler = new StreamMarshaler(stream))
				{
					long position = stream.Position;
					Backend backend = new Backend(streamMarshaler);
					stream.Position = position;
					memoryStream.Position = 0L;
					MemoryStream memoryStream2 = new MemoryStream();
					using (StreamMarshaler streamMarshaler2 = new StreamMarshaler(memoryStream))
					{
						Backend backend2 = new Backend(streamMarshaler2);
						Backend backend3 = Backend.CombineGrammar(rule, backend, backend2);
						using (StreamMarshaler streamMarshaler3 = new StreamMarshaler(memoryStream2))
						{
							backend3.Commit(streamMarshaler3);
							memoryStream2.Position = 0L;
							memoryStream3 = memoryStream2;
						}
					}
				}
			}
			return memoryStream3;
		}
		private SrgsRule[] RunOnInit(bool stg)
		{
			SrgsRule[] array = null;
			bool flag = false;
			string text = ScriptRef.OnInitMethod(this._scripts, this._ruleName);
			if (text != null)
			{
				if (this._proxy != null)
				{
					Exception ex;
					array = this._proxy.OnInit(text, this._parameters, this._onInitParameters, out ex);
					flag = true;
					if (ex != null)
					{
						throw ex;
					}
				}
				else
				{
					Type[] array2 = new Type[this._parameters.Length];
					for (int i = 0; i < this._parameters.Length; i++)
					{
						array2[i] = this._parameters[i].GetType();
					}
					MethodInfo method = base.GetType().GetMethod(text, array2);
					if (method == null)
					{
						throw new ArgumentException(SR.Get(SRID.RuleScriptInvalidParameters, new object[] { this._ruleName, this._ruleName }));
					}
					array = (SrgsRule[])method.Invoke(this, this._parameters);
					flag = true;
				}
			}
			if (!stg && !flag && this._parameters != null)
			{
				throw new ArgumentException(SR.Get(SRID.RuleScriptInvalidParameters, new object[] { this._ruleName, this._ruleName }));
			}
			return array;
		}
		private static string CheckRuleName(Stream stream, string rulename, bool isImportedGrammar, bool stgInit, out bool sapi53Only, out GrammarOptions grammarOptions)
		{
			sapi53Only = false;
			long position = stream.Position;
			using (StreamMarshaler streamMarshaler = new StreamMarshaler(stream))
			{
				CfgGrammar.CfgSerializedHeader cfgSerializedHeader = null;
				CfgGrammar.CfgHeader cfgHeader = CfgGrammar.ConvertCfgHeader(streamMarshaler, false, true, out cfgSerializedHeader);
				StringBlob pszSymbols = cfgHeader.pszSymbols;
				string text = ((cfgHeader.ulRootRuleIndex != uint.MaxValue && (ulong)cfgHeader.ulRootRuleIndex < (ulong)((long)cfgHeader.rules.Length)) ? pszSymbols.FromOffset(cfgHeader.rules[(int)((UIntPtr)cfgHeader.ulRootRuleIndex)]._nameOffset) : null);
				sapi53Only = (cfgHeader.GrammarOptions & (GrammarOptions.MssV1 | GrammarOptions.IpaPhoneme | GrammarOptions.W3cV1 | GrammarOptions.STG)) != GrammarOptions.KeyValuePairs;
				if (text == null && string.IsNullOrEmpty(rulename))
				{
					throw new ArgumentException(SR.Get(SRID.SapiErrorNoRulesToActivate, new object[0]));
				}
				if (!string.IsNullOrEmpty(rulename))
				{
					bool flag = false;
					foreach (CfgRule cfgRule in cfgHeader.rules)
					{
						if (pszSymbols.FromOffset(cfgRule._nameOffset) == rulename)
						{
							flag = cfgRule.Export || stgInit || (!isImportedGrammar && (cfgRule.TopLevel || rulename == text));
							break;
						}
					}
					if (!flag)
					{
						throw new ArgumentException(SR.Get(SRID.RecognizerRuleNotFoundStream, new object[] { rulename }));
					}
				}
				else
				{
					rulename = text;
				}
				grammarOptions = cfgHeader.GrammarOptions & GrammarOptions.TagFormat;
			}
			stream.Position = position;
			return rulename;
		}
		internal GrammarOptions _semanticTag;
		internal AppDomain _appDomain;
		internal AppDomainGrammarProxy _proxy;
		internal ScriptRef[] _scripts;
		private byte[] _cfgData;
		private Stream _appStream;
		private bool _isSrgsDocument;
		private SrgsDocument _srgsDocument;
		private GrammarBuilder _grammarBuilder;
		private IRecognizerInternal _recognizer;
		private GrammarState _grammarState;
		private Exception _loadException;
		private Uri _uri;
		private Uri _baseUri;
		private string _ruleName;
		private string _resources;
		private object[] _parameters;
		private string _onInitParameters;
		private bool _enabled = true;
		private bool _isStg;
		private bool _sapi53Only;
		private uint _sapiGrammarId;
		private float _weight = 1f;
		private int _priority;
		private InternalGrammarData _internalData;
		private string _grammarName = string.Empty;
		private Collection<Grammar> _ruleRefs;
		private static ResourceLoader _resourceLoader = new ResourceLoader();
		private struct NameValuePair
		{
			internal string _name;
			internal string _value;
		}
	}
}

RecognitionResult.cs

using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Speech.AudioFormat;
using System.Speech.Internal;
using System.Speech.Internal.SapiInterop;
using System.Text;

namespace System.Speech.Recognition
{
	[DebuggerDisplay("{DebuggerDisplayString ()}")]
	[Serializable]
	public sealed class RecognitionResult : RecognizedPhrase, ISerializable
	{
		internal RecognitionResult(IRecognizerInternal recognizer, ISpRecoResult recoResult, byte[] sapiResultBlob, int maxAlternates)
		{
			this.Initialize(recognizer, recoResult, sapiResultBlob, maxAlternates);
		}
		internal RecognitionResult()
		{
		}
		private RecognitionResult(SerializationInfo info, StreamingContext context)
		{
			Type type = base.GetType();
			MemberInfo[] serializableMembers = FormatterServices.GetSerializableMembers(type, context);
			bool flag = context.State == StreamingContextStates.CrossAppDomain;
			foreach (MemberInfo memberInfo in serializableMembers)
			{
				FieldInfo fieldInfo = (FieldInfo)memberInfo;
				if (!flag || (memberInfo.Name != "_recognizer" && memberInfo.Name != "_grammar" && memberInfo.Name != "_ruleList" && memberInfo.Name != "_audio" && memberInfo.Name != "_audio"))
				{
					fieldInfo.SetValue(this, info.GetValue(fieldInfo.Name, fieldInfo.FieldType));
				}
			}
		}
		public RecognizedAudio GetAudioForWordRange(RecognizedWordUnit firstWord, RecognizedWordUnit lastWord)
		{
			Helpers.ThrowIfNull(firstWord, "firstWord");
			Helpers.ThrowIfNull(lastWord, "lastWord");
			return this.Audio.GetRange(firstWord._audioPosition, lastWord._audioPosition + lastWord._audioDuration - firstWord._audioPosition);
		}
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			Helpers.ThrowIfNull(info, "info");
			bool flag = context.State == StreamingContextStates.CrossAppDomain;
			if (!flag)
			{
				foreach (RecognizedPhrase recognizedPhrase in this.Alternates)
				{
					try
					{
						string smlContent = recognizedPhrase.SmlContent;
						RecognizedAudio audio = this.Audio;
						if (recognizedPhrase.Text == null || recognizedPhrase.Homophones == null || recognizedPhrase.Semantics == null || (smlContent == null && smlContent != null) || (audio == null && audio != null))
						{
							throw new SerializationException();
						}
					}
					catch (NotSupportedException)
					{
					}
				}
			}
			Type type = base.GetType();
			MemberInfo[] serializableMembers = FormatterServices.GetSerializableMembers(type, context);
			foreach (MemberInfo memberInfo in serializableMembers)
			{
				if (!flag || (memberInfo.Name != "_recognizer" && memberInfo.Name != "_grammar" && memberInfo.Name != "_ruleList" && memberInfo.Name != "_audio" && memberInfo.Name != "_audio"))
				{
					info.AddValue(memberInfo.Name, ((FieldInfo)memberInfo).GetValue(this));
				}
			}
		}
		internal bool SetTextFeedback(string text, bool isSuccessfulAction)
		{
			if (this._sapiRecoResult == null)
			{
				throw new NotSupportedException(SR.Get(SRID.NotSupportedWithThisVersionOfSAPI, new object[0]));
			}
			try
			{
				this._sapiRecoResult.SetTextFeedback(text, isSuccessfulAction);
			}
			catch (COMException ex)
			{
				if (ex.ErrorCode == -2147200893)
				{
					throw new NotSupportedException(SR.Get(SRID.SapiErrorNotSupportedForInprocRecognizer, new object[0]));
				}
				return false;
			}
			return true;
		}
		public RecognizedAudio Audio
		{
			get
			{
				if (this._audio == null && this._header.ulRetainedOffset > 0U)
				{
					int num = this._sapiAudioBlob.Length;
					GCHandle gchandle = GCHandle.Alloc(this._sapiAudioBlob, GCHandleType.Pinned);
					try
					{
						IntPtr intPtr = gchandle.AddrOfPinnedObject();
						SPWAVEFORMATEX spwaveformatex = (SPWAVEFORMATEX)Marshal.PtrToStructure(intPtr, typeof(SPWAVEFORMATEX));
						IntPtr intPtr2 = new IntPtr((long)intPtr + (long)((ulong)spwaveformatex.cbUsed));
						byte[] array = new byte[(long)num - (long)((ulong)spwaveformatex.cbUsed)];
						Marshal.Copy(intPtr2, array, 0, num - (int)spwaveformatex.cbUsed);
						byte[] array2 = new byte[(int)spwaveformatex.cbSize];
						if (spwaveformatex.cbSize > 0)
						{
							IntPtr intPtr3 = new IntPtr((long)intPtr + 38L);
							Marshal.Copy(intPtr3, array2, 0, (int)spwaveformatex.cbSize);
						}
						SpeechAudioFormatInfo speechAudioFormatInfo = new SpeechAudioFormatInfo((EncodingFormat)spwaveformatex.wFormatTag, (int)spwaveformatex.nSamplesPerSec, (int)((short)spwaveformatex.wBitsPerSample), (int)((short)spwaveformatex.nChannels), (int)spwaveformatex.nAvgBytesPerSec, (int)((short)spwaveformatex.nBlockAlign), array2);
						DateTime dateTime;
						if (this._header.times.dwTickCount == 0U)
						{
							dateTime = this._startTime - this.AudioDuration;
						}
						else
						{
							dateTime = DateTime.FromFileTime((long)(((ulong)this._header.times.ftStreamTime.dwHighDateTime << 32) + (ulong)this._header.times.ftStreamTime.dwLowDateTime));
						}
						this._audio = new RecognizedAudio(array, speechAudioFormatInfo, dateTime, this.AudioPosition, this.AudioDuration);
					}
					finally
					{
						gchandle.Free();
					}
				}
				return this._audio;
			}
		}
		public ReadOnlyCollection<RecognizedPhrase> Alternates
		{
			get
			{
				return new ReadOnlyCollection<RecognizedPhrase>(this.GetAlternates());
			}
		}
		internal string ConvertPronunciation(string pronunciation, int langId)
		{
			if (this._alphabetConverter == null)
			{
				this._alphabetConverter = new AlphabetConverter(langId);
			}
			else
			{
				this._alphabetConverter.SetLanguageId(langId);
			}
			char[] array = this._alphabetConverter.SapiToIpa(pronunciation.ToCharArray());
			if (array != null)
			{
				pronunciation = new string(array);
			}
			return pronunciation;
		}
		internal IRecognizerInternal Recognizer
		{
			get
			{
				if (this._recognizer == null)
				{
					throw new NotSupportedException(SR.Get(SRID.CantGetPropertyFromSerializedInfo, new object[] { "Recognizer" }));
				}
				return this._recognizer;
			}
		}
		internal TimeSpan AudioPosition
		{
			get
			{
				if (this._audioPosition == null)
				{
					this._audioPosition = new TimeSpan?(new TimeSpan((long)this._header.times.ullStart));
				}
				return this._audioPosition.Value;
			}
		}
		internal TimeSpan AudioDuration
		{
			get
			{
				if (this._audioDuration == null)
				{
					this._audioDuration = new TimeSpan?(new TimeSpan((long)this._header.times.ullLength));
				}
				return this._audioDuration.Value;
			}
		}
		private void Initialize(IRecognizerInternal recognizer, ISpRecoResult recoResult, byte[] sapiResultBlob, int maxAlternates)
		{
			this._recognizer = recognizer;
			this._maxAlternates = maxAlternates;
			try
			{
				this._sapiRecoResult = recoResult as ISpRecoResult2;
			}
			catch (COMException)
			{
				this._sapiRecoResult = null;
			}
			GCHandle gchandle = GCHandle.Alloc(sapiResultBlob, GCHandleType.Pinned);
			try
			{
				IntPtr intPtr = gchandle.AddrOfPinnedObject();
				int num = Marshal.ReadInt32(intPtr, 4);
				if (num == Marshal.SizeOf(typeof(SPRESULTHEADER_Sapi51)))
				{
					SPRESULTHEADER_Sapi51 spresultheader_Sapi = (SPRESULTHEADER_Sapi51)Marshal.PtrToStructure(intPtr, typeof(SPRESULTHEADER_Sapi51));
					this._header = new SPRESULTHEADER(spresultheader_Sapi);
					this._isSapi53Header = false;
				}
				else
				{
					this._header = (SPRESULTHEADER)Marshal.PtrToStructure(intPtr, typeof(SPRESULTHEADER));
					this._isSapi53Header = true;
				}
				this._header.Validate();
				IntPtr intPtr2 = new IntPtr((long)intPtr + (long)this._header.ulPhraseOffset);
				SPSERIALIZEDPHRASE phraseHeader = RecognizedPhrase.GetPhraseHeader(intPtr2, this._header.ulPhraseDataSize, this._isSapi53Header);
				bool flag = (this._header.fAlphabet & 1U) != 0U;
				base.InitializeFromSerializedBuffer(this, phraseHeader, intPtr2, (int)this._header.ulPhraseDataSize, this._isSapi53Header, flag);
				if (recoResult != null)
				{
					this.ExtractDictationAlternates(recoResult, maxAlternates);
					recoResult.Discard(255U);
				}
			}
			finally
			{
				gchandle.Free();
			}
			this._sapiAudioBlob = new byte[this._header.ulRetainedDataSize];
			Array.Copy(sapiResultBlob, (int)this._header.ulRetainedOffset, this._sapiAudioBlob, 0, (int)this._header.ulRetainedDataSize);
			this._sapiAlternatesBlob = new byte[this._header.ulPhraseAltDataSize];
			Array.Copy(sapiResultBlob, (int)this._header.ulPhraseAltOffset, this._sapiAlternatesBlob, 0, (int)this._header.ulPhraseAltDataSize);
		}
		private Collection<RecognizedPhrase> ExtractAlternates(int numberOfAlternates, bool isSapi53Header)
		{
			Collection<RecognizedPhrase> collection = new Collection<RecognizedPhrase>();
			if (numberOfAlternates > 0)
			{
				GCHandle gchandle = GCHandle.Alloc(this._sapiAlternatesBlob, GCHandleType.Pinned);
				try
				{
					IntPtr intPtr = gchandle.AddrOfPinnedObject();
					int num = Marshal.SizeOf(typeof(SPSERIALIZEDPHRASEALT));
					int num2 = 0;
					for (int i = 0; i < numberOfAlternates; i++)
					{
						IntPtr intPtr2 = new IntPtr((long)intPtr + (long)num2);
						SPSERIALIZEDPHRASEALT spserializedphrasealt = (SPSERIALIZEDPHRASEALT)Marshal.PtrToStructure(intPtr2, typeof(SPSERIALIZEDPHRASEALT));
						num2 += num;
						if (isSapi53Header)
						{
							num2 += (int)((ulong)(spserializedphrasealt.cbAltExtra + 7U) & 18446744073709551608UL);
						}
						else
						{
							num2 += (int)spserializedphrasealt.cbAltExtra;
						}
						IntPtr intPtr3 = new IntPtr((long)intPtr + (long)num2);
						SPSERIALIZEDPHRASE phraseHeader = RecognizedPhrase.GetPhraseHeader(intPtr3, this._header.ulPhraseAltDataSize - (uint)num2, this._isSapi53Header);
						int ulSerializedSize = (int)phraseHeader.ulSerializedSize;
						RecognizedPhrase recognizedPhrase = new RecognizedPhrase();
						bool flag = (this._header.fAlphabet & 2U) != 0U;
						recognizedPhrase.InitializeFromSerializedBuffer(this, phraseHeader, intPtr3, ulSerializedSize, isSapi53Header, flag);
						if (isSapi53Header)
						{
							num2 += (ulSerializedSize + 7) & -8;
						}
						else
						{
							num2 += ulSerializedSize;
						}
						collection.Add(recognizedPhrase);
					}
				}
				finally
				{
					gchandle.Free();
				}
			}
			return collection;
		}
		private void ExtractDictationAlternates(ISpRecoResult recoResult, int maxAlternates)
		{
			if (recoResult != null && base.Grammar is DictationGrammar)
			{
				this._alternates = new Collection<RecognizedPhrase>();
				IntPtr[] array = new IntPtr[maxAlternates];
				try
				{
					recoResult.GetAlternates(0, -1, maxAlternates, array, out maxAlternates);
				}
				catch (COMException)
				{
					maxAlternates = 0;
				}
				uint num = 0U;
				while ((ulong)num < (ulong)((long)maxAlternates))
				{
					ISpPhraseAlt spPhraseAlt = (ISpPhraseAlt)Marshal.GetObjectForIUnknown(array[(int)((UIntPtr)num)]);
					try
					{
						IntPtr intPtr;
						spPhraseAlt.GetSerializedPhrase(out intPtr);
						try
						{
							RecognizedPhrase recognizedPhrase = new RecognizedPhrase();
							SPSERIALIZEDPHRASE phraseHeader = RecognizedPhrase.GetPhraseHeader(intPtr, uint.MaxValue, this._isSapi53Header);
							bool flag = (this._header.fAlphabet & 1U) != 0U;
							recognizedPhrase.InitializeFromSerializedBuffer(this, phraseHeader, intPtr, (int)phraseHeader.ulSerializedSize, this._isSapi53Header, flag);
							this._alternates.Add(recognizedPhrase);
						}
						finally
						{
							Marshal.FreeCoTaskMem(intPtr);
						}
					}
					finally
					{
						Marshal.Release(array[(int)((UIntPtr)num)]);
					}
					num += 1U;
				}
			}
		}
		private Collection<RecognizedPhrase> GetAlternates()
		{
			if (this._alternates == null)
			{
				this._alternates = this.ExtractAlternates((int)this._header.ulNumPhraseAlts, this._isSapi53Header);
				if (this._alternates.Count == 0 && this._maxAlternates > 0)
				{
					RecognizedPhrase recognizedPhrase = new RecognizedPhrase();
					GCHandle gchandle = GCHandle.Alloc(this._phraseBuffer, GCHandleType.Pinned);
					try
					{
						recognizedPhrase.InitializeFromSerializedBuffer(this, this._serializedPhrase, gchandle.AddrOfPinnedObject(), this._phraseBuffer.Length, this._isSapi53Header, this._hasIPAPronunciation);
					}
					finally
					{
						gchandle.Free();
					}
					this._alternates.Add(recognizedPhrase);
				}
			}
			return this._alternates;
		}
		internal string DebuggerDisplayString()
		{
			StringBuilder stringBuilder = new StringBuilder("Recognized text: '");
			stringBuilder.Append(base.Text);
			stringBuilder.Append("'");
			if (base.Semantics.Value != null)
			{
				stringBuilder.Append(" - Semantic Value  = ");
				stringBuilder.Append(base.Semantics.Value.ToString());
			}
			if (base.Semantics.Count > 0)
			{
				stringBuilder.Append(" - Semantic children count = ");
				stringBuilder.Append(base.Semantics.Count.ToString(CultureInfo.InvariantCulture));
			}
			if (this.Alternates.Count > 1)
			{
				stringBuilder.Append(" - Alternate word count = ");
				stringBuilder.Append(this.Alternates.Count.ToString(CultureInfo.InvariantCulture));
			}
			return stringBuilder.ToString();
		}
		[NonSerialized]
		private IRecognizerInternal _recognizer;
		[NonSerialized]
		private int _maxAlternates;
		[NonSerialized]
		private AlphabetConverter _alphabetConverter;
		private byte[] _sapiAudioBlob;
		private byte[] _sapiAlternatesBlob;
		private Collection<RecognizedPhrase> _alternates;
		private SPRESULTHEADER _header;
		private RecognizedAudio _audio;
		private DateTime _startTime = DateTime.Now;
		[NonSerialized]
		private ISpRecoResult2 _sapiRecoResult;
		private TimeSpan? _audioPosition;
		private TimeSpan? _audioDuration;
	}
}

SpeechRecognitionEngine.cs

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Speech.AudioFormat;
using System.Speech.Internal;
using System.Speech.Internal.ObjectTokens;
using System.Speech.Internal.SapiInterop;

namespace System.Speech.Recognition
{
	public class SpeechRecognitionEngine : IDisposable
	{
		public SpeechRecognitionEngine()
		{
			this.Initialize(null);
		}
		public SpeechRecognitionEngine(CultureInfo culture)
		{
			Helpers.ThrowIfNull(culture, "culture");
			if (culture.Equals(CultureInfo.InvariantCulture))
			{
				throw new ArgumentException(SR.Get(SRID.InvariantCultureInfo, new object[0]), "culture");
			}
			foreach (RecognizerInfo recognizerInfo in SpeechRecognitionEngine.InstalledRecognizers())
			{
				if (culture.Equals(recognizerInfo.Culture))
				{
					this.Initialize(recognizerInfo);
					return;
				}
			}
			foreach (RecognizerInfo recognizerInfo2 in SpeechRecognitionEngine.InstalledRecognizers())
			{
				if (Helpers.CompareInvariantCulture(recognizerInfo2.Culture, culture))
				{
					this.Initialize(recognizerInfo2);
					return;
				}
			}
			throw new ArgumentException(SR.Get(SRID.RecognizerNotFound, new object[0]), "culture");
		}
		public SpeechRecognitionEngine(string recognizerId)
		{
			Helpers.ThrowIfEmptyOrNull(recognizerId, "recognizerId");
			foreach (RecognizerInfo recognizerInfo in SpeechRecognitionEngine.InstalledRecognizers())
			{
				if (recognizerId.Equals(recognizerInfo.Id, StringComparison.OrdinalIgnoreCase))
				{
					this.Initialize(recognizerInfo);
					return;
				}
			}
			throw new ArgumentException(SR.Get(SRID.RecognizerNotFound, new object[0]), "recognizerId");
		}
		public SpeechRecognitionEngine(RecognizerInfo recognizerInfo)
		{
			Helpers.ThrowIfNull(recognizerInfo, "recognizerInfo");
			this.Initialize(recognizerInfo);
		}
		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}
		protected virtual void Dispose(bool disposing)
		{
			if (disposing && !this._disposed)
			{
				if (this._recognizerBase != null)
				{
					this._recognizerBase.Dispose();
					this._recognizerBase = null;
				}
				if (this._sapiRecognizer != null)
				{
					this._sapiRecognizer.Dispose();
					this._sapiRecognizer = null;
				}
				this._disposed = true;
			}
		}
		public static ReadOnlyCollection<RecognizerInfo> InstalledRecognizers()
		{
			List<RecognizerInfo> list = new List<RecognizerInfo>();
			using (ObjectTokenCategory objectTokenCategory = ObjectTokenCategory.Create("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Recognizers"))
			{
				if (objectTokenCategory != null)
				{
					foreach (ObjectToken objectToken in ((IEnumerable<ObjectToken>)objectTokenCategory))
					{
						RecognizerInfo recognizerInfo = RecognizerInfo.Create(objectToken);
						if (recognizerInfo != null)
						{
							list.Add(recognizerInfo);
						}
					}
				}
			}
			return new ReadOnlyCollection<RecognizerInfo>(list);
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TimeSpan InitialSilenceTimeout
		{
			get
			{
				return this.RecoBase.InitialSilenceTimeout;
			}
			set
			{
				this.RecoBase.InitialSilenceTimeout = value;
			}
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TimeSpan BabbleTimeout
		{
			get
			{
				return this.RecoBase.BabbleTimeout;
			}
			set
			{
				this.RecoBase.BabbleTimeout = value;
			}
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TimeSpan EndSilenceTimeout
		{
			get
			{
				return TimeSpan.FromMilliseconds((double)this.RecoBase.QueryRecognizerSettingAsInt("ResponseSpeed"));
			}
			set
			{
				if (value.TotalMilliseconds < 0.0 || value.TotalMilliseconds > 10000.0)
				{
					throw new ArgumentOutOfRangeException("value", SR.Get(SRID.EndSilenceOutOfRange, new object[0]));
				}
				this.RecoBase.UpdateRecognizerSetting("ResponseSpeed", (int)value.TotalMilliseconds);
			}
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TimeSpan EndSilenceTimeoutAmbiguous
		{
			get
			{
				return TimeSpan.FromMilliseconds((double)this.RecoBase.QueryRecognizerSettingAsInt("ComplexResponseSpeed"));
			}
			set
			{
				if (value.TotalMilliseconds < 0.0 || value.TotalMilliseconds > 10000.0)
				{
					throw new ArgumentOutOfRangeException("value", SR.Get(SRID.EndSilenceOutOfRange, new object[0]));
				}
				this.RecoBase.UpdateRecognizerSetting("ComplexResponseSpeed", (int)value.TotalMilliseconds);
			}
		}
		public ReadOnlyCollection<Grammar> Grammars
		{
			get
			{
				return this.RecoBase.Grammars;
			}
		}
		public RecognizerInfo RecognizerInfo
		{
			get
			{
				return this.RecoBase.RecognizerInfo;
			}
		}
		public AudioState AudioState
		{
			get
			{
				return this.RecoBase.AudioState;
			}
		}
		public int AudioLevel
		{
			get
			{
				return this.RecoBase.AudioLevel;
			}
		}
		public TimeSpan RecognizerAudioPosition
		{
			get
			{
				return this.RecoBase.RecognizerAudioPosition;
			}
		}
		public TimeSpan AudioPosition
		{
			get
			{
				return this.RecoBase.AudioPosition;
			}
		}
		public SpeechAudioFormatInfo AudioFormat
		{
			get
			{
				return this.RecoBase.AudioFormat;
			}
		}
		public int MaxAlternates
		{
			get
			{
				return this.RecoBase.MaxAlternates;
			}
			set
			{
				this.RecoBase.MaxAlternates = value;
			}
		}
		public void SetInputToWaveFile(string path)
		{
			Helpers.ThrowIfEmptyOrNull(path, "path");
			this.RecoBase.SetInput(path);
		}
		public void SetInputToWaveStream(Stream audioSource)
		{
			this.RecoBase.SetInput(audioSource, null);
		}
		public void SetInputToAudioStream(Stream audioSource, SpeechAudioFormatInfo audioFormat)
		{
			Helpers.ThrowIfNull(audioSource, "audioSource");
			Helpers.ThrowIfNull(audioFormat, "audioFormat");
			this.RecoBase.SetInput(audioSource, audioFormat);
		}
		public void SetInputToNull()
		{
			this.RecoBase.SetInput(null, null);
		}
		public void SetInputToDefaultAudioDevice()
		{
			this.RecoBase.SetInputToDefaultAudioDevice();
		}
		public RecognitionResult Recognize()
		{
			return this.RecoBase.Recognize(this.RecoBase.InitialSilenceTimeout);
		}
		public RecognitionResult Recognize(TimeSpan initialSilenceTimeout)
		{
			if (this.Grammars.Count == 0)
			{
				throw new InvalidOperationException(SR.Get(SRID.RecognizerHasNoGrammar, new object[0]));
			}
			return this.RecoBase.Recognize(initialSilenceTimeout);
		}
		public void RecognizeAsync()
		{
			this.RecognizeAsync(RecognizeMode.Single);
		}
		public void RecognizeAsync(RecognizeMode mode)
		{
			if (this.Grammars.Count == 0)
			{
				throw new InvalidOperationException(SR.Get(SRID.RecognizerHasNoGrammar, new object[0]));
			}
			this.RecoBase.RecognizeAsync(mode);
		}
		public void RecognizeAsyncCancel()
		{
			this.RecoBase.RecognizeAsyncCancel();
		}
		public void RecognizeAsyncStop()
		{
			this.RecoBase.RecognizeAsyncStop();
		}
		public object QueryRecognizerSetting(string settingName)
		{
			return this.RecoBase.QueryRecognizerSetting(settingName);
		}
		public void UpdateRecognizerSetting(string settingName, string updatedValue)
		{
			this.RecoBase.UpdateRecognizerSetting(settingName, updatedValue);
		}
		public void UpdateRecognizerSetting(string settingName, int updatedValue)
		{
			this.RecoBase.UpdateRecognizerSetting(settingName, updatedValue);
		}
		public void LoadGrammar(Grammar grammar)
		{
			this.RecoBase.LoadGrammar(grammar);
		}
		public void LoadGrammarAsync(Grammar grammar)
		{
			this.RecoBase.LoadGrammarAsync(grammar);
		}
		public void UnloadGrammar(Grammar grammar)
		{
			this.RecoBase.UnloadGrammar(grammar);
		}
		public void UnloadAllGrammars()
		{
			this.RecoBase.UnloadAllGrammars();
		}
		public RecognitionResult EmulateRecognize(string inputText)
		{
			return this.EmulateRecognize(inputText, CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth);
		}
		public RecognitionResult EmulateRecognize(string inputText, CompareOptions compareOptions)
		{
			if (this.Grammars.Count == 0)
			{
				throw new InvalidOperationException(SR.Get(SRID.RecognizerHasNoGrammar, new object[0]));
			}
			return this.RecoBase.EmulateRecognize(inputText, compareOptions);
		}
		public RecognitionResult EmulateRecognize(RecognizedWordUnit[] wordUnits, CompareOptions compareOptions)
		{
			if (this.Grammars.Count == 0)
			{
				throw new InvalidOperationException(SR.Get(SRID.RecognizerHasNoGrammar, new object[0]));
			}
			return this.RecoBase.EmulateRecognize(wordUnits, compareOptions);
		}
		public void EmulateRecognizeAsync(string inputText)
		{
			this.EmulateRecognizeAsync(inputText, CompareOptions.IgnoreCase | CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth);
		}
		public void EmulateRecognizeAsync(string inputText, CompareOptions compareOptions)
		{
			if (this.Grammars.Count == 0)
			{
				throw new InvalidOperationException(SR.Get(SRID.RecognizerHasNoGrammar, new object[0]));
			}
			this.RecoBase.EmulateRecognizeAsync(inputText, compareOptions);
		}
		public void EmulateRecognizeAsync(RecognizedWordUnit[] wordUnits, CompareOptions compareOptions)
		{
			if (this.Grammars.Count == 0)
			{
				throw new InvalidOperationException(SR.Get(SRID.RecognizerHasNoGrammar, new object[0]));
			}
			this.RecoBase.EmulateRecognizeAsync(wordUnits, compareOptions);
		}
		public void RequestRecognizerUpdate()
		{
			this.RecoBase.RequestRecognizerUpdate();
		}
		public void RequestRecognizerUpdate(object userToken)
		{
			this.RecoBase.RequestRecognizerUpdate(userToken);
		}
		public void RequestRecognizerUpdate(object userToken, TimeSpan audioPositionAheadToRaiseUpdate)
		{
			this.RecoBase.RequestRecognizerUpdate(userToken, audioPositionAheadToRaiseUpdate);
		}
		public event EventHandler<RecognizeCompletedEventArgs> RecognizeCompleted;
		public event EventHandler<EmulateRecognizeCompletedEventArgs> EmulateRecognizeCompleted;
		public event EventHandler<LoadGrammarCompletedEventArgs> LoadGrammarCompleted;
		public event EventHandler<SpeechDetectedEventArgs> SpeechDetected;
		public event EventHandler<SpeechRecognizedEventArgs> SpeechRecognized;
		public event EventHandler<SpeechRecognitionRejectedEventArgs> SpeechRecognitionRejected;
		public event EventHandler<RecognizerUpdateReachedEventArgs> RecognizerUpdateReached;
		public event EventHandler<SpeechHypothesizedEventArgs> SpeechHypothesized
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				if (this._speechHypothesizedDelegate == null)
				{
					this.RecoBase.SpeechHypothesized += this.SpeechHypothesizedProxy;
				}
				this._speechHypothesizedDelegate = (EventHandler<SpeechHypothesizedEventArgs>)Delegate.Combine(this._speechHypothesizedDelegate, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this._speechHypothesizedDelegate = (EventHandler<SpeechHypothesizedEventArgs>)Delegate.Remove(this._speechHypothesizedDelegate, value);
				if (this._speechHypothesizedDelegate == null)
				{
					this.RecoBase.SpeechHypothesized -= this.SpeechHypothesizedProxy;
				}
			}
		}
		public event EventHandler<AudioSignalProblemOccurredEventArgs> AudioSignalProblemOccurred
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				if (this._audioSignalProblemOccurredDelegate == null)
				{
					this.RecoBase.AudioSignalProblemOccurred += this.AudioSignalProblemOccurredProxy;
				}
				this._audioSignalProblemOccurredDelegate = (EventHandler<AudioSignalProblemOccurredEventArgs>)Delegate.Combine(this._audioSignalProblemOccurredDelegate, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this._audioSignalProblemOccurredDelegate = (EventHandler<AudioSignalProblemOccurredEventArgs>)Delegate.Remove(this._audioSignalProblemOccurredDelegate, value);
				if (this._audioSignalProblemOccurredDelegate == null)
				{
					this.RecoBase.AudioSignalProblemOccurred -= this.AudioSignalProblemOccurredProxy;
				}
			}
		}
		public event EventHandler<AudioLevelUpdatedEventArgs> AudioLevelUpdated
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				if (this._audioLevelUpdatedDelegate == null)
				{
					this.RecoBase.AudioLevelUpdated += this.AudioLevelUpdatedProxy;
				}
				this._audioLevelUpdatedDelegate = (EventHandler<AudioLevelUpdatedEventArgs>)Delegate.Combine(this._audioLevelUpdatedDelegate, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this._audioLevelUpdatedDelegate = (EventHandler<AudioLevelUpdatedEventArgs>)Delegate.Remove(this._audioLevelUpdatedDelegate, value);
				if (this._audioLevelUpdatedDelegate == null)
				{
					this.RecoBase.AudioLevelUpdated -= this.AudioLevelUpdatedProxy;
				}
			}
		}
		public event EventHandler<AudioStateChangedEventArgs> AudioStateChanged
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				if (this._audioStateChangedDelegate == null)
				{
					this.RecoBase.AudioStateChanged += this.AudioStateChangedProxy;
				}
				this._audioStateChangedDelegate = (EventHandler<AudioStateChangedEventArgs>)Delegate.Combine(this._audioStateChangedDelegate, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this._audioStateChangedDelegate = (EventHandler<AudioStateChangedEventArgs>)Delegate.Remove(this._audioStateChangedDelegate, value);
				if (this._audioStateChangedDelegate == null)
				{
					this.RecoBase.AudioStateChanged -= this.AudioStateChangedProxy;
				}
			}
		}
		private void Initialize(RecognizerInfo recognizerInfo)
		{
			try
			{
				this._sapiRecognizer = new SapiRecognizer(SapiRecognizer.RecognizerType.InProc);
			}
			catch (COMException ex)
			{
				throw RecognizerBase.ExceptionFromSapiCreateRecognizerError(ex);
			}
			if (recognizerInfo != null)
			{
				ObjectToken objectToken = recognizerInfo.GetObjectToken();
				if (objectToken == null)
				{
					throw new ArgumentException(SR.Get(SRID.NullParamIllegal, new object[0]), "recognizerInfo");
				}
				try
				{
					this._sapiRecognizer.SetRecognizer(objectToken.SAPIToken);
				}
				catch (COMException ex2)
				{
					throw new ArgumentException(SR.Get(SRID.RecognizerNotFound, new object[0]), RecognizerBase.ExceptionFromSapiCreateRecognizerError(ex2));
				}
			}
			this._sapiRecognizer.SetRecoState(SPRECOSTATE.SPRST_INACTIVE);
		}
		private void RecognizeCompletedProxy(object sender, RecognizeCompletedEventArgs e)
		{
			EventHandler<RecognizeCompletedEventArgs> recognizeCompleted = this.RecognizeCompleted;
			if (recognizeCompleted != null)
			{
				recognizeCompleted(this, e);
			}
		}
		private void EmulateRecognizeCompletedProxy(object sender, EmulateRecognizeCompletedEventArgs e)
		{
			EventHandler<EmulateRecognizeCompletedEventArgs> emulateRecognizeCompleted = this.EmulateRecognizeCompleted;
			if (emulateRecognizeCompleted != null)
			{
				emulateRecognizeCompleted(this, e);
			}
		}
		private void LoadGrammarCompletedProxy(object sender, LoadGrammarCompletedEventArgs e)
		{
			EventHandler<LoadGrammarCompletedEventArgs> loadGrammarCompleted = this.LoadGrammarCompleted;
			if (loadGrammarCompleted != null)
			{
				loadGrammarCompleted(this, e);
			}
		}
		private void SpeechDetectedProxy(object sender, SpeechDetectedEventArgs e)
		{
			EventHandler<SpeechDetectedEventArgs> speechDetected = this.SpeechDetected;
			if (speechDetected != null)
			{
				speechDetected(this, e);
			}
		}
		private void SpeechRecognizedProxy(object sender, SpeechRecognizedEventArgs e)
		{
			EventHandler<SpeechRecognizedEventArgs> speechRecognized = this.SpeechRecognized;
			if (speechRecognized != null)
			{
				speechRecognized(this, e);
			}
		}
		private void SpeechRecognitionRejectedProxy(object sender, SpeechRecognitionRejectedEventArgs e)
		{
			EventHandler<SpeechRecognitionRejectedEventArgs> speechRecognitionRejected = this.SpeechRecognitionRejected;
			if (speechRecognitionRejected != null)
			{
				speechRecognitionRejected(this, e);
			}
		}
		private void RecognizerUpdateReachedProxy(object sender, RecognizerUpdateReachedEventArgs e)
		{
			EventHandler<RecognizerUpdateReachedEventArgs> recognizerUpdateReached = this.RecognizerUpdateReached;
			if (recognizerUpdateReached != null)
			{
				recognizerUpdateReached(this, e);
			}
		}
		private void SpeechHypothesizedProxy(object sender, SpeechHypothesizedEventArgs e)
		{
			EventHandler<SpeechHypothesizedEventArgs> speechHypothesizedDelegate = this._speechHypothesizedDelegate;
			if (speechHypothesizedDelegate != null)
			{
				speechHypothesizedDelegate(this, e);
			}
		}
		private void AudioSignalProblemOccurredProxy(object sender, AudioSignalProblemOccurredEventArgs e)
		{
			EventHandler<AudioSignalProblemOccurredEventArgs> audioSignalProblemOccurredDelegate = this._audioSignalProblemOccurredDelegate;
			if (audioSignalProblemOccurredDelegate != null)
			{
				audioSignalProblemOccurredDelegate(this, e);
			}
		}
		private void AudioLevelUpdatedProxy(object sender, AudioLevelUpdatedEventArgs e)
		{
			EventHandler<AudioLevelUpdatedEventArgs> audioLevelUpdatedDelegate = this._audioLevelUpdatedDelegate;
			if (audioLevelUpdatedDelegate != null)
			{
				audioLevelUpdatedDelegate(this, e);
			}
		}
		private void AudioStateChangedProxy(object sender, AudioStateChangedEventArgs e)
		{
			EventHandler<AudioStateChangedEventArgs> audioStateChangedDelegate = this._audioStateChangedDelegate;
			if (audioStateChangedDelegate != null)
			{
				audioStateChangedDelegate(this, e);
			}
		}
		private RecognizerBase RecoBase
		{
			get
			{
				if (this._disposed)
				{
					throw new ObjectDisposedException("SpeechRecognitionEngine");
				}
				if (this._recognizerBase == null)
				{
					this._recognizerBase = new RecognizerBase();
					this._recognizerBase.Initialize(this._sapiRecognizer, true);
					this._recognizerBase.RecognizeCompleted += this.RecognizeCompletedProxy;
					this._recognizerBase.EmulateRecognizeCompleted += this.EmulateRecognizeCompletedProxy;
					this._recognizerBase.LoadGrammarCompleted += this.LoadGrammarCompletedProxy;
					this._recognizerBase.SpeechDetected += this.SpeechDetectedProxy;
					this._recognizerBase.SpeechRecognized += this.SpeechRecognizedProxy;
					this._recognizerBase.SpeechRecognitionRejected += this.SpeechRecognitionRejectedProxy;
					this._recognizerBase.RecognizerUpdateReached += this.RecognizerUpdateReachedProxy;
				}
				return this._recognizerBase;
			}
		}
		private bool _disposed;
		private RecognizerBase _recognizerBase;
		private SapiRecognizer _sapiRecognizer;
		private EventHandler<AudioSignalProblemOccurredEventArgs> _audioSignalProblemOccurredDelegate;
		private EventHandler<AudioLevelUpdatedEventArgs> _audioLevelUpdatedDelegate;
		private EventHandler<AudioStateChangedEventArgs> _audioStateChangedDelegate;
		private EventHandler<SpeechHypothesizedEventArgs> _speechHypothesizedDelegate;
	}
}

ContourPoint.cs

using System;
using System.ComponentModel;

namespace System.Speech.Synthesis.TtsEngine
{
	[ImmutableObject(true)]
	public struct ContourPoint : IEquatable<ContourPoint>
	{
		public float Start
		{
			get
			{
				return this._start;
			}
		}
		public float Change
		{
			get
			{
				return this._change;
			}
		}
		public ContourPointChangeType ChangeType
		{
			get
			{
				return this._changeType;
			}
		}
		public ContourPoint(float start, float change, ContourPointChangeType changeType)
		{
			this._start = start;
			this._change = change;
			this._changeType = changeType;
		}
		public static bool operator ==(ContourPoint point1, ContourPoint point2)
		{
			return point1.Start.Equals(point2.Start) && point1.Change.Equals(point2.Change) && point1.ChangeType.Equals(point2.ChangeType);
		}
		public static bool operator !=(ContourPoint point1, ContourPoint point2)
		{
			return !(point1 == point2);
		}
		public bool Equals(ContourPoint other)
		{
			return this == other;
		}
		public override bool Equals(object obj)
		{
			return obj is ContourPoint && this.Equals((ContourPoint)obj);
		}
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
		private float _start;
		private float _change;
		private ContourPointChangeType _changeType;
	}
}

EventParameterType.cs

using System;

namespace System.Speech.Synthesis.TtsEngine
{
	public enum EventParameterType
	{
		Undefined,
		Token,
		Object,
		Pointer,
		String
	}
}

FragmentState.cs

using System;
using System.ComponentModel;
using System.Speech.Internal;

namespace System.Speech.Synthesis.TtsEngine
{
	[ImmutableObject(true)]
	public struct FragmentState : IEquatable<FragmentState>
	{
		public TtsEngineAction Action
		{
			get
			{
				return this._action;
			}
			internal set
			{
				this._action = value;
			}
		}
		public int LangId
		{
			get
			{
				return this._langId;
			}
			internal set
			{
				this._langId = value;
			}
		}
		public int Emphasis
		{
			get
			{
				return this._emphasis;
			}
			internal set
			{
				this._emphasis = value;
			}
		}
		public int Duration
		{
			get
			{
				return this._duration;
			}
			internal set
			{
				this._duration = value;
			}
		}
		public SayAs SayAs
		{
			get
			{
				return this._sayAs;
			}
			internal set
			{
				Helpers.ThrowIfNull(value, "value");
				this._sayAs = value;
			}
		}
		public Prosody Prosody
		{
			get
			{
				return this._prosody;
			}
			internal set
			{
				Helpers.ThrowIfNull(value, "value");
				this._prosody = value;
			}
		}
		public char[] Phoneme
		{
			get
			{
				return this._phoneme;
			}
			internal set
			{
				Helpers.ThrowIfNull(value, "value");
				this._phoneme = value;
			}
		}
		public FragmentState(TtsEngineAction action, int langId, int emphasis, int duration, SayAs sayAs, Prosody prosody, char[] phonemes)
		{
			this._action = action;
			this._langId = langId;
			this._emphasis = emphasis;
			this._duration = duration;
			this._sayAs = sayAs;
			this._prosody = prosody;
			this._phoneme = phonemes;
		}
		public static bool operator ==(FragmentState state1, FragmentState state2)
		{
			return state1.Action == state2.Action && state1.LangId == state2.LangId && state1.Emphasis == state2.Emphasis && state1.Duration == state2.Duration && state1.SayAs == state2.SayAs && state1.Prosody == state2.Prosody && object.Equals(state1.Phoneme, state2.Phoneme);
		}
		public static bool operator !=(FragmentState state1, FragmentState state2)
		{
			return !(state1 == state2);
		}
		public bool Equals(FragmentState other)
		{
			return this == other;
		}
		public override bool Equals(object obj)
		{
			return obj is FragmentState && this.Equals((FragmentState)obj);
		}
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
		private TtsEngineAction _action;
		private int _langId;
		private int _emphasis;
		private int _duration;
		private SayAs _sayAs;
		private Prosody _prosody;
		private char[] _phoneme;
	}
}

TtsEngineAction.cs

using System;

namespace System.Speech.Synthesis.TtsEngine
{
	public enum TtsEngineAction
	{
		Speak,
		Silence,
		Pronounce,
		Bookmark,
		SpellOut,
		StartSentence,
		StartParagraph,
		ParseUnknownTag
	}
}

BookmarkReachedEventArgs.cs

using System;

namespace System.Speech.Synthesis
{
	public class BookmarkReachedEventArgs : PromptEventArgs
	{
		internal BookmarkReachedEventArgs(Prompt prompt, string bookmark, TimeSpan audioPosition)
			: base(prompt)
		{
			this._bookmark = bookmark;
			this._audioPosition = audioPosition;
		}
		public string Bookmark
		{
			get
			{
				return this._bookmark;
			}
		}
		public TimeSpan AudioPosition
		{
			get
			{
				return this._audioPosition;
			}
		}
		private string _bookmark;
		private TimeSpan _audioPosition;
	}
}

Prompt.cs

using System;
using System.Diagnostics;
using System.IO;
using System.Speech.Internal;

namespace System.Speech.Synthesis
{
	[DebuggerDisplay("{_text}")]
	public class Prompt
	{
		public Prompt(string textToSpeak)
			: this(textToSpeak, SynthesisTextFormat.Text)
		{
		}
		public Prompt(PromptBuilder promptBuilder)
		{
			Helpers.ThrowIfNull(promptBuilder, "promptBuilder");
			this._text = promptBuilder.ToXml();
			this._media = SynthesisMediaType.Ssml;
		}
		public Prompt(string textToSpeak, SynthesisTextFormat media)
		{
			Helpers.ThrowIfNull(textToSpeak, "textToSpeak");
			this._media = (SynthesisMediaType)media;
			switch (media)
			{
			case SynthesisTextFormat.Text:
			case SynthesisTextFormat.Ssml:
				this._text = textToSpeak;
				return;
			default:
				throw new ArgumentException(SR.Get(SRID.SynthesizerUnknownMediaType, new object[0]), "media");
			}
		}
		internal Prompt(Uri promptFile, SynthesisMediaType media)
		{
			Helpers.ThrowIfNull(promptFile, "promptFile");
			this._media = media;
			switch (media)
			{
			case SynthesisMediaType.Text:
			case SynthesisMediaType.Ssml:
			{
				string text;
				Uri uri;
				string text2;
				using (Stream stream = Prompt._resourceLoader.LoadFile(promptFile, out text, out uri, out text2))
				{
					try
					{
						using (TextReader textReader = new StreamReader(stream))
						{
							this._text = textReader.ReadToEnd();
						}
					}
					finally
					{
						Prompt._resourceLoader.UnloadFile(text2);
					}
					return;
				}
				break;
			}
			case SynthesisMediaType.WaveAudio:
				break;
			default:
				throw new ArgumentException(SR.Get(SRID.SynthesizerUnknownMediaType, new object[0]), "media");
			}
			this._text = promptFile.ToString();
			this._audio = promptFile;
		}
		public bool IsCompleted
		{
			get
			{
				return this._completed;
			}
			internal set
			{
				this._completed = value;
			}
		}
		internal object Synthesizer
		{
			set
			{
				if (value != null && (this._synthesizer != null || this._completed))
				{
					throw new ArgumentException(SR.Get(SRID.SynthesizerPromptInUse, new object[0]), "synthesizer");
				}
				this._synthesizer = value;
			}
		}
		internal string _text;
		internal Uri _audio;
		internal SynthesisMediaType _media;
		internal bool _syncSpeak;
		internal Exception _exception;
		private bool _completed;
		private object _synthesizer;
		private static ResourceLoader _resourceLoader = new ResourceLoader();
	}
}

SpeechSynthesizer.cs

using System;
using System.Collections.ObjectModel;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using System.Speech.AudioFormat;
using System.Speech.Internal;
using System.Speech.Internal.Synthesis;
using System.Speech.Synthesis.TtsEngine;

namespace System.Speech.Synthesis
{
	public sealed class SpeechSynthesizer : IDisposable
	{
		~SpeechSynthesizer()
		{
			this.Dispose(false);
		}
		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}
		public void SelectVoice(string name)
		{
			Helpers.ThrowIfEmptyOrNull(name, "name");
			TTSVoice engine = this.VoiceSynthesizer.GetEngine(name, CultureInfo.CurrentUICulture, VoiceGender.NotSet, VoiceAge.NotSet, 1, true);
			if (engine == null || name != engine.VoiceInfo.Name)
			{
				throw new ArgumentException(SR.Get(SRID.SynthesizerSetVoiceNoMatch, new object[0]));
			}
			this.VoiceSynthesizer.Voice = engine;
		}
		public void SelectVoiceByHints(VoiceGender gender)
		{
			this.SelectVoiceByHints(gender, VoiceAge.NotSet, 1, CultureInfo.CurrentUICulture);
		}
		public void SelectVoiceByHints(VoiceGender gender, VoiceAge age)
		{
			this.SelectVoiceByHints(gender, age, 1, CultureInfo.CurrentUICulture);
		}
		public void SelectVoiceByHints(VoiceGender gender, VoiceAge age, int voiceAlternate)
		{
			this.SelectVoiceByHints(gender, age, voiceAlternate, CultureInfo.CurrentUICulture);
		}
		public void SelectVoiceByHints(VoiceGender gender, VoiceAge age, int voiceAlternate, CultureInfo culture)
		{
			Helpers.ThrowIfNull(culture, "culture");
			if (voiceAlternate < 0)
			{
				throw new ArgumentOutOfRangeException("voiceAlternate", SR.Get(SRID.PromptBuilderInvalidVariant, new object[0]));
			}
			if (!VoiceInfo.ValidateGender(gender))
			{
				throw new ArgumentException(SR.Get(SRID.EnumInvalid, new object[] { "VoiceGender" }), "gender");
			}
			if (!VoiceInfo.ValidateAge(age))
			{
				throw new ArgumentException(SR.Get(SRID.EnumInvalid, new object[] { "VoiceAge" }), "age");
			}
			TTSVoice engine = this.VoiceSynthesizer.GetEngine(null, culture, gender, age, voiceAlternate, true);
			if (engine == null)
			{
				throw new InvalidOperationException(SR.Get(SRID.SynthesizerSetVoiceNoMatch, new object[0]));
			}
			this.VoiceSynthesizer.Voice = engine;
		}
		public Prompt SpeakAsync(string textToSpeak)
		{
			Helpers.ThrowIfNull(textToSpeak, "textToSpeak");
			Prompt prompt = new Prompt(textToSpeak, SynthesisTextFormat.Text);
			this.SpeakAsync(prompt);
			return prompt;
		}
		public void SpeakAsync(Prompt prompt)
		{
			Helpers.ThrowIfNull(prompt, "prompt");
			prompt.Synthesizer = this;
			this.VoiceSynthesizer.SpeakAsync(prompt);
		}
		public Prompt SpeakSsmlAsync(string textToSpeak)
		{
			Helpers.ThrowIfNull(textToSpeak, "textToSpeak");
			Prompt prompt = new Prompt(textToSpeak, SynthesisTextFormat.Ssml);
			this.SpeakAsync(prompt);
			return prompt;
		}
		public Prompt SpeakAsync(PromptBuilder promptBuilder)
		{
			Helpers.ThrowIfNull(promptBuilder, "promptBuilder");
			Prompt prompt = new Prompt(promptBuilder);
			this.SpeakAsync(prompt);
			return prompt;
		}
		public void Speak(string textToSpeak)
		{
			this.Speak(new Prompt(textToSpeak, SynthesisTextFormat.Text));
		}
		public void Speak(Prompt prompt)
		{
			Helpers.ThrowIfNull(prompt, "prompt");
			if (this.State == SynthesizerState.Paused)
			{
				throw new InvalidOperationException(SR.Get(SRID.SynthesizerSyncSpeakWhilePaused, new object[0]));
			}
			prompt.Synthesizer = this;
			prompt._syncSpeak = true;
			this.VoiceSynthesizer.Speak(prompt);
		}
		public void Speak(PromptBuilder promptBuilder)
		{
			this.Speak(new Prompt(promptBuilder));
		}
		public void SpeakSsml(string textToSpeak)
		{
			this.Speak(new Prompt(textToSpeak, SynthesisTextFormat.Ssml));
		}
		public void Pause()
		{
			if (!this.paused)
			{
				this.VoiceSynthesizer.Pause();
				this.paused = true;
			}
		}
		public void Resume()
		{
			if (this.paused)
			{
				this.VoiceSynthesizer.Resume();
				this.paused = false;
			}
		}
		public void SpeakAsyncCancel(Prompt prompt)
		{
			Helpers.ThrowIfNull(prompt, "prompt");
			this.VoiceSynthesizer.Abort(prompt);
		}
		public void SpeakAsyncCancelAll()
		{
			this.VoiceSynthesizer.Abort();
		}
		public void SetOutputToWaveFile(string path)
		{
			Helpers.ThrowIfEmptyOrNull(path, "path");
			this.SetOutputToNull();
			this.SetOutputStream(new FileStream(path, FileMode.Create, FileAccess.Write), null, true, true);
		}
		public void SetOutputToWaveFile(string path, SpeechAudioFormatInfo formatInfo)
		{
			Helpers.ThrowIfEmptyOrNull(path, "path");
			Helpers.ThrowIfNull(formatInfo, "formatInfo");
			this.SetOutputToNull();
			this.SetOutputStream(new FileStream(path, FileMode.Create, FileAccess.Write), formatInfo, true, true);
		}
		public void SetOutputToWaveStream(Stream audioDestination)
		{
			Helpers.ThrowIfNull(audioDestination, "audioDestination");
			this.SetOutputStream(audioDestination, null, true, false);
		}
		public void SetOutputToAudioStream(Stream audioDestination, SpeechAudioFormatInfo formatInfo)
		{
			Helpers.ThrowIfNull(audioDestination, "audioDestination");
			Helpers.ThrowIfNull(formatInfo, "formatInfo");
			this.SetOutputStream(audioDestination, formatInfo, false, false);
		}
		public void SetOutputToDefaultAudioDevice()
		{
			this.SetOutputStream(null, null, true, false);
		}
		public void SetOutputToNull()
		{
			if (this._outputStream != Stream.Null)
			{
				this.VoiceSynthesizer.SetOutput(Stream.Null, null, true);
			}
			if (this._outputStream != null && this._closeStreamOnExit)
			{
				this._outputStream.Close();
			}
			this._outputStream = Stream.Null;
		}
		public Prompt GetCurrentlySpokenPrompt()
		{
			return this.VoiceSynthesizer.Prompt;
		}
		public ReadOnlyCollection<InstalledVoice> GetInstalledVoices()
		{
			return this.VoiceSynthesizer.GetInstalledVoices(null);
		}
		public ReadOnlyCollection<InstalledVoice> GetInstalledVoices(CultureInfo culture)
		{
			Helpers.ThrowIfNull(culture, "culture");
			if (culture.Equals(CultureInfo.InvariantCulture))
			{
				throw new ArgumentException(SR.Get(SRID.InvariantCultureInfo, new object[0]), "culture");
			}
			return this.VoiceSynthesizer.GetInstalledVoices(culture);
		}
		public void AddLexicon(Uri uri, string mediaType)
		{
			Helpers.ThrowIfNull(uri, "uri");
			this.VoiceSynthesizer.AddLexicon(uri, mediaType);
		}
		public void RemoveLexicon(Uri uri)
		{
			Helpers.ThrowIfNull(uri, "uri");
			this.VoiceSynthesizer.RemoveLexicon(uri);
		}
		public event EventHandler<SpeakStartedEventArgs> SpeakStarted
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				VoiceSynthesis voiceSynthesizer = this.VoiceSynthesizer;
				voiceSynthesizer._speakStarted = (EventHandler<SpeakStartedEventArgs>)Delegate.Combine(voiceSynthesizer._speakStarted, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				VoiceSynthesis voiceSynthesizer = this.VoiceSynthesizer;
				voiceSynthesizer._speakStarted = (EventHandler<SpeakStartedEventArgs>)Delegate.Remove(voiceSynthesizer._speakStarted, value);
			}
		}
		public event EventHandler<SpeakCompletedEventArgs> SpeakCompleted
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				VoiceSynthesis voiceSynthesizer = this.VoiceSynthesizer;
				voiceSynthesizer._speakCompleted = (EventHandler<SpeakCompletedEventArgs>)Delegate.Combine(voiceSynthesizer._speakCompleted, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				VoiceSynthesis voiceSynthesizer = this.VoiceSynthesizer;
				voiceSynthesizer._speakCompleted = (EventHandler<SpeakCompletedEventArgs>)Delegate.Remove(voiceSynthesizer._speakCompleted, value);
			}
		}
		public event EventHandler<SpeakProgressEventArgs> SpeakProgress
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.AddEvent<SpeakProgressEventArgs>(TtsEventId.WordBoundary, ref this.VoiceSynthesizer._speakProgress, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.RemoveEvent<SpeakProgressEventArgs>(TtsEventId.WordBoundary, ref this.VoiceSynthesizer._speakProgress, value);
			}
		}
		public event EventHandler<BookmarkReachedEventArgs> BookmarkReached
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.AddEvent<BookmarkReachedEventArgs>(TtsEventId.Bookmark, ref this.VoiceSynthesizer._bookmarkReached, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.RemoveEvent<BookmarkReachedEventArgs>(TtsEventId.Bookmark, ref this.VoiceSynthesizer._bookmarkReached, value);
			}
		}
		public event EventHandler<VoiceChangeEventArgs> VoiceChange
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.AddEvent<VoiceChangeEventArgs>(TtsEventId.VoiceChange, ref this.VoiceSynthesizer._voiceChange, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.RemoveEvent<VoiceChangeEventArgs>(TtsEventId.VoiceChange, ref this.VoiceSynthesizer._voiceChange, value);
			}
		}
		public event EventHandler<PhonemeReachedEventArgs> PhonemeReached
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.AddEvent<PhonemeReachedEventArgs>(TtsEventId.Phoneme, ref this.VoiceSynthesizer._phonemeReached, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.RemoveEvent<PhonemeReachedEventArgs>(TtsEventId.Phoneme, ref this.VoiceSynthesizer._phonemeReached, value);
			}
		}
		public event EventHandler<VisemeReachedEventArgs> VisemeReached
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.AddEvent<VisemeReachedEventArgs>(TtsEventId.Viseme, ref this.VoiceSynthesizer._visemeReached, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				this.VoiceSynthesizer.RemoveEvent<VisemeReachedEventArgs>(TtsEventId.Viseme, ref this.VoiceSynthesizer._visemeReached, value);
			}
		}
		public event EventHandler<StateChangedEventArgs> StateChanged
		{
			[MethodImpl(MethodImplOptions.Synchronized)]
			add
			{
				Helpers.ThrowIfNull(value, "value");
				VoiceSynthesis voiceSynthesizer = this.VoiceSynthesizer;
				voiceSynthesizer._stateChanged = (EventHandler<StateChangedEventArgs>)Delegate.Combine(voiceSynthesizer._stateChanged, value);
			}
			[MethodImpl(MethodImplOptions.Synchronized)]
			remove
			{
				Helpers.ThrowIfNull(value, "value");
				VoiceSynthesis voiceSynthesizer = this.VoiceSynthesizer;
				voiceSynthesizer._stateChanged = (EventHandler<StateChangedEventArgs>)Delegate.Remove(voiceSynthesizer._stateChanged, value);
			}
		}
		public SynthesizerState State
		{
			get
			{
				return this.VoiceSynthesizer.State;
			}
		}
		public int Rate
		{
			get
			{
				return this.VoiceSynthesizer.Rate;
			}
			set
			{
				if (value < -10 || value > 10)
				{
					throw new ArgumentOutOfRangeException("value", SR.Get(SRID.RateOutOfRange, new object[0]));
				}
				this.VoiceSynthesizer.Rate = value;
			}
		}
		public int Volume
		{
			get
			{
				return this.VoiceSynthesizer.Volume;
			}
			set
			{
				if (value < 0 || value > 100)
				{
					throw new ArgumentOutOfRangeException("value", SR.Get(SRID.ResourceUsageOutOfRange, new object[0]));
				}
				this.VoiceSynthesizer.Volume = value;
			}
		}
		public VoiceInfo Voice
		{
			get
			{
				return this.VoiceSynthesizer.CurrentVoice(true).VoiceInfo;
			}
		}
		private void SetOutputStream(Stream stream, SpeechAudioFormatInfo formatInfo, bool headerInfo, bool closeStreamOnExit)
		{
			this.SetOutputToNull();
			this._outputStream = stream;
			this._closeStreamOnExit = closeStreamOnExit;
			this.VoiceSynthesizer.SetOutput(stream, formatInfo, headerInfo);
		}
		private void Dispose(bool disposing)
		{
			if (!this._isDisposed && disposing && this._voiceSynthesis != null)
			{
				this._isDisposed = true;
				this.SpeakAsyncCancelAll();
				if (this._outputStream != null)
				{
					if (this._closeStreamOnExit)
					{
						this._outputStream.Close();
					}
					else
					{
						this._outputStream.Flush();
					}
					this._outputStream = null;
				}
			}
			if (this._voiceSynthesis != null)
			{
				this._voiceSynthesis.Dispose();
				this._voiceSynthesis = null;
			}
			this._isDisposed = true;
		}
		private VoiceSynthesis VoiceSynthesizer
		{
			get
			{
				if (this._voiceSynthesis == null && this._isDisposed)
				{
					throw new ObjectDisposedException("SpeechSynthesizer");
				}
				if (this._voiceSynthesis == null)
				{
					WeakReference weakReference = new WeakReference(this);
					this._voiceSynthesis = new VoiceSynthesis(weakReference);
				}
				return this._voiceSynthesis;
			}
		}
		private VoiceSynthesis _voiceSynthesis;
		private bool _isDisposed;
		private bool paused;
		private Stream _outputStream;
		private bool _closeStreamOnExit;
	}
}

VoiceInfo.cs

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Speech.AudioFormat;
using System.Speech.Internal;
using System.Speech.Internal.ObjectTokens;
using System.Speech.Internal.Synthesis;

namespace System.Speech.Synthesis
{
	[DebuggerDisplay("{(_name != null ? \"'\" + _name + \"' \" : \"\") +  (_culture != null ? \" '\" + _culture.ToString () + \"' \" : \"\") + (_gender != VoiceGender.NotSet ? \" '\" + _gender.ToString () + \"' \" : \"\") + (_age != VoiceAge.NotSet ? \" '\" + _age.ToString () + \"' \" : \"\") + (_variant > 0 ? \" \" + _variant.ToString () : \"\")}")]
	[Serializable]
	public class VoiceInfo
	{
		internal VoiceInfo(string name)
		{
			Helpers.ThrowIfEmptyOrNull(name, "name");
			this._name = name;
		}
		internal VoiceInfo(CultureInfo culture)
		{
			Helpers.ThrowIfNull(culture, "culture");
			if (culture.Equals(CultureInfo.InvariantCulture))
			{
				throw new ArgumentException(SR.Get(SRID.InvariantCultureInfo, new object[0]), "culture");
			}
			this._culture = culture;
		}
		internal VoiceInfo(ObjectToken token)
		{
			this._registryKeyPath = token._sKeyId;
			this._id = token.Name;
			this._description = token.Description;
			this._name = token.TokenName();
			SsmlParserHelpers.TryConvertAge(token.Age.ToLowerInvariant(), out this._age);
			SsmlParserHelpers.TryConvertGender(token.Gender.ToLowerInvariant(), out this._gender);
			string text;
			if (token.Attributes.TryGetString("Language", out text))
			{
				this._culture = SapiAttributeParser.GetCultureInfoFromLanguageString(text);
			}
			string text2;
			if (token.TryGetString("Assembly", out text2))
			{
				this._assemblyName = text2;
			}
			string text3;
			if (token.TryGetString("CLSID", out text3))
			{
				this._clsid = text3;
			}
			if (token.Attributes != null)
			{
				foreach (string text4 in token.Attributes.GetValueNames())
				{
					string text5;
					if (token.Attributes.TryGetString(text4, out text5))
					{
						this._attributes.InternalDictionary.Add(text4, text5);
					}
				}
			}
			string text6;
			if (token.Attributes != null && token.Attributes.TryGetString("AudioFormats", out text6))
			{
				this._audioFormats = new ReadOnlyCollection<SpeechAudioFormatInfo>(SapiAttributeParser.GetAudioFormatsFromString(text6));
				return;
			}
			this._audioFormats = new ReadOnlyCollection<SpeechAudioFormatInfo>(new List<SpeechAudioFormatInfo>());
		}
		internal VoiceInfo(VoiceGender gender)
		{
			this._gender = gender;
		}
		internal VoiceInfo(VoiceGender gender, VoiceAge age)
		{
			this._gender = gender;
			this._age = age;
		}
		internal VoiceInfo(VoiceGender gender, VoiceAge age, int voiceAlternate)
		{
			if (voiceAlternate < 0)
			{
				throw new ArgumentOutOfRangeException("voiceAlternate", SR.Get(SRID.PromptBuilderInvalidVariant, new object[0]));
			}
			this._gender = gender;
			this._age = age;
			this._variant = voiceAlternate + 1;
		}
		public override bool Equals(object obj)
		{
			VoiceInfo voiceInfo = obj as VoiceInfo;
			return voiceInfo != null && this._name == voiceInfo._name && (this._age == voiceInfo._age || this._age == VoiceAge.NotSet || voiceInfo._age == VoiceAge.NotSet) && (this._gender == voiceInfo._gender || this._gender == VoiceGender.NotSet || voiceInfo._gender == VoiceGender.NotSet) && (this._culture == null || voiceInfo._culture == null || this._culture.Equals(voiceInfo._culture));
		}
		public override int GetHashCode()
		{
			return this._name.GetHashCode();
		}
		public VoiceGender Gender
		{
			get
			{
				return this._gender;
			}
		}
		public VoiceAge Age
		{
			get
			{
				return this._age;
			}
		}
		public string Name
		{
			get
			{
				return this._name;
			}
		}
		public CultureInfo Culture
		{
			get
			{
				return this._culture;
			}
		}
		public string Id
		{
			get
			{
				return this._id;
			}
		}
		public string Description
		{
			get
			{
				if (this._description == null)
				{
					return string.Empty;
				}
				return this._description;
			}
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ReadOnlyCollection<SpeechAudioFormatInfo> SupportedAudioFormats
		{
			get
			{
				return this._audioFormats;
			}
		}
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public IDictionary<string, string> AdditionalInfo
		{
			get
			{
				return this._attributes;
			}
		}
		internal static bool ValidateGender(VoiceGender gender)
		{
			return gender == VoiceGender.Female || gender == VoiceGender.Male || gender == VoiceGender.Neutral || gender == VoiceGender.NotSet;
		}
		internal static bool ValidateAge(VoiceAge age)
		{
			return age == VoiceAge.Adult || age == VoiceAge.Child || age == VoiceAge.NotSet || age == VoiceAge.Senior || age == VoiceAge.Teen;
		}
		internal int Variant
		{
			get
			{
				return this._variant;
			}
		}
		internal string AssemblyName
		{
			get
			{
				return this._assemblyName;
			}
		}
		internal string Clsid
		{
			get
			{
				return this._clsid;
			}
		}
		internal string RegistryKeyPath
		{
			get
			{
				return this._registryKeyPath;
			}
		}
		private string _name;
		private CultureInfo _culture;
		private VoiceGender _gender;
		private VoiceAge _age;
		private int _variant = -1;
		[NonSerialized]
		private string _id;
		[NonSerialized]
		private string _registryKeyPath;
		[NonSerialized]
		private string _assemblyName;
		[NonSerialized]
		private string _clsid;
		[NonSerialized]
		private string _description;
		[NonSerialized]
		private ReadOnlyDictionary<string, string> _attributes = new ReadOnlyDictionary<string, string>();
		[NonSerialized]
		private ReadOnlyCollection<SpeechAudioFormatInfo> _audioFormats;
	}
}

SR.cs

using System;
using System.Globalization;
using System.Resources;

namespace System.Speech
{
	internal static class SR
	{
		internal static string Get(SRID id, params object[] args)
		{
			string text = SR._resourceManager.GetString(id.ToString());
			if (string.IsNullOrEmpty(text))
			{
				text = SR._resourceManager.GetString("Unavailable");
			}
			else if (args != null && args.Length > 0)
			{
				text = string.Format(CultureInfo.InvariantCulture, text, args);
			}
			return text;
		}
		private static ResourceManager _resourceManager = new ResourceManager("ExceptionStringTable", typeof(SR).Assembly);
	}
}

SRID.cs

using System;

namespace System.Speech
{
	internal enum SRID
	{
		NullParamIllegal,
		ArrayOfNullIllegal,
		ParamsEntryNullIllegal,
		Unavailable,
		UnexpectedError,
		CollectionReadOnly,
		StringCanNotBeEmpty,
		EnumInvalid,
		NotSupportedWithThisVersionOfSAPI,
		NotSupportedWithThisVersionOfSAPI2,
		NotSupportedWithThisVersionOfSAPIBaseUri,
		NotSupportedWithThisVersionOfSAPITagFormat,
		NotSupportedWithThisVersionOfSAPICompareOption,
		MustBeGreaterThanZero,
		InvalidXml,
		OperationAborted,
		InvariantCultureInfo,
		DuplicatedEntry,
		StreamMustBeReadable,
		StreamMustBeWriteable,
		StreamMustBeSeekable,
		StreamEndedUnexpectedly,
		CannotReadFromDirectory,
		UnknownMimeFormat,
		CannotLoadResourceFromManifest,
		TokenInUse,
		TokenDeleted,
		TokenUninitialized,
		InvalidTokenId,
		NotFound,
		NoBackSlash,
		InvalidRegistryEntry,
		TokenCannotCreateInstance,
		InvalidXmlFormat,
		IncorrectAttributeValue,
		MissingRequiredAttribute,
		InvalidRuleRefSelf,
		InvalidDynamicExport,
		InvalidToken,
		MetaNameHTTPEquiv,
		EmptyRule,
		InvalidTokenString,
		InvalidQuotedString,
		ExportDynamicRule,
		EmptyDisplayString,
		EmptyPronunciationString,
		InvalidPhoneme,
		MuliplePronunciationString,
		MultipleDisplayString,
		RuleRedefinition,
		EmptyOneOf,
		InvalidGrammarOrdering,
		MinMaxOutOfRange,
		InvalidExampleOrdering,
		GrammarDefTwice,
		UnsupportedFormat,
		InvalidImport,
		DuplicatedRuleName,
		RootRuleAlreadyDefined,
		RuleNameIdConflict,
		RuleNotDynamic,
		StateWithNoArcs,
		NoTerminatingRulePath,
		RuleRefNoUri,
		UnavailableProperty,
		MinGreaterThanMax,
		ReqConfidenceNotSupported,
		SapiPropertiesAndSemantics,
		InvalidAttributeDefinedTwice,
		GrammarCompilerError,
		RuleScriptNotFound,
		DynamicRuleNotFound,
		RuleScriptInvalidParameters,
		RuleScriptInvalidReturnType,
		NoClassname,
		EmbeddedClassLibraryFailed,
		CannotFindClass,
		StrongTypedGrammarNotAGrammar,
		NoScriptsForRules,
		ClassNotPublic,
		MethodNotPublic,
		IncompatibleLanguageProperties,
		IncompatibleNamespaceProperties,
		IncompatibleDebugProperties,
		CannotLoadDotNetSemanticCode,
		InvalidSemanticProcessingType,
		InvalidScriptDefinition,
		InvalidMethodName,
		ConstructorNotAllowed,
		OverloadNotAllowed,
		OnInitOnPublicRule,
		ArgumentMismatch,
		CantGetPropertyFromSerializedInfo,
		CantFindAConstructor,
		TooManyArcs,
		TooManyRulesWithSemanticsGlobals,
		MaxTransitionsCount,
		UnknownElement,
		CircularRuleRef,
		RuleDefinedMultipleTimes,
		RuleDefinedMultipleTimes2,
		RuleNotDefined,
		RootNotDefined,
		InvalidLanguage,
		InvalidRuleId,
		InvalidRepeatProbability,
		InvalidConfidence,
		InvalidMinRepeat,
		InvalidMaxRepeat,
		InvalidWeight,
		InvalidName,
		InvalidValueType,
		TagFormatNotSet,
		NoName,
		NoName1,
		InvalidSpecialRuleRef,
		InvalidRuleRef,
		InvalidNotEmptyElement,
		InvalidEmptyElement,
		InvalidEmptyRule,
		UndefRuleRef,
		UnsupportedLanguage,
		UnsupportedPhoneticAlphabet,
		UnsupportedLexicon,
		InvalidScriptAttribute,
		NoLanguageSet,
		MethodAttributeDefinedMultipeTimes,
		RuleAttributeDefinedMultipeTimes,
		InvalidAssemblyReferenceAttribute,
		InvalidImportNamespaceAttribute,
		NoUriForSpecialRuleRef,
		NoAliasForSpecialRuleRef,
		NoSmlData,
		InvalidNameValueProperty,
		InvalidTagInAnEmptyItem,
		InvalidSrgs,
		InvalidSrgsNamespace,
		Line,
		Position,
		InvalidVersion,
		InvalidTagFormat,
		MissingTagFormat,
		InvalidGrammarMode,
		InvalidGrammarAttribute,
		InvalidRuleAttribute,
		InvalidRulerefAttribute,
		InvalidOneOfAttribute,
		InvalidItemAttribute,
		InvalidTokenAttribute,
		InvalidItemRepeatAttribute,
		InvalidReqConfAttribute,
		InvalidTagAttribute,
		InvalidLexiconAttribute,
		InvalidMetaAttribute,
		InvalidItemAttribute2,
		InvalidElement,
		InvalidRuleScope,
		InvalidDynamicSetting,
		InvalidSubsetAttribute,
		InvalidVoiceElementInPromptOutput,
		NoRuleId,
		PromptBuilderInvalideState,
		PromptBuilderStateEnded,
		PromptBuilderStateSentence,
		PromptBuilderStateParagraph,
		PromptBuilderStateVoice,
		PromptBuilderStateStyle,
		PromptBuilderAgeOutOfRange,
		PromptBuilderMismatchStyle,
		PromptBuilderMismatchVoice,
		PromptBuilderMismatchParagraph,
		PromptBuilderMismatchSentence,
		PromptBuilderNestedParagraph,
		PromptBuilderNestedSentence,
		PromptBuilderInvalidAttribute,
		PromptBuilderInvalidElement,
		PromptBuilderInvalidVariant,
		PromptBuilderDatabaseName,
		PromptAsyncOperationCancelled,
		SynthesizerPauseResumeMismatched,
		SynthesizerInvalidMediaType,
		SynthesizerUnknownMediaType,
		SynthesizerSpeakError,
		SynthesizerInvalidWaveFile,
		SynthesizerPromptInUse,
		SynthesizerUnknownPriority,
		SynthesizerUnknownEvent,
		SynthesizerVoiceFailed,
		SynthesizerSetVoiceNoMatch,
		SynthesizerNoCulture,
		SynthesizerSyncSpeakWhilePaused,
		SynthesizerSyncSetOutputWhilePaused,
		SynthesizerNoCulture2,
		SynthesizerNoSpeak,
		SynthesizerSetOutputSpeaking,
		InvalidSpeakAttribute,
		UnsupportedAlphabet,
		GrammarInvalidWeight,
		GrammarInvalidPriority,
		DictationInvalidTopic,
		DictationTopicNotFound,
		RecognizerGrammarNotFound,
		RecognizerRuleNotFound,
		RecognizerInvalidBinaryGrammar,
		RecognizerRuleNotFoundStream,
		RecognizerNoRootRuleToActivate,
		RecognizerNoRootRuleToActivate1,
		RecognizerRuleActivationFailed,
		RecognizerAlreadyRecognizing,
		RecognizerHasNoGrammar,
		NegativeTimesNotSupported,
		AudioDeviceFormatError,
		AudioDeviceError,
		AudioDeviceInternalError,
		RecognizerNotFound,
		RecognizerNotEnabled,
		RecognitionNotSupported,
		RecognitionNotSupportedOn64bit,
		GrammarAlreadyLoaded,
		RecognizerNoInputSource,
		GrammarNotLoaded,
		GrammarLoadingInProgress,
		GrammarLoadFailed,
		GrammarWrongRecognizer,
		NotSupportedOnDictationGrammars,
		LocalFilesOnly,
		NotValidAudioFile,
		NotValidAudioStream,
		FileNotFound,
		CannotSetPriorityOnDictation,
		RecognizerUpdateTableTooLarge,
		MaxAlternatesInvalid,
		RecognizerSettingGetError,
		RecognizerSettingUpdateError,
		RecognizerSettingNotSupported,
		ResourceUsageOutOfRange,
		RateOutOfRange,
		EndSilenceOutOfRange,
		RejectionThresholdOutOfRange,
		ReferencedGrammarNotFound,
		SapiErrorRuleNotFound2,
		NoAudioAvailable,
		ResultNotGrammarAvailable,
		ResultInvalidFormat,
		UnhandledVariant,
		DupSemanticKey,
		DupSemanticValue,
		CannotUseCustomFormat,
		NoPromptEngine,
		NoPromptEngineInterface,
		SeekNotSupported,
		ExtraDataNotPresent,
		BitsPerSampleInvalid,
		DataBlockSizeInvalid,
		NotWholeNumberBlocks,
		BlockSignatureInvalid,
		NumberOfSamplesInvalid,
		SapiErrorUninitialized,
		SapiErrorAlreadyInitialized,
		SapiErrorNotSupportedFormat,
		SapiErrorInvalidFlags,
		SapiErrorEndOfStream,
		SapiErrorDeviceBusy,
		SapiErrorDeviceNotSupported,
		SapiErrorDeviceNotEnabled,
		SapiErrorNoDriver,
		SapiErrorFileMustBeUnicode,
		InsufficientData,
		SapiErrorInvalidPhraseID,
		SapiErrorBufferTooSmall,
		SapiErrorFormatNotSpecified,
		SapiErrorAudioStopped0,
		AudioPaused,
		SapiErrorRuleNotFound,
		SapiErrorTTSEngineException,
		SapiErrorTTSNLPException,
		SapiErrorEngineBUSY,
		AudioConversionEnabled,
		NoHypothesisAvailable,
		SapiErrorCantCreate,
		AlreadyInLex,
		SapiErrorNotInLex,
		LexNothingToSync,
		SapiErrorLexVeryOutOfSync,
		SapiErrorUndefinedForwardRuleRef,
		SapiErrorEmptyRule,
		SapiErrorGrammarCompilerInternalError,
		SapiErrorRuleNotDynamic,
		SapiErrorDuplicateRuleName,
		SapiErrorDuplicateResourceName,
		SapiErrorTooManyGrammars,
		SapiErrorCircularReference,
		SapiErrorInvalidImport,
		SapiErrorInvalidWAVFile,
		RequestPending,
		SapiErrorAllWordsOptional,
		SapiErrorInstanceChangeInvalid,
		SapiErrorRuleNameIdConflict,
		SapiErrorNoRules,
		SapiErrorCircularRuleRef,
		NoParseFound,
		SapiErrorInvalidHandle,
		SapiErrorRemoteCallTimedout,
		SapiErrorAudioBufferOverflow,
		SapiErrorNoAudioData,
		SapiErrorDeadAlternate,
		SapiErrorHighLowConfidence,
		SapiErrorInvalidFormatString,
		SPNotSupportedOnStreamInput,
		SapiErrorAppLexReadOnly,
		SapiErrorNoTerminatingRulePath,
		WordExistsWithoutPronunciation,
		SapiErrorStreamClosed,
		SapiErrorNoMoreItems,
		SapiErrorNotFound,
		SapiErrorInvalidAudioState,
		SapiErrorGenericMMSYS,
		SapiErrorMarshalerException,
		SapiErrorNotDynamicGrammar,
		SapiErrorAmbiguousProperty,
		SapiErrorInvalidRegistrykey,
		SapiErrorInvalidTokenId,
		SapiErrorXMLBadSyntax,
		SapiErrorXMLResourceNotFound,
		SapiErrorTokenInUse,
		SapiErrorTokenDeleted,
		SapiErrorMultilingualNotSupported,
		SapiErrorExportDynamicRule,
		SapiErrorSTGF,
		SapiErrorWordFormat,
		SapiErrorStreamNotActive,
		SapiErrorEngineResponseInvalid,
		SapiErrorSREngineException,
		SapiErrorStreamPosInvalid,
		SapiErrorRecognizerInactive,
		SapiErrorRemoteCallOnWrongThread,
		SapiErrorRemoteProcessTerminated,
		SapiErrorRemoteProcessAlreadyRunning,
		SapiErrorLangIdMismatch,
		SapiErrorPartialParseFound,
		SapiErrorNotTopLevelRule,
		SapiErrorNoRuleActive,
		SapiErrorLexRequiresCookie,
		SapiErrorStreamUninitialized,
		SapiErrorUnused0,
		SapiErrorNotSupportedLang,
		SapiErrorVoicePaused,
		SapiErrorAudioBufferUnderflow,
		SapiErrorAudioStoppedUnexpectedly,
		SapiErrorNoWordPronunciation,
		SapiErrorAlternatesWouldBeInconsistent,
		SapiErrorNotSupportedForSharedRecognizer,
		SapiErrorTimeOut,
		SapiErrorReenterSynchronize,
		SapiErrorStateWithNoArcs,
		SapiErrorNotActiveSession,
		SapiErrorAlreadyDeleted,
		SapiErrorAudioStopped,
		SapiErrorRecoXMLGenerationFail,
		SapiErrorSMLGenerationFail,
		SapiErrorNotPromptVoice,
		SapiErrorRootRuleAlreadyDefined,
		SapiErrorUnused1,
		SapiErrorUnused2,
		SapiErrorUnused3,
		SapiErrorUnused4,
		SapiErrorUnused5,
		SapiErrorUnused6,
		SapiErrorScriptDisallowed,
		SapiErrorRemoteCallTimedOutStart,
		SapiErrorRemoteCallTimedOutConnect,
		SapiErrorSecMgrChangeNotAllowed,
		SapiErrorCompleteButExtendable,
		SapiErrorFailedToDeleteFile,
		SapiErrorSharedEngineDisabled,
		SapiErrorRecognizerNotFound,
		SapiErrorAudioNotFound,
		SapiErrorNoVowel,
		SapiErrorNotSupportedPhoneme,
		SapiErrorNoRulesToActivate,
		SapiErrorNoWordEntryNotification,
		SapiErrorWordNeedsNormalization,
		SapiErrorCannotNormalize,
		LimitReached,
		NotSupported,
		SapiErrorTopicNotADaptable,
		SapiErrorPhonemeConversion,
		SapiErrorNotSupportedForInprocRecognizer
	}
}
