ApiConst.cs


using System;

namespace Aladdin.HASP
{
	internal static class ApiConst
	{
		public const int HASP_FEATURETYPE_MASK = -65536;

		public const int HASP_PROGNUM_FEATURETYPE = -65536;

		public const int HASP_PROGNUM_MASK = 255;

		public const int HASP_PROGNUM_OPT_MASK = 65280;

		public const int HASP_PROGNUM_OPT_NO_LOCAL = 32768;

		public const int HASP_PROGNUM_OPT_NO_REMOTE = 16384;

		public const int HASP_PROGNUM_OPT_PROCESS = 8192;

		public const int HASP_PROGNUM_OPT_CLASSIC = 4096;

		public const int HASP_PROGNUM_OPT_TS = 2048;

		public const int HASP_DEFAULT_FID = 0;

		public const int HASP_PROGNUM_DEFAULT_FID = -65536;

		public const int HASP_FILEID_MAIN = 65520;

		public const int HASP_FILEID_LICENSE = 65522;

		public const int HASP_FILEID_RW = 65524;

		public const int HASP_FILEID_RO = 65525;

		public const string HASP_UPDATEINFO = "<haspformat format=\"updateinfo\"/>";

		public const string HASP_FASTUPDATEINFO = "<haspformat format=\"fastupdateinfo\"/>";

		public const string HASP_SESSIONINFO = "<haspformat format=\"sessioninfo\"/>";

		public const string HASP_KEYINFO = "<haspformat format=\"keyinfo\"/>";

		public const string HASP_RECIPIENT = "<haspformat root=\"location\">  <license_manager>    <attribute name=\"id\" />    <attribute name=\"time\" />    <element name=\"hostname\" />    <element name=\"version\" />    <element name=\"host_fingerprint\" />  </license_manager></haspformat>";

		public const string HASP_FINGERPRINT = "<haspformat format=\"host_fingerprint\"/>";

		public const int HASP_INVALID_HANDLE_VALUE = 0;

		public const int HASP_MIN_BLOCK_SIZE = 16;

		public const int HASP_MIN_BLOCK_SIZE_LEGACY = 8;

		public enum hasp_error_codes
		{
			HASP_STATUS_OK,
			HASP_MEM_RANGE,
			HASP_INV_PROGNUM_OPT,
			HASP_INSUF_MEM,
			HASP_TMOF,
			HASP_ACCESS_DENIED,
			HASP_INCOMPAT_FEATURE,
			HASP_CONTAINER_NOT_FOUND,
			HASP_HASP_NOT_FOUND = 7,
			HASP_TOO_SHORT,
			HASP_INV_HND,
			HASP_INV_FILEID,
			HASP_OLD_DRIVER,
			HASP_NO_TIME,
			HASP_SYS_ERR,
			HASP_NO_DRIVER,
			HASP_INV_FORMAT,
			HASP_REQ_NOT_SUPP,
			HASP_INV_UPDATE_OBJ,
			HASP_KEYID_NOT_FOUND,
			HASP_INV_UPDATE_DATA,
			HASP_INV_UPDATE_NOTSUPP,
			HASP_INV_UPDATE_CNTR,
			HASP_INV_VCODE,
			HASP_ENC_NOT_SUPP,
			HASP_INV_TIME,
			HASP_NO_BATTERY_POWER,
			HASP_NO_ACK_SPACE,
			HASP_TS_DETECTED,
			HASP_FEATURE_TYPE_NOT_IMPL,
			HASP_UNKNOWN_ALG,
			HASP_INV_SIG,
			HASP_FEATURE_NOT_FOUND,
			HASP_NO_LOG,
			HASP_LOCAL_COMM_ERR,
			HASP_UNKNOWN_VCODE,
			HASP_INV_SPEC,
			HASP_INV_SCOPE,
			HASP_TOO_MANY_KEYS,
			HASP_TOO_MANY_USERS,
			HASP_BROKEN_SESSION,
			HASP_REMOTE_COMM_ERR,
			HASP_FEATURE_EXPIRED,
			HASP_OLD_LM,
			HASP_DEVICE_ERR,
			HASP_UPDATE_BLOCKED,
			HASP_TIME_ERR,
			HASP_SCHAN_ERR,
			HASP_STORAGE_CORRUPT,
			HASP_NO_VLIB,
			HASP_INV_VLIB,
			HASP_SCOPE_RESULTS_EMPTY,
			HASP_VM_DETECTED,
			HASP_HARDWARE_MODIFIED,
			HASP_USER_DENIED,
			HASP_UPDATE_TOO_OLD,
			HASP_UPDATE_TOO_NEW,
			HASP_OLD_VLIB,
			HASP_UPLOAD_ERROR,
			HASP_INV_RECIPIENT,
			HASP_INV_DETACH_ACTION,
			HASP_TOO_MANY_PRODUCTS,
			HASP_INV_PRODUCT,
			HASP_UNKNOWN_RECIPIENT,
			HASP_INV_DURATION,
			HASP_CLONE_DETECTED,
			HASP_UPDATE_ALREADY_ADDED,
			HASP_HASP_INACTIVE,
			HASP_NO_DETACHABLE_FEATURE,
			HASP_NO_DEATCHABLE_FEATURE = 67,
			HASP_TOO_MANY_HOSTS,
			HASP_REHOST_NOT_ALLOWED,
			HASP_LICENSE_REHOSTED,
			HASP_REHOST_ALREADY_APPLIED,
			HASP_CANNOT_READ_FILE,
			HASP_EXTENSION_NOT_ALLOWED,
			HASP_DETACH_DISABLED,
			HASP_REHOST_DISABLED,
			HASP_DETACHED_LICENSE_FOUND,
			HASP_RECIPIENT_OLD_LM,
			HASP_SECURE_STORE_ID_MISMATCH,
			HASP_DUPLICATE_HOSTNAME,
			HASP_MISSING_LM,
			HASP_NO_API_DYLIB = 400,
			HASP_INV_API_DYLIB,
			HASP_INVALID_OBJECT = 500,
			HASP_INVALID_PARAMETER,
			HASP_ALREADY_LOGGED_IN,
			HASP_ALREADY_LOGGED_OUT,
			HASP_OPERATION_FAILED = 525,
			HASP_NO_EXTBLOCK = 600,
			HASP_INV_PORT_TYPE = 650,
			HASP_INV_PORT,
			HASP_NET_DLL_BROKEN,
			HASP_NOT_IMPL = 698,
			HASP_INT_ERR,
			HASP_FIRST_HELPER = 2001,
			HASP_FIRST_HASP_ACT = 3001,
			HASP_NEXT_FREE_VALUES = 5001
		}
	}
}
---------------------------------------------------------

DllBrokenException.cs

using System;
using System.Runtime.Serialization;

namespace Aladdin.HASP
{
	[Serializable]
	public class DllBrokenException : Exception
	{
		public DllBrokenException()
		{
		}

		public DllBrokenException(string message)
			: base(message)
		{
		}

		public DllBrokenException(string message, Exception ex)
			: base(message, ex)
		{
		}

		protected DllBrokenException(SerializationInfo serInfo, StreamingContext streamContext)
			: base(serInfo, streamContext)
		{
		}
	}
}


-------------------------------------------------------

FeatureOptions.cs

using System;

namespace Aladdin.HASP
{
	[Flags]
	[Serializable]
	public enum FeatureOptions
	{
		Default = 0,
		NotLocal = 32768,
		NotRemote = 16384,
		Process = 8192,
		Classic = 4096,
		IgnoreTS = 2048
	}
}

-------------------------------------------------------

FeatureType.cs

using System;

namespace Aladdin.HASP
{
	public enum FeatureType
	{
		Default,
		ProgNumDefault = -65536
	}
}

-------------------------------------------------------

Hasp.cs

using System;
using Aladdin.HASP.Internal;
using HEDS;

namespace Aladdin.HASP
{
	public class Hasp : ICloneable, IDisposable, IComparable<Hasp>
	{
		public Hasp()
		{
			this.SetKey(HaspFeature.Default);
			this.isFeatureSet = true;
		}

		public Hasp(HaspFeature feature)
		{
			this.SetKey(feature);
			this.isFeatureSet = true;
		}

		private void SetKey(HaspFeature feature)
		{
			this.key = new Hasp.HaspBase(feature);
		}

		public Hasp(Hasp other)
		{
			if (other == null)
			{
				this.SetKey(HaspFeature.Default);
			}
			else
			{
				this.key = other.key;
				this.key.RefCount++;
				this.isFeatureSet = other.isFeatureSet;
			}
		}

		~Hasp()
		{
			this.Dispose(false);
		}

		public HaspStatus Decrypt(byte[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Decrypt(char[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Decrypt(double[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Decrypt(short[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Decrypt(int[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Decrypt(long[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Decrypt(float[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Decrypt(ref string data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.decrypt(this.key.handle, ref data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(byte[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(char[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(double[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(short[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(int[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(long[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(float[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public HaspStatus Encrypt(ref string data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = this.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.encrypt(this.key.handle, ref data);
				}
			}
			return haspStatus;
		}

		public HaspFeature Feature
		{
			get
			{
				return this.key.feature;
			}
		}

		public HaspFile GetFile()
		{
			return this.GetFile(HaspFileId.Main);
		}

		public HaspFile GetFile(HaspFileId fileId)
		{
			return new HaspFile(fileId, this.IsValid() ? this : new Hasp());
		}

		public HaspFile GetFile(int fileId)
		{
			return new HaspFile(fileId, this.IsValid() ? this : new Hasp());
		}

		public static HaspStatus GetInfo(string query, string format, byte[] vendorCode, ref string info)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			HaspStatus haspStatus;
			if (query == null || format == null || vendorCode == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				info = "";
				HaspStatus haspStatus2 = Hasp.Hasp_Prologue();
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.get_info(query, format, vendorCode, ref info);
				}
			}
			return haspStatus;
		}

		public static HaspStatus GetInfo(string query, string format, string vendorCode, ref string info)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			HaspStatus haspStatus;
			if (query == null || format == null || vendorCode == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				info = "";
				HaspStatus haspStatus2 = Hasp.Hasp_Prologue();
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.get_info(query, format, vendorCode, ref info);
				}
			}
			return haspStatus;
		}

		public HaspLegacy Legacy
		{
			get
			{
				return new HaspLegacy(this.HasLegacy ? this : new Hasp());
			}
		}

		public HaspStatus GetRtc(ref DateTime rtc)
		{
			HaspStatus haspStatus = this.Hasp_Prologue(this.key);
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				long num = 0L;
				haspStatus = ApiDisp.get_rtc(this.key.handle, ref num);
				if (haspStatus != HaspStatus.StatusOk)
				{
					haspStatus2 = haspStatus;
				}
				else
				{
					DateTime dateTime = new DateTime(1970, 1, 1);
					rtc = new DateTime(num * 10L * 1000L * 1000L + dateTime.Ticks);
					haspStatus2 = haspStatus;
				}
			}
			return haspStatus2;
		}

		public HaspStatus GetSessionInfo(string format, ref string info)
		{
			HaspStatus haspStatus = this.Hasp_Prologue(this.key);
			info = "";
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.get_sessioninfo(this.key.handle, format, ref info);
			}
			return haspStatus2;
		}

		public static HaspStatus GetApiVersion(byte[] vendorCode, ref HaspVersion version)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			version = default(HaspVersion);
			HaspStatus haspStatus = Hasp.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus = ApiDisp.get_version(ref num, ref num2, ref num3, ref num4, vendorCode);
				if (haspStatus != HaspStatus.StatusOk)
				{
					haspStatus2 = haspStatus;
				}
				else
				{
					version = new HaspVersion(num, num2, num3, num4);
					haspStatus2 = HaspStatus.StatusOk;
				}
			}
			return haspStatus2;
		}

		public static HaspStatus GetApiVersion(string vendorCode, ref HaspVersion version)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			version = default(HaspVersion);
			HaspStatus haspStatus = Hasp.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus = ApiDisp.get_version(ref num, ref num2, ref num3, ref num4, vendorCode);
				if (haspStatus != HaspStatus.StatusOk)
				{
					haspStatus2 = haspStatus;
				}
				else
				{
					version = new HaspVersion(num, num2, num3, num4);
					haspStatus2 = HaspStatus.StatusOk;
				}
			}
			return haspStatus2;
		}

		public bool HasLegacy
		{
			get
			{
				return !this.isDisposed && this.key.feature.IsProgNum;
			}
		}

		public static string KeyInfo
		{
			get
			{
				return "<haspformat format=\"keyinfo\"/>";
			}
		}

		public HaspStatus Login(byte[] vendorCode)
		{
			HaspStatus haspStatus;
			if (this.isDisposed)
			{
				haspStatus = HaspStatus.InvalidObject;
			}
			else
			{
				try
				{
					Hasp.TestSignature();
				}
				catch (DllBrokenException)
				{
					return HaspStatus.HaspDotNetDllBroken;
				}
				if (this.key.IsLoggedIn)
				{
					haspStatus = HaspStatus.AlreadyLoggedIn;
				}
				else
				{
					HaspStatus haspStatus2 = ApiDisp.login(this.key.feature.Feature, vendorCode, ref this.key.handle);
					if (haspStatus2 != HaspStatus.StatusOk)
					{
						haspStatus = haspStatus2;
					}
					else
					{
						this.key.IsLoggedIn = true;
						haspStatus = HaspStatus.StatusOk;
					}
				}
			}
			return haspStatus;
		}

		public HaspStatus Login(string vendorCode)
		{
			HaspStatus haspStatus;
			if (this.isDisposed)
			{
				haspStatus = HaspStatus.InvalidObject;
			}
			else
			{
				try
				{
					Hasp.TestSignature();
				}
				catch (DllBrokenException)
				{
					return HaspStatus.HaspDotNetDllBroken;
				}
				if (this.key.IsLoggedIn)
				{
					haspStatus = HaspStatus.AlreadyLoggedIn;
				}
				else
				{
					HaspStatus haspStatus2 = ApiDisp.login(this.key.feature.Feature, vendorCode, ref this.key.handle);
					if (haspStatus2 != HaspStatus.StatusOk)
					{
						haspStatus = haspStatus2;
					}
					else
					{
						this.key.IsLoggedIn = true;
						haspStatus = HaspStatus.StatusOk;
					}
				}
			}
			return haspStatus;
		}

		public HaspStatus Login(byte[] vendorCode, string scope)
		{
			HaspStatus haspStatus;
			if (this.isDisposed)
			{
				haspStatus = HaspStatus.InvalidObject;
			}
			else
			{
				try
				{
					Hasp.TestSignature();
				}
				catch (DllBrokenException)
				{
					return HaspStatus.HaspDotNetDllBroken;
				}
				if (this.key.IsLoggedIn)
				{
					haspStatus = HaspStatus.AlreadyLoggedIn;
				}
				else if (vendorCode == null)
				{
					haspStatus = HaspStatus.InvalidParameter;
				}
				else
				{
					HaspStatus haspStatus2 = ApiDisp.login_scope(this.key.feature.Feature, scope, vendorCode, ref this.key.handle);
					if (haspStatus2 != HaspStatus.StatusOk)
					{
						haspStatus = haspStatus2;
					}
					else
					{
						this.key.IsLoggedIn = true;
						haspStatus = HaspStatus.StatusOk;
					}
				}
			}
			return haspStatus;
		}

		public HaspStatus Login(string vendorCode, string scope)
		{
			HaspStatus haspStatus;
			if (this.isDisposed)
			{
				haspStatus = HaspStatus.InvalidObject;
			}
			else
			{
				try
				{
					Hasp.TestSignature();
				}
				catch (DllBrokenException)
				{
					return HaspStatus.HaspDotNetDllBroken;
				}
				if (this.key.IsLoggedIn)
				{
					haspStatus = HaspStatus.AlreadyLoggedIn;
				}
				else if (vendorCode == null)
				{
					haspStatus = HaspStatus.InvalidParameter;
				}
				else
				{
					HaspStatus haspStatus2 = ApiDisp.login_scope(this.key.feature.Feature, scope, vendorCode, ref this.key.handle);
					if (haspStatus2 != HaspStatus.StatusOk)
					{
						haspStatus = haspStatus2;
					}
					else
					{
						this.key.IsLoggedIn = true;
						haspStatus = HaspStatus.StatusOk;
					}
				}
			}
			return haspStatus;
		}

		public HaspStatus Logout()
		{
			HaspStatus haspStatus;
			if (this.isDisposed)
			{
				haspStatus = HaspStatus.InvalidObject;
			}
			else if (!this.key.IsLoggedIn)
			{
				haspStatus = HaspStatus.AlreadyLoggedOut;
			}
			else
			{
				HaspStatus haspStatus2 = ApiDisp.logout(this.key.handle);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					this.key.IsLoggedIn = false;
					this.key.handle = 0;
					this.key.loggedOut = true;
					haspStatus = HaspStatus.StatusOk;
				}
			}
			return haspStatus;
		}

		public static string SessionInfo
		{
			get
			{
				return "<haspformat format=\"sessioninfo\"/>";
			}
		}

		public override string ToString()
		{
			return this.key.handle.ToString();
		}

		public static HaspStatus Update(string updateXml, ref string acknowledgeXml)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			acknowledgeXml = "";
			HaspStatus haspStatus = Hasp.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.update(updateXml, ref acknowledgeXml);
			}
			return haspStatus2;
		}

		[Obsolete("Starting from Sentinel LDK version 6.0, the \u0093Detach\u0094 method has been deprecated.SafeNet recommends that user should use the \u0093Transfer\u0094 method to perform the detach/cancel actions. This method has been retained for backward compatibility.")]
		public static HaspStatus Detach(string detach_action, string scope, string vendor_code, string recipient, ref string info)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			HaspStatus haspStatus = Hasp.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.detach(detach_action, scope, vendor_code, recipient, ref info);
			}
			return haspStatus2;
		}

		[Obsolete("Starting from Sentinel LDK version 6.0, the \u0093Detach\u0094 method has been deprecated.SafeNet recommends that user should use the \u0093Transfer\u0094 method to perform the detach/cancel actions. This method has been retained for backward compatibility.")]
		public static HaspStatus Detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			HaspStatus haspStatus = Hasp.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.detach(detach_action, scope, vendor_code, recipient, ref info);
			}
			return haspStatus2;
		}

		public static HaspStatus Transfer(string action, string scope, string vendor_code, string recipient, ref string info)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			HaspStatus haspStatus = Hasp.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.transfer(action, scope, vendor_code, recipient, ref info);
			}
			return haspStatus2;
		}

		public static HaspStatus Transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			try
			{
				Hasp.TestSignature();
			}
			catch (DllBrokenException)
			{
				return HaspStatus.HaspDotNetDllBroken;
			}
			HaspStatus haspStatus = Hasp.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.transfer(action, scope, vendor_code, recipient, ref info);
			}
			return haspStatus2;
		}

		public static string UpdateInfo
		{
			get
			{
				return "<haspformat format=\"updateinfo\"/>";
			}
		}

		public static string Recipient
		{
			get
			{
				return "<haspformat root=\"location\">  <license_manager>    <attribute name=\"id\" />    <attribute name=\"time\" />    <element name=\"hostname\" />    <element name=\"version\" />    <element name=\"host_fingerprint\" />  </license_manager></haspformat>";
			}
		}

		public static string Fingerprint
		{
			get
			{
				return "<haspformat format=\"host_fingerprint\"/>";
			}
		}

		internal HaspStatus Hasp_Prologue(Hasp.HaspBase key)
		{
			HaspStatus haspStatus;
			if (this.isDisposed)
			{
				haspStatus = HaspStatus.InvalidObject;
			}
			else if (key.IsLoggedIn)
			{
				haspStatus = HaspStatus.StatusOk;
			}
			else if (key.loggedOut)
			{
				haspStatus = HaspStatus.AlreadyLoggedOut;
			}
			else
			{
				haspStatus = HaspStatus.InvalidHandle;
			}
			return haspStatus;
		}

		internal static HaspStatus Hasp_Prologue()
		{
			return HaspStatus.StatusOk;
		}

		public bool IsValid()
		{
			return this.isFeatureSet && !this.isDisposed;
		}

		public bool IsLoggedIn()
		{
			return this.key != null && this.IsValid() && this.key.IsLoggedIn;
		}

		public object Clone()
		{
			return new Hasp(this);
		}

		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!this.isDisposed)
			{
				if (this.key != null)
				{
					this.key.RefCount--;
					if (this.key.RefCount == 0 && this.key.IsLoggedIn)
					{
						this.Logout();
					}
					this.key = null;
				}
				this.isDisposed = true;
			}
		}

		public Hasp Assign(Hasp other)
		{
			Hasp hasp;
			if (this.isDisposed)
			{
				hasp = null;
			}
			else
			{
				this.key.RefCount--;
				if (this.key.RefCount == 0 && this.key.IsLoggedIn)
				{
					this.Logout();
				}
				this.key = null;
				if (other == null)
				{
					hasp = null;
				}
				else
				{
					this.key = other.key;
					this.key.RefCount++;
					this.isFeatureSet = other.isFeatureSet;
					hasp = this;
				}
			}
			return hasp;
		}

		public int CompareTo(Hasp other)
		{
			int num;
			if (other == null)
			{
				num = 1;
			}
			else
			{
				int num2 = this.key.feature.CompareTo(other.key.feature);
				if (num2 != 0)
				{
					num = num2;
				}
				else
				{
					num = this.key.handle.CompareTo(other.key.handle);
				}
			}
			return num;
		}

		public override bool Equals(object obj)
		{
			return this == obj;
		}

		public static bool operator ==(Hasp left, object right)
		{
			bool flag;
			if (left == null && right == null)
			{
				flag = true;
			}
			else if (left == null || right == null)
			{
				flag = false;
			}
			else
			{
				Hasp hasp = right as Hasp;
				if (hasp == null)
				{
					HaspFile haspFile = right as HaspFile;
					flag = !(haspFile == null) && haspFile == left;
				}
				else
				{
					flag = left.CompareTo(hasp) == 0;
				}
			}
			return flag;
		}

		public static bool operator !=(Hasp left, object right)
		{
			return !(left == right);
		}

		public override int GetHashCode()
		{
			return this.key.handle;
		}

		private static void TestSignature()
		{
			if (ApiDisp.IsRunningOnMono() <= 0)
			{
				if (!Hasp.tested)
				{
					HedsCrypt hedsCrypt = new HedsCrypt();
					hedsCrypt.Init("<RSAKeyValue>  <Modulus>tPkMcaY3CO1MlQp+hShdu1MWrOkisuRmubklR4cxQt9JM1i6wPooMkeRXu62u/JyUk           IEe4Y45JFCZL5/dOBirs7dyMBM+a0umaANRQE1wvr+k7uQyXuTo8dNwFlZR4WShBD2           O/gv/QMfgYuJ0nm5P0IFGjJrx+K6oiMrRLBcg5E=  </Modulus><Exponent>AQAB</Exponent></RSAKeyValue>");
					HedsFile hedsFile = new HedsFile();
					hedsFile.hedsCrypt = hedsCrypt;
					int size = IntPtr.Size;
					string text;
					if (size != 4)
					{
						if (size != 8)
						{
							throw new PlatformNotSupportedException();
						}
						text = "apidsp_windows_x64.dll";
					}
					else
					{
						text = "apidsp_windows.dll";
					}
					hedsFile.strFileName = text;
					HedsFile.heds_status heds_status = hedsFile.CheckSignature(hedsFile.FindFile(Hasp.libPath), 1);
					if (heds_status != HedsFile.heds_status.HEDS_STATUS_OK)
					{
						throw new DllBrokenException(heds_status.ToString());
					}
					Hasp.tested = true;
				}
			}
		}

		public HaspStatus SetLibPath(string path)
		{
			HaspStatus haspStatus;
			if (this.isDisposed)
			{
				haspStatus = HaspStatus.InvalidObject;
			}
			else
			{
				HaspStatus haspStatus2;
				if (path != null)
				{
					string text = path;
					if (!text.EndsWith("\\"))
					{
						text += "\\";
					}
					haspStatus2 = ApiDisp.set_lib_path(text);
				}
				else
				{
					haspStatus2 = ApiDisp.set_lib_path(path);
				}
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					if (path != null)
					{
						Hasp.libPath = path;
					}
					try
					{
						Hasp.TestSignature();
					}
					catch (DllBrokenException)
					{
						return HaspStatus.HaspDotNetDllBroken;
					}
					haspStatus = HaspStatus.StatusOk;
				}
			}
			return haspStatus;
		}

		internal Hasp.HaspBase key;

		private bool isFeatureSet = false;

		private bool isDisposed = false;

		private static string libPath;

		private static bool tested;

		internal class HaspBase
		{
			public HaspBase(HaspFeature feature)
			{
				this.feature = feature;
			}

			public bool IsLoggedIn
			{
				get
				{
					return this.loggedIn;
				}
				set
				{
					this.loggedIn = value;
				}
			}

			public int RefCount
			{
				get
				{
					return this.refCount;
				}
				set
				{
					this.refCount = value;
				}
			}

			public int handle = 0;

			public bool loggedOut = false;

			public HaspFeature feature;

			private bool loggedIn = false;

			private int refCount = 1;
		}
	}
}
----------------------------------------------------

HaspFeature.cs

using System;

namespace Aladdin.HASP
{
	[Serializable]
	public struct HaspFeature : IComparable<HaspFeature>
	{
		public HaspFeature(int feature)
		{
			this.feature = feature;
		}

		public HaspFeature(FeatureType feature)
		{
			this.feature = (int)feature;
		}

		public static HaspFeature Default
		{
			get
			{
				return new HaspFeature(FeatureType.Default);
			}
		}

		public static HaspFeature ProgNumDefault
		{
			get
			{
				return new HaspFeature(FeatureType.ProgNumDefault);
			}
		}

		public int Feature
		{
			get
			{
				return this.feature;
			}
		}

		public int FeatureId
		{
			get
			{
				return this.IsProgNum ? (this.feature & -65281) : this.feature;
			}
		}

		public bool IsDefault
		{
			get
			{
				return this.FeatureId == (this.IsProgNum ? (-65536) : 0);
			}
		}

		public bool IsProgNum
		{
			get
			{
				return (this.feature & -65536) == -65536;
			}
		}

		public FeatureOptions Options
		{
			get
			{
				return (FeatureOptions)(this.IsProgNum ? (this.feature & 65280) : 0);
			}
		}

		public int CompareTo(HaspFeature other)
		{
			return this.feature.CompareTo(other.feature);
		}

		public static bool operator ==(HaspFeature left, HaspFeature right)
		{
			return left.CompareTo(right) == 0;
		}

		public static bool operator !=(HaspFeature left, HaspFeature right)
		{
			return !(left == right);
		}

		public override bool Equals(object obj)
		{
			return this == (HaspFeature)obj;
		}

		public override int GetHashCode()
		{
			return this.feature;
		}

		public static HaspFeature FromFeature(int feature)
		{
			return new HaspFeature(feature & 1048575);
		}

		public static HaspFeature FromProgNum(int number)
		{
			number &= 255;
			return new HaspFeature(number | -65536);
		}

		public bool HasOption(FeatureOptions option)
		{
			bool flag;
			if (this.IsProgNum)
			{
				flag = option == FeatureOptions.Default;
			}
			else
			{
				int num = this.feature & 65280;
				if (option == FeatureOptions.Default)
				{
					flag = num == 0;
				}
				else
				{
					flag = option == FeatureOptions.Default;
				}
			}
			return flag;
		}

		public bool SetOptions(FeatureOptions add, FeatureOptions remove)
		{
			bool flag;
			if (!this.IsProgNum)
			{
				flag = false;
			}
			else
			{
				if ((add & FeatureOptions.NotRemote) == FeatureOptions.NotRemote)
				{
					add &= ~FeatureOptions.NotLocal;
					remove |= FeatureOptions.NotLocal;
				}
				if ((add & FeatureOptions.NotLocal) == FeatureOptions.NotLocal)
				{
					add &= ~FeatureOptions.NotRemote;
					remove |= FeatureOptions.NotRemote;
				}
				this.feature |= (int)(add & (FeatureOptions)65280);
				this.feature &= (int)(~(int)(remove & (FeatureOptions)65280));
				flag = true;
			}
			return flag;
		}

		public override string ToString()
		{
			return this.feature.ToString();
		}

		private int feature;
	}
}

--------------------------------------------------------

HaspFile.cs

using System;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using Aladdin.HASP.Internal;

namespace Aladdin.HASP
{
	public sealed class HaspFile : ICloneable, IDisposable, IComparable<HaspFile>
	{
		internal HaspFile()
		{
			this.init();
		}

		public HaspFile(HaspFileId fileId, Hasp other)
		{
			this.parent = other;
			this.init((int)fileId);
		}

		public HaspFile(int fileId, Hasp other)
		{
			this.parent = other;
			this.init(fileId);
		}

		public HaspFile(HaspFile other)
		{
			if (!(other == null))
			{
				this.parent = other.parent;
				this.init(other.getFileIdInt());
			}
		}

		~HaspFile()
		{
			this.Dispose(false);
		}

		private int handle
		{
			get
			{
				return this.parent.key.handle;
			}
		}

		public static implicit operator Hasp(HaspFile other)
		{
			Hasp hasp;
			if (other == null)
			{
				hasp = null;
			}
			else
			{
				hasp = other.parent;
			}
			return hasp;
		}

		public static bool CanWriteString(string value)
		{
			return value != null && (int)HaspFile.maxStringLength() >= value.Length;
		}

		private HaspFileId getFileId()
		{
			HaspFileId haspFileId;
			if (Enum.IsDefined(typeof(HaspFileId), (HaspFileId)this.pIntId))
			{
				haspFileId = (HaspFileId)this.pIntId;
			}
			else
			{
				haspFileId = HaspFileId.Custom;
			}
			return haspFileId;
		}

		private int getFileIdInt()
		{
			return this.pIntId;
		}

		public static int FilePosFromString(string value)
		{
			int num;
			if (value == null)
			{
				num = 0;
			}
			else
			{
				num = (HaspFile.CanWriteString(value) ? (value.Length + 2) : 0);
			}
			return num;
		}

		public HaspStatus FileSize(ref int size)
		{
			HaspStatus haspStatus = this.parent.Hasp_Prologue(this.parent.key);
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				size = 0;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.get_size(this.handle, this.pIntId, ref size);
			}
			return haspStatus2;
		}

		private void init()
		{
			this.init(65524);
		}

		private void init(int fileId)
		{
			this.ulFilePos = 0;
			if (this.parent == null)
			{
				this.pIntId = 0;
			}
			else
			{
				this.pIntId = fileId;
				if (this.parent.Feature.IsProgNum)
				{
					switch (fileId)
					{
					case 65524:
					case 65525:
						this.pIntId = 0;
						break;
					}
				}
				else
				{
					switch (fileId)
					{
					case 65520:
					case 65522:
						this.pIntId = 0;
						break;
					}
				}
			}
		}

		private static byte maxStringLength()
		{
			return byte.MaxValue;
		}

		public HaspFile Assign(HaspFile other)
		{
			HaspFile haspFile;
			if (other == null)
			{
				this.parent = null;
				this.init();
				haspFile = this;
			}
			else
			{
				this.parent = other.parent;
				this.init(other.getFileIdInt());
				haspFile = this;
			}
			return haspFile;
		}

		public HaspStatus Read(ref bool value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = false;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref byte value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(byte[] buffer, int index, int count)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else if (buffer == null)
			{
				haspStatus2 = HaspStatus.InvalidParameter;
			}
			else if (0 == count)
			{
				haspStatus2 = HaspStatus.StatusOk;
			}
			else if (index + count > buffer.Length)
			{
				haspStatus2 = HaspStatus.InvalidParameter;
			}
			else if (index == 0 && count == buffer.Length)
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, buffer);
			}
			else
			{
				byte[] array = new byte[count];
				haspStatus = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, array);
				if (haspStatus != HaspStatus.StatusOk)
				{
					haspStatus2 = haspStatus;
				}
				else
				{
					array.CopyTo(buffer, index);
					haspStatus2 = haspStatus;
				}
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref char value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = '\0';
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref double value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0.0;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref short value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref int value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref long value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0L;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref float value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0f;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public HaspStatus Read(ref string value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = "";
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		[CLSCompliant(false)]
		public HaspStatus Read(ref ushort value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		[CLSCompliant(false)]
		public HaspStatus Read(ref uint value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0U;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		[CLSCompliant(false)]
		public HaspStatus Read(ref ulong value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				value = 0UL;
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.read(this.handle, this.pIntId, this.ulFilePos, ref value);
			}
			return haspStatus2;
		}

		public int FilePos
		{
			get
			{
				return this.ulFilePos;
			}
			set
			{
				this.ulFilePos = value;
			}
		}

		public override string ToString()
		{
			HaspFileId haspFileId;
			if (Enum.IsDefined(typeof(HaspFileId), (HaspFileId)this.pIntId))
			{
				haspFileId = (HaspFileId)this.pIntId;
			}
			else
			{
				haspFileId = HaspFileId.Custom;
			}
			return haspFileId.ToString();
		}

		public HaspStatus Write(bool value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(byte value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(byte[] buffer, int index, int count)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else if (buffer == null)
			{
				haspStatus2 = HaspStatus.InvalidParameter;
			}
			else if (index + count > buffer.Length)
			{
				haspStatus2 = HaspStatus.InvalidParameter;
			}
			else if (index == 0)
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, buffer);
			}
			else
			{
				byte[] array = new byte[count];
				Array.Copy(buffer, index, array, 0, count);
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, array);
			}
			return haspStatus2;
		}

		public HaspStatus Write(char value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(double value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(short value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(int value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(long value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(float value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspStatus Write(string value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		[CLSCompliant(false)]
		public HaspStatus Write(ushort value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		[CLSCompliant(false)]
		public HaspStatus Write(uint value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		[CLSCompliant(false)]
		public HaspStatus Write(ulong value)
		{
			HaspStatus haspStatus = this.Hasp_Prologue();
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.write(this.handle, this.pIntId, this.ulFilePos, value);
			}
			return haspStatus2;
		}

		public HaspFileId FileId
		{
			get
			{
				HaspFileId haspFileId;
				if (Enum.IsDefined(typeof(HaspFileId), (HaspFileId)this.pIntId))
				{
					haspFileId = (HaspFileId)this.pIntId;
				}
				else
				{
					haspFileId = HaspFileId.Custom;
				}
				return haspFileId;
			}
		}

		[PermissionSet(SecurityAction.LinkDemand)]
		public static int TypeSize(Type type)
		{
			return Marshal.SizeOf(type);
		}

		public object Clone()
		{
			return new HaspFile(this);
		}

		private HaspStatus Hasp_Prologue()
		{
			return this.parent.Hasp_Prologue(this.parent.key);
		}

		public bool IsValid()
		{
			HaspFileId haspFileId;
			if (Enum.IsDefined(typeof(HaspFileId), (HaspFileId)this.pIntId))
			{
				haspFileId = (HaspFileId)this.pIntId;
			}
			else
			{
				haspFileId = HaspFileId.Custom;
			}
			return !this.isDisposed && this.parent.IsValid() && haspFileId != HaspFileId.None && (this.parent.key.IsLoggedIn || !this.parent.key.loggedOut);
		}

		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing)
		{
			if (!this.isDisposed)
			{
				this.parent = null;
			}
			this.isDisposed = true;
		}

		public bool IsLoggedIn()
		{
			return !this.isDisposed && this.IsValid() && this.parent.IsLoggedIn();
		}

		public int CompareTo(HaspFile other)
		{
			int num;
			if (other == null)
			{
				num = 1;
			}
			else if (this.parent == null)
			{
				num = -1;
			}
			else
			{
				try
				{
					if (other.parent == null)
					{
						return 1;
					}
				}
				catch (NullReferenceException)
				{
					return 1;
				}
				int num2 = this.parent.CompareTo(other.parent);
				if (num2 != 0)
				{
					num = num2;
				}
				else
				{
					num2 = this.pIntId.CompareTo(other.pIntId);
					if (num2 != 0)
					{
						num = num2;
					}
					else
					{
						num = this.ulFilePos.CompareTo(other.ulFilePos);
					}
				}
			}
			return num;
		}

		public int CompareTo(Hasp other)
		{
			int num;
			if (other == null)
			{
				num = 1;
			}
			else
			{
				num = this.parent.CompareTo(other);
			}
			return num;
		}

		public override bool Equals(object obj)
		{
			return this == obj;
		}

		public static bool operator ==(HaspFile left, object right)
		{
			bool flag;
			if (left == null && right == null)
			{
				flag = true;
			}
			else if (left == null || right == null)
			{
				flag = false;
			}
			else
			{
				HaspFile haspFile = right as HaspFile;
				if (haspFile != null)
				{
					flag = left.CompareTo(haspFile) == 0;
				}
				else
				{
					Hasp hasp = right as Hasp;
					flag = hasp != null && left.parent.CompareTo(hasp) == 0;
				}
			}
			return flag;
		}

		public static bool operator !=(HaspFile left, object right)
		{
			return !(left == right);
		}

		public override int GetHashCode()
		{
			return this.pIntId;
		}

		private Hasp parent;

		private int pIntId;

		private int ulFilePos;

		private bool isDisposed = false;
	}
}

-------------------------------------------------

HaspFileId.cs

using System;

namespace Aladdin.HASP
{
	[Serializable]
	public enum HaspFileId
	{
		None,
		Main = 65520,
		License = 65522,
		ReadOnly = 65525,
		ReadWrite = 65524,
		Custom = 123456
	}
}

-------------------------------------------------

HaspHandle.cs

using System;

namespace Aladdin.HASP
{
	internal struct HaspHandle
	{
	}
}

--------------------------------------------------

HaspLegacy.cs

using System;
using Aladdin.HASP.Internal;

namespace Aladdin.HASP
{
	public sealed class HaspLegacy : Hasp
	{
		public HaspLegacy(Hasp other)
			: base(other)
		{
		}

		public HaspLegacy(HaspLegacy other)
			: base(other)
		{
		}

		public new HaspStatus Decrypt(byte[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Decrypt(char[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Decrypt(double[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Decrypt(short[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Decrypt(int[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Decrypt(long[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Decrypt(float[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Decrypt(ref string data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_decrypt(this.key.handle, ref data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(byte[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(char[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(double[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(short[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(int[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(long[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(float[] data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, data);
				}
			}
			return haspStatus;
		}

		public new HaspStatus Encrypt(ref string data)
		{
			HaspStatus haspStatus;
			if (data == null)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				HaspStatus haspStatus2 = base.Hasp_Prologue(this.key);
				if (haspStatus2 != HaspStatus.StatusOk)
				{
					haspStatus = haspStatus2;
				}
				else
				{
					haspStatus = ApiDisp.legacy_encrypt(this.key.handle, ref data);
				}
			}
			return haspStatus;
		}

		public HaspStatus SetIdleTime(short idleTime)
		{
			HaspStatus haspStatus = base.Hasp_Prologue(this.key);
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				haspStatus2 = ApiDisp.legacy_set_idletime(this.key.handle, idleTime);
			}
			return haspStatus2;
		}

		public HaspStatus SetRtc(DateTime rtc)
		{
			HaspStatus haspStatus = base.Hasp_Prologue(this.key);
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				haspStatus2 = haspStatus;
			}
			else
			{
				DateTime dateTime = new DateTime(1970, 1, 1);
				haspStatus2 = ApiDisp.legacy_set_rtc(this.key.handle, (rtc.Ticks - dateTime.Ticks) / 10L / 1000L / 1000L);
			}
			return haspStatus2;
		}

		public new bool IsValid()
		{
			return base.IsValid() && base.HasLegacy && (this.key.IsLoggedIn || !this.key.loggedOut);
		}

		public new object Clone()
		{
			return new HaspLegacy(this);
		}

		public new HaspLegacy Assign(Hasp other)
		{
			base.Assign(other);
			return this;
		}
	}
}

--------------------------------------------------------

HaspStatus.cs

using System;

namespace Aladdin.HASP
{
	[Serializable]
	public enum HaspStatus
	{
		StatusOk,
		InvalidAddress,
		InvalidFeature,
		NotEnoughMemory,
		TooManyOpenFeatures,
		AccessDenied,
		IncompatibleFeature,
		ContainerNotFound,
		HaspNotFound = 7,
		BufferTooShort,
		InvalidHandle,
		InvalidFile,
		DriverTooOld,
		NoTime,
		SystemError,
		DriverNotFound,
		InvalidFormat,
		RequestNotSupported,
		InvalidUpdateObject,
		KeyIdNotFound,
		InvalidUpdateData,
		UpdateNotSupported,
		InvalidUpdateCounter,
		InvalidVendorCode,
		EncryptionNotSupported,
		InvalidTime,
		NoBatteryPower,
		UpdateNoAckSpace,
		TerminalServiceDetected,
		FeatureNotImplemented,
		UnknownAlgorithm,
		InvalidSignature,
		FeatureNotFound,
		NoLog,
		LocalCommErr,
		UnknownVcode,
		InvalidXmlSpec,
		InvalidXmlScope,
		TooManyKeys,
		TooManyUsers,
		BrokenSession,
		RemoteCommErr,
		FeatureExpired,
		TooOldLM,
		DeviceError,
		UpdateBlocked,
		TimeError,
		SecureChannelError,
		CorruptStorage,
		VendorLibNotFound,
		InvalidVendorLib,
		EmptyScopeResults,
		VMDetected,
		HardwareModified,
		UserDenied,
		UpdateTooOld,
		UpdateTooNew,
		VendorlibOld,
		UploadError,
		InvalidRecipient,
		InvalidDetachAction,
		TooManyProducts,
		InvalidProduct,
		UnknownRecipient,
		InvalidDuration,
		CloneDetected,
		UpdateAlreadyAdded,
		HaspInactive,
		NoDetachableFeature,
		TooManyHosts,
		RehostNotAllowed,
		LicenseRehosted,
		RehostAlreadyApplied,
		CannotReadFile,
		ExtensionNotAllowed,
		DetachDisabled,
		RehostDisabled,
		DetachedLicenseFound,
		RecipientOldLm,
		SecureStoreIdMismatch,
		DuplicateHostname,
		MissingLM,
		NoApiDylib = 400,
		InvApiDylib,
		InvalidObject = 500,
		InvalidParameter,
		AlreadyLoggedIn,
		AlreadyLoggedOut,
		OperationFailed = 525,
		NoExtensionBlock = 600,
		InvalidPortType = 650,
		InvalidPort,
		NotImplemented = 698,
		InternalError,
		HaspDotNetDllBroken = 652
	}
}

----------------------------------------------------

HaspVersion.cs

using System;

namespace Aladdin.HASP
{
	[Serializable]
	public struct HaspVersion
	{
		public int MajorVersion
		{
			get
			{
				return this.majorVersion;
			}
		}

		public int MinorVersion
		{
			get
			{
				return this.minorVersion;
			}
		}

		public int ServerBuild
		{
			get
			{
				return this.serverBuild;
			}
		}

		public int BuildNumber
		{
			get
			{
				return this.buildNumber;
			}
		}

		public HaspVersion(int majorVersion, int minorVersion, int serverBuild, int buildNumber)
		{
			this.majorVersion = majorVersion;
			this.minorVersion = minorVersion;
			this.serverBuild = serverBuild;
			this.buildNumber = buildNumber;
		}

		public override bool Equals(object obj)
		{
			bool flag;
			if (obj == null)
			{
				flag = false;
			}
			else if (obj.GetType() != typeof(HaspVersion))
			{
				flag = false;
			}
			else
			{
				HaspVersion haspVersion = (HaspVersion)obj;
				flag = haspVersion.majorVersion == this.majorVersion && haspVersion.minorVersion == this.minorVersion && haspVersion.serverBuild == this.serverBuild && haspVersion.buildNumber == this.buildNumber;
			}
			return flag;
		}

		public override int GetHashCode()
		{
			return this.majorVersion ^ this.minorVersion ^ this.serverBuild ^ this.buildNumber;
		}

		public static bool operator ==(HaspVersion left, HaspVersion right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(HaspVersion left, HaspVersion right)
		{
			return !left.Equals(right);
		}

		private int majorVersion;

		private int minorVersion;

		private int serverBuild;

		private int buildNumber;
	}
}

-------------------------------------------------------

NativeMethods.cs

using System;
using System.Runtime.InteropServices;

namespace Aladdin.HASP.Internal.NativeMethods32
{
	internal static class NativeMethods
	{
		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_login(int feature_id, string vendor_code, ref int handle);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_login(int feature_id, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, string vendor_code, ref int handle);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_logout(int handle);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [Out] byte[] buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, byte[] buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_size(int handle, int fileid, ref int size);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_rtc(int handle, ref long time);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_set_rtc(int handle, long new_time);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_set_idletime(int handle, short idle_time);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_info(string scope, string format, string vendor_code, ref string info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_info(string scope, string format, byte[] vendor_code, ref string info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, string format, ref string info);

		[DllImport("apidsp_windows.dll")]
		public static extern void hasp_free(IntPtr info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_update(string update_data, ref string ack_data);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_transfer(string action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_login(int feature_id, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_login_scope(int feature_id, IntPtr scope, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_info(IntPtr scope, IntPtr format, IntPtr vendor_code, ref IntPtr info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, IntPtr format, ref IntPtr info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_update(IntPtr update_data, ref IntPtr ack_data);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_detach(IntPtr detach_action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_transfer(IntPtr action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, IntPtr vendor_code);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_set_lib_path(IntPtr path);

		[DllImport("apidsp_windows.dll")]
		public static extern HaspStatus hasp_set_lib_path(int path);

		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern bool SetDllDirectory(string pathName);
	}
}

--------------------------------------------------------------

NativeMethods.cs

using System;
using System.Runtime.InteropServices;

namespace Aladdin.HASP.Internal.NativeMethods64
{
	internal static class NativeMethods
	{
		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_login(int feature_id, string vendor_code, ref int handle);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_login(int feature_id, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, string vendor_code, ref int handle);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_logout(int handle);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [Out] byte[] buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, byte[] buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_size(int handle, int fileid, ref int size);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_rtc(int handle, ref long time);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_set_rtc(int handle, long new_time);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_set_idletime(int handle, short idle_time);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_info(string scope, string format, string vendor_code, ref string info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_info(string scope, string format, byte[] vendor_code, ref string info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, string format, ref string info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern void hasp_free(IntPtr info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_update(string update_data, ref string ack_data);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_transfer(string action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_login(int feature_id, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_login_scope(int feature_id, IntPtr scope, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_info(IntPtr scope, IntPtr format, IntPtr vendor_code, ref IntPtr info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, IntPtr format, ref IntPtr info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_update(IntPtr update_data, ref IntPtr ack_data);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_detach(IntPtr detach_action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_transfer(IntPtr action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, IntPtr vendor_code);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_set_lib_path(IntPtr path);

		[DllImport("apidsp_windows_x64.dll")]
		public static extern HaspStatus hasp_set_lib_path(long path);
	}
}

---------------------------------------------------------

NativeMethods.cs

using System;
using System.Runtime.InteropServices;

namespace Aladdin.HASP.Internal.NativeMethodsDarwin
{
	internal static class NativeMethods
	{
		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_login(int feature_id, string vendor_code, ref int handle);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_login(int feature_id, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, string vendor_code, ref int handle);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_logout(int handle);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [Out] byte[] buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, byte[] buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_size(int handle, int fileid, ref int size);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_rtc(int handle, ref long time);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_set_rtc(int handle, long new_time);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_set_idletime(int handle, short idle_time);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_info(string scope, string format, string vendor_code, ref string info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_info(string scope, string format, byte[] vendor_code, ref string info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, string format, ref string info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern void hasp_free(IntPtr info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_update(string update_data, ref string ack_data);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_transfer(string action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_login(int feature_id, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_login_scope(int feature_id, IntPtr scope, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_info(IntPtr scope, IntPtr format, IntPtr vendor_code, ref IntPtr info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, IntPtr format, ref IntPtr info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_update(IntPtr update_data, ref IntPtr ack_data);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_detach(IntPtr detach_action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_transfer(IntPtr action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_darwin.dylib")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, IntPtr vendor_code);
	}
}

---------------------------------------------------

NativeMethods.cs

using System;
using System.Runtime.InteropServices;

namespace Aladdin.HASP.Internal.NativeMethodsLinux32
{
	internal static class NativeMethods
	{
		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_login(int feature_id, string vendor_code, ref int handle);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_login(int feature_id, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, string vendor_code, ref int handle);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_logout(int handle);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [Out] byte[] buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, byte[] buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_size(int handle, int fileid, ref int size);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_rtc(int handle, ref long time);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_set_rtc(int handle, long new_time);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_set_idletime(int handle, short idle_time);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_info(string scope, string format, string vendor_code, ref string info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_info(string scope, string format, byte[] vendor_code, ref string info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, string format, ref string info);

		[DllImport("apidsp_linux.so")]
		public static extern void hasp_free(IntPtr info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_update(string update_data, ref string ack_data);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_transfer(string action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_login(int feature_id, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_login_scope(int feature_id, IntPtr scope, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_info(IntPtr scope, IntPtr format, IntPtr vendor_code, ref IntPtr info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, IntPtr format, ref IntPtr info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_update(IntPtr update_data, ref IntPtr ack_data);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_detach(IntPtr detach_action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_transfer(IntPtr action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_linux.so")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, IntPtr vendor_code);
	}
}

------------------------------------------------------------

NativeMethods.cs

using System;
using System.Runtime.InteropServices;

namespace Aladdin.HASP.Internal.NativeMethodsLinux64
{
	internal static class NativeMethods
	{
		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_login(int feature_id, string vendor_code, ref int handle);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_login(int feature_id, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, string vendor_code, ref int handle);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_logout(int handle);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] byte[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] double[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] short[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] int[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] long[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] float[] data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [Out] byte[] buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, byte[] buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, [MarshalAs(UnmanagedType.U1)] ref bool buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref byte buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref char buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref double buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref short buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref int buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref long buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ushort buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref uint buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref ulong buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref float buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref string buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_size(int handle, int fileid, ref int size);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_rtc(int handle, ref long time);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] byte[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] double[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] short[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] int[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] long[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] float[] buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_set_rtc(int handle, long new_time);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_set_idletime(int handle, short idle_time);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_info(string scope, string format, string vendor_code, ref string info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_info(string scope, string format, byte[] vendor_code, ref string info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, string format, ref string info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern void hasp_free(IntPtr info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_update(string update_data, ref string ack_data);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_transfer(string action, string scope, string vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_login(int feature_id, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_login_scope(int feature_id, IntPtr scope, IntPtr vendor_code, ref int handle);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_encrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_decrypt(int handle, [In] [Out] IntPtr data, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_read(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, ref IntPtr buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_write(int handle, int fileid, int offset, int length, IntPtr buffer);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_encrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_legacy_decrypt(int handle, [In] [Out] IntPtr buffer, int length);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_info(IntPtr scope, IntPtr format, IntPtr vendor_code, ref IntPtr info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_sessioninfo(int handle, IntPtr format, ref IntPtr info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_update(IntPtr update_data, ref IntPtr ack_data);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_detach(IntPtr detach_action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_transfer(IntPtr action, IntPtr scope, IntPtr vendor_code, IntPtr recipient, ref IntPtr info);

		[DllImport("apidsp_linux_x64.so")]
		public static extern HaspStatus hasp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, IntPtr vendor_code);
	}
}

-------------------------------------------------------

ApiDisp.cs

using System;
using System.Runtime.InteropServices;
using System.Text;
using Aladdin.HASP.Internal.NativeMethods32;

namespace Aladdin.HASP.Internal
{
	internal static class ApiDisp
	{
		public static int IsRunningOnMono()
		{
			int num = 1;
			if (Environment.OSVersion.ToString().IndexOf("Windows") >= 0)
			{
				num = 0;
			}
			else
			{
				string text = Environment.OSVersion.ToString();
				int num2 = text.IndexOf('.');
				int num3 = text.IndexOf(' ');
				if (num2 >= 0 && num3 >= 0)
				{
					string text2 = text.Substring(num3, num2 - num3);
					int num4 = int.Parse(text2);
					if (num4 >= 4)
					{
						num = 2;
					}
				}
			}
			return num;
		}

		public static IntPtr NativeUtf8FromString(string managedString)
		{
			int byteCount = Encoding.UTF8.GetByteCount(managedString);
			byte[] array = new byte[byteCount + 1];
			Encoding.UTF8.GetBytes(managedString, 0, managedString.Length, array, 0);
			IntPtr intPtr = Marshal.AllocHGlobal(array.Length);
			Marshal.Copy(array, 0, intPtr, array.Length);
			return intPtr;
		}

		public static string StringFromNativeUtf8(IntPtr nativeUtf8)
		{
			int num = 0;
			while (Marshal.ReadByte(nativeUtf8, num) != 0)
			{
				num++;
			}
			string text;
			if (num == 0)
			{
				text = string.Empty;
			}
			else
			{
				byte[] array = new byte[num];
				Marshal.Copy(nativeUtf8, array, 0, array.Length);
				text = Encoding.UTF8.GetString(array);
			}
			return text;
		}

		public static HaspStatus login(int feature_id, string vendor_code, ref int handle)
		{
			return ApiDisp.apidsp.disp_login(feature_id, vendor_code, ref handle);
		}

		public static HaspStatus login(int feature_id, byte[] vendor_code, ref int handle)
		{
			return ApiDisp.apidsp.disp_login(feature_id, vendor_code, ref handle);
		}

		public static HaspStatus login_scope(int feature_id, string scope, string vendor_code, ref int handle)
		{
			return ApiDisp.apidsp.disp_login_scope(feature_id, scope, vendor_code, ref handle);
		}

		public static HaspStatus login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle)
		{
			return ApiDisp.apidsp.disp_login_scope(feature_id, scope, vendor_code, ref handle);
		}

		public static HaspStatus logout(int handle)
		{
			return ApiDisp.apidsp.disp_logout(handle);
		}

		public static HaspStatus encrypt(int handle, byte[] data)
		{
			return ApiDisp.apidsp.disp_encrypt(handle, data);
		}

		public static HaspStatus encrypt(int handle, char[] data)
		{
			short[] array = new short[data.Length];
			for (int i = 0; i < data.Length; i++)
			{
				array[i] = (short)data[i];
			}
			HaspStatus haspStatus = ApiDisp.apidsp.disp_encrypt(handle, array);
			for (int i = 0; i < data.Length; i++)
			{
				data[i] = (char)array[i];
			}
			return haspStatus;
		}

		public static HaspStatus encrypt(int handle, double[] data)
		{
			return ApiDisp.apidsp.disp_encrypt(handle, data);
		}

		public static HaspStatus encrypt(int handle, short[] data)
		{
			return ApiDisp.apidsp.disp_encrypt(handle, data);
		}

		public static HaspStatus encrypt(int handle, int[] data)
		{
			return ApiDisp.apidsp.disp_encrypt(handle, data);
		}

		public static HaspStatus encrypt(int handle, long[] data)
		{
			return ApiDisp.apidsp.disp_encrypt(handle, data);
		}

		public static HaspStatus encrypt(int handle, float[] data)
		{
			return ApiDisp.apidsp.disp_encrypt(handle, data);
		}

		public static HaspStatus encrypt(int handle, ref string data)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(data);
			HaspStatus haspStatus = ApiDisp.apidsp.disp_encrypt(handle, bytes);
			data = Convert.ToBase64String(bytes);
			return haspStatus;
		}

		public static HaspStatus decrypt(int handle, byte[] data)
		{
			return ApiDisp.apidsp.disp_decrypt(handle, data);
		}

		public static HaspStatus decrypt(int handle, char[] data)
		{
			short[] array = new short[data.Length];
			for (int i = 0; i < data.Length; i++)
			{
				array[i] = (short)data[i];
			}
			HaspStatus haspStatus = ApiDisp.apidsp.disp_decrypt(handle, array);
			for (int i = 0; i < data.Length; i++)
			{
				data[i] = (char)array[i];
			}
			return haspStatus;
		}

		public static HaspStatus decrypt(int handle, double[] data)
		{
			return ApiDisp.apidsp.disp_decrypt(handle, data);
		}

		public static HaspStatus decrypt(int handle, short[] data)
		{
			return ApiDisp.apidsp.disp_decrypt(handle, data);
		}

		public static HaspStatus decrypt(int handle, int[] data)
		{
			return ApiDisp.apidsp.disp_decrypt(handle, data);
		}

		public static HaspStatus decrypt(int handle, long[] data)
		{
			return ApiDisp.apidsp.disp_decrypt(handle, data);
		}

		public static HaspStatus decrypt(int handle, float[] data)
		{
			return ApiDisp.apidsp.disp_decrypt(handle, data);
		}

		public static HaspStatus decrypt(int handle, ref string data)
		{
			byte[] array = Convert.FromBase64String(data);
			HaspStatus haspStatus = ApiDisp.apidsp.disp_decrypt(handle, array);
			data = Encoding.UTF8.GetString(array);
			return haspStatus;
		}

		public static HaspStatus read(int handle, int fileid, int offset, byte[] buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, buffer.Length, buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref bool buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref byte buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref char buffer)
		{
			short num = 0;
			HaspStatus haspStatus = ApiDisp.apidsp.disp_read(handle, fileid, offset, ref num);
			buffer = (char)num;
			return haspStatus;
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref double buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref short buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref int buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref long buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref ushort buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref uint buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref ulong buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref float buffer)
		{
			return ApiDisp.apidsp.disp_read(handle, fileid, offset, ref buffer);
		}

		public static HaspStatus read(int handle, int fileid, int offset, ref string buffer)
		{
			byte b = 0;
			HaspStatus haspStatus = ApiDisp.read(handle, fileid, offset, ref b);
			HaspStatus haspStatus2;
			if (haspStatus != HaspStatus.StatusOk)
			{
				buffer = "";
				haspStatus2 = haspStatus;
			}
			else
			{
				byte[] array = new byte[(int)b];
				haspStatus = ApiDisp.read(handle, fileid, offset + 1, array);
				if (haspStatus != HaspStatus.StatusOk)
				{
					buffer = "";
					haspStatus2 = haspStatus;
				}
				else
				{
					buffer = Encoding.UTF8.GetString(array);
					haspStatus2 = HaspStatus.StatusOk;
				}
			}
			return haspStatus2;
		}

		public static HaspStatus write(int handle, int fileid, int offset, byte[] buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, bool buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, byte buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, char buffer)
		{
			short num = (short)buffer;
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, num);
		}

		public static HaspStatus write(int handle, int fileid, int offset, double buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, short buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, int buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, long buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, ushort buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, uint buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, ulong buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, float buffer)
		{
			return ApiDisp.apidsp.disp_write(handle, fileid, offset, buffer);
		}

		public static HaspStatus write(int handle, int fileid, int offset, string buffer)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(buffer);
			byte[] array = new byte[bytes.Length + 1];
			HaspStatus haspStatus;
			if (bytes.Length > 255)
			{
				haspStatus = HaspStatus.InvalidParameter;
			}
			else
			{
				array[0] = (byte)bytes.Length;
				bytes.CopyTo(array, 1);
				haspStatus = ApiDisp.apidsp.disp_write(handle, fileid, offset, array);
			}
			return haspStatus;
		}

		public static HaspStatus get_size(int handle, int fileid, ref int size)
		{
			return ApiDisp.apidsp.disp_get_size(handle, fileid, ref size);
		}

		public static HaspStatus get_rtc(int handle, ref long time)
		{
			return ApiDisp.apidsp.disp_get_rtc(handle, ref time);
		}

		public static HaspStatus legacy_encrypt(int handle, byte[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_encrypt(handle, buffer);
		}

		public static HaspStatus legacy_encrypt(int handle, char[] data)
		{
			short[] array = new short[data.Length];
			for (int i = 0; i < data.Length; i++)
			{
				array[i] = (short)data[i];
			}
			HaspStatus haspStatus = ApiDisp.apidsp.disp_legacy_encrypt(handle, array);
			for (int i = 0; i < data.Length; i++)
			{
				data[i] = (char)array[i];
			}
			return haspStatus;
		}

		public static HaspStatus legacy_encrypt(int handle, double[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_encrypt(handle, buffer);
		}

		public static HaspStatus legacy_encrypt(int handle, short[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_encrypt(handle, buffer);
		}

		public static HaspStatus legacy_encrypt(int handle, int[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_encrypt(handle, buffer);
		}

		public static HaspStatus legacy_encrypt(int handle, long[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_encrypt(handle, buffer);
		}

		public static HaspStatus legacy_encrypt(int handle, float[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_encrypt(handle, buffer);
		}

		public static HaspStatus legacy_encrypt(int handle, ref string data)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(data);
			HaspStatus haspStatus = ApiDisp.apidsp.disp_legacy_encrypt(handle, bytes);
			data = Convert.ToBase64String(bytes);
			return haspStatus;
		}

		public static HaspStatus legacy_decrypt(int handle, byte[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_decrypt(handle, buffer);
		}

		public static HaspStatus legacy_decrypt(int handle, char[] data)
		{
			short[] array = new short[data.Length];
			for (int i = 0; i < data.Length; i++)
			{
				array[i] = (short)data[i];
			}
			HaspStatus haspStatus = ApiDisp.apidsp.disp_legacy_decrypt(handle, array);
			for (int i = 0; i < data.Length; i++)
			{
				data[i] = (char)array[i];
			}
			return haspStatus;
		}

		public static HaspStatus legacy_decrypt(int handle, double[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_decrypt(handle, buffer);
		}

		public static HaspStatus legacy_decrypt(int handle, short[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_decrypt(handle, buffer);
		}

		public static HaspStatus legacy_decrypt(int handle, int[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_decrypt(handle, buffer);
		}

		public static HaspStatus legacy_decrypt(int handle, long[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_decrypt(handle, buffer);
		}

		public static HaspStatus legacy_decrypt(int handle, float[] buffer)
		{
			return ApiDisp.apidsp.disp_legacy_decrypt(handle, buffer);
		}

		public static HaspStatus legacy_decrypt(int handle, ref string data)
		{
			byte[] array = Convert.FromBase64String(data);
			HaspStatus haspStatus = ApiDisp.apidsp.disp_legacy_decrypt(handle, array);
			data = Encoding.UTF8.GetString(array);
			return haspStatus;
		}

		public static HaspStatus legacy_set_rtc(int handle, long new_time)
		{
			return ApiDisp.apidsp.disp_legacy_set_rtc(handle, new_time);
		}

		public static HaspStatus legacy_set_idletime(int handle, short idle_time)
		{
			return ApiDisp.apidsp.disp_legacy_set_idletime(handle, idle_time);
		}

		public static HaspStatus get_info(string scope, string format, string vendor_code, ref string info)
		{
			return ApiDisp.apidsp.disp_get_info(scope, format, vendor_code, ref info);
		}

		public static HaspStatus get_info(string scope, string format, byte[] vendor_code, ref string info)
		{
			return ApiDisp.apidsp.disp_get_info(scope, format, vendor_code, ref info);
		}

		public static HaspStatus get_sessioninfo(int handle, string format, ref string info)
		{
			return ApiDisp.apidsp.disp_get_sessioninfo(handle, format, ref info);
		}

		public static HaspStatus update(string update_data, ref string ack_data)
		{
			return ApiDisp.apidsp.disp_update(update_data, ref ack_data);
		}

		public static HaspStatus get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code)
		{
			return ApiDisp.apidsp.disp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, vendor_code);
		}

		public static HaspStatus get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code)
		{
			return ApiDisp.apidsp.disp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, vendor_code);
		}

		public static HaspStatus detach(string detach_action, string scope, string vendor_code, string recipient, ref string info)
		{
			return ApiDisp.apidsp.disp_detach(detach_action, scope, vendor_code, recipient, ref info);
		}

		public static HaspStatus detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			return ApiDisp.apidsp.disp_detach(detach_action, scope, vendor_code, recipient, ref info);
		}

		public static HaspStatus set_lib_path(string path)
		{
			if (ApiDisp.IsRunningOnMono() == 1)
			{
				NativeMethods.SetDllDirectory(path);
			}
			return ApiDisp.apidsp.disp_set_lib_path(path);
		}

		public static HaspStatus transfer(string action, string scope, string vendor_code, string recipient, ref string info)
		{
			return ApiDisp.apidsp.disp_transfer(action, scope, vendor_code, recipient, ref info);
		}

		public static HaspStatus transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			return ApiDisp.apidsp.disp_transfer(action, scope, vendor_code, recipient, ref info);
		}

		// Note: this type is marked as 'beforefieldinit'.
		static ApiDisp()
		{
			ApiDispatcher apiDispatcher2;
			if (ApiDisp.IsRunningOnMono() <= 0)
			{
				if (IntPtr.Size != 4)
				{
					ApiDispatcher apiDispatcher = new ApiDispatcher64();
					apiDispatcher2 = apiDispatcher;
				}
				else
				{
					apiDispatcher2 = new ApiDispatcher32();
				}
			}
			else if (ApiDisp.IsRunningOnMono() != 1)
			{
				apiDispatcher2 = new ApiDispatcherDarwin();
			}
			else if (IntPtr.Size != 4)
			{
				ApiDispatcher apiDispatcher = new ApiDispatcherLinux64();
				apiDispatcher2 = apiDispatcher;
			}
			else
			{
				apiDispatcher2 = new ApiDispatcherLinux32();
			}
			ApiDisp.apidsp = apiDispatcher2;
		}

		private static ApiDispatcher apidsp;
	}
}

----------------------------------------------------

ApiDispatcher.cs

using System;

namespace Aladdin.HASP.Internal
{
	internal interface ApiDispatcher
	{
		HaspStatus disp_login(int feature_id, string vendor_code, ref int handle);

		HaspStatus disp_login(int feature_id, byte[] vendor_code, ref int handle);

		HaspStatus disp_login_scope(int feature_id, string scope, string vendor_code, ref int handle);

		HaspStatus disp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle);

		HaspStatus disp_logout(int handle);

		HaspStatus disp_encrypt(int handle, byte[] data);

		HaspStatus disp_encrypt(int handle, double[] data);

		HaspStatus disp_encrypt(int handle, short[] data);

		HaspStatus disp_encrypt(int handle, int[] data);

		HaspStatus disp_encrypt(int handle, long[] data);

		HaspStatus disp_encrypt(int handle, float[] data);

		HaspStatus disp_decrypt(int handle, byte[] data);

		HaspStatus disp_decrypt(int handle, double[] data);

		HaspStatus disp_decrypt(int handle, short[] data);

		HaspStatus disp_decrypt(int handle, int[] data);

		HaspStatus disp_decrypt(int handle, long[] data);

		HaspStatus disp_decrypt(int handle, float[] data);

		HaspStatus disp_read(int handle, int fileid, int offset, int length, byte[] buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref bool buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref byte buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref char buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref double buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref short buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref int buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref long buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref ushort buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref uint buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref ulong buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref float buffer);

		HaspStatus disp_read(int handle, int fileid, int offset, ref string buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, byte[] buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, bool buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, byte buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, char buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, double buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, short buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, int buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, long buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, ushort buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, uint buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, ulong buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, float buffer);

		HaspStatus disp_write(int handle, int fileid, int offset, string buffer);

		HaspStatus disp_get_size(int handle, int fileid, ref int size);

		HaspStatus disp_get_rtc(int handle, ref long time);

		HaspStatus disp_legacy_encrypt(int handle, byte[] buffer);

		HaspStatus disp_legacy_encrypt(int handle, double[] buffer);

		HaspStatus disp_legacy_encrypt(int handle, short[] buffer);

		HaspStatus disp_legacy_encrypt(int handle, int[] buffer);

		HaspStatus disp_legacy_encrypt(int handle, long[] buffer);

		HaspStatus disp_legacy_encrypt(int handle, float[] buffer);

		HaspStatus disp_legacy_decrypt(int handle, byte[] buffer);

		HaspStatus disp_legacy_decrypt(int handle, double[] buffer);

		HaspStatus disp_legacy_decrypt(int handle, short[] buffer);

		HaspStatus disp_legacy_decrypt(int handle, int[] buffer);

		HaspStatus disp_legacy_decrypt(int handle, long[] buffer);

		HaspStatus disp_legacy_decrypt(int handle, float[] buffer);

		HaspStatus disp_legacy_set_rtc(int handle, long new_time);

		HaspStatus disp_legacy_set_idletime(int handle, short idle_time);

		HaspStatus disp_get_info(string scope, string format, string vendor_code, ref string info);

		HaspStatus disp_get_info(string scope, string format, byte[] vendor_code, ref string info);

		HaspStatus disp_get_sessioninfo(int handle, string format, ref string info);

		void disp_free(IntPtr info);

		HaspStatus disp_update(string update_data, ref string ack_data);

		HaspStatus disp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info);

		HaspStatus disp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info);

		HaspStatus disp_transfer(string action, string scope, string vendor_code, string recipient, ref string info);

		HaspStatus disp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info);

		HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code);

		HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code);

		HaspStatus disp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time);

		HaspStatus disp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second);

		HaspStatus disp_set_lib_path(string path);
	}
}


--------------------------------------------------------

ApiDispatcher32.cs

using System;
using System.Runtime.InteropServices;
using System.Text;
using Aladdin.HASP.Internal.NativeMethods32;

namespace Aladdin.HASP.Internal
{
	internal class ApiDispatcher32 : ApiDispatcher
	{
		public HaspStatus disp_login(int feature_id, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login(int feature_id, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr2 = ApiDisp.NativeUtf8FromString(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr2 = ApiDisp.NativeUtf8FromString(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_logout(int handle)
		{
			return NativeMethods.hasp_logout(handle);
		}

		public HaspStatus disp_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, int length, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, length, intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, buffer, 0, length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref bool buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref byte buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref char buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref double buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref short buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref int buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref long buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ushort buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref uint buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ulong buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref float buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref string buffer)
		{
			IntPtr zero = IntPtr.Zero;
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, 1, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAuto(zero);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(buffer, 0, intPtr, buffer.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, buffer.Length, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, bool buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, char buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, double buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, short buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, int buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, long buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ushort buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, uint buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ulong buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, float buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, string buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToCoTaskMemAuto(buffer);
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, 1, ref intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAnsi(intPtr);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_size(int handle, int fileid, ref int size)
		{
			return NativeMethods.hasp_get_size(handle, fileid, ref size);
		}

		public HaspStatus disp_get_rtc(int handle, ref long time)
		{
			return NativeMethods.hasp_get_rtc(handle, ref time);
		}

		public HaspStatus disp_legacy_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_set_rtc(int handle, long new_time)
		{
			return NativeMethods.hasp_legacy_set_rtc(handle, new_time);
		}

		public HaspStatus disp_legacy_set_idletime(int handle, short idle_time)
		{
			return NativeMethods.hasp_legacy_set_idletime(handle, idle_time);
		}

		public HaspStatus disp_get_info(string scope, string format, string vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_info(string scope, string format, byte[] vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_sessioninfo(int handle, string format, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(format);
			HaspStatus haspStatus = NativeMethods.hasp_get_sessioninfo(handle, intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public void disp_free(IntPtr info)
		{
			NativeMethods.hasp_free(info);
		}

		public HaspStatus disp_update(string update_data, ref string ack_data)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(update_data);
			HaspStatus haspStatus = NativeMethods.hasp_update(intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				if (zero != IntPtr.Zero)
				{
					ack_data = ApiDisp.StringFromNativeUtf8(zero);
				}
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time)
		{
			return NativeMethods.hasp_datetime_to_hasptime(day, month, year, hour, minute, second, ref time);
		}

		public HaspStatus disp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second)
		{
			return NativeMethods.hasp_hasptime_to_datetime(time, ref day, ref month, ref year, ref hour, ref minute, ref second);
		}

		public HaspStatus disp_set_lib_path(string path)
		{
			IntPtr intPtr = IntPtr.Zero;
			NativeMethods.SetDllDirectory(path);
			HaspStatus haspStatus;
			if (path != null)
			{
				intPtr = ApiDisp.NativeUtf8FromString(path);
				haspStatus = NativeMethods.hasp_set_lib_path(intPtr);
			}
			else
			{
				haspStatus = NativeMethods.hasp_set_lib_path(0);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}
	}
}


----------------------------------------------------------------

ApiDispatcher64.cs

using System;
using System.Runtime.InteropServices;
using System.Text;
using Aladdin.HASP.Internal.NativeMethods64;

namespace Aladdin.HASP.Internal
{
	internal class ApiDispatcher64 : ApiDispatcher
	{
		public HaspStatus disp_login(int feature_id, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login(int feature_id, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr2 = ApiDisp.NativeUtf8FromString(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr2 = ApiDisp.NativeUtf8FromString(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_logout(int handle)
		{
			return NativeMethods.hasp_logout(handle);
		}

		public HaspStatus disp_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, int length, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, length, intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, buffer, 0, length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref bool buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref byte buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref char buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref double buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref short buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref int buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref long buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ushort buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref uint buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ulong buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref float buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref string buffer)
		{
			IntPtr zero = IntPtr.Zero;
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, 1, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAuto(zero);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(buffer, 0, intPtr, buffer.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, buffer.Length, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, bool buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, char buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, double buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, short buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, int buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, long buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ushort buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, uint buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ulong buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, float buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, string buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToCoTaskMemAuto(buffer);
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, 1, ref intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAnsi(intPtr);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_size(int handle, int fileid, ref int size)
		{
			return NativeMethods.hasp_get_size(handle, fileid, ref size);
		}

		public HaspStatus disp_get_rtc(int handle, ref long time)
		{
			return NativeMethods.hasp_get_rtc(handle, ref time);
		}

		public HaspStatus disp_legacy_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_set_rtc(int handle, long new_time)
		{
			return NativeMethods.hasp_legacy_set_rtc(handle, new_time);
		}

		public HaspStatus disp_legacy_set_idletime(int handle, short idle_time)
		{
			return NativeMethods.hasp_legacy_set_idletime(handle, idle_time);
		}

		public HaspStatus disp_get_info(string scope, string format, string vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_info(string scope, string format, byte[] vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_sessioninfo(int handle, string format, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(format);
			HaspStatus haspStatus = NativeMethods.hasp_get_sessioninfo(handle, intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public void disp_free(IntPtr info)
		{
			NativeMethods.hasp_free(info);
		}

		public HaspStatus disp_update(string update_data, ref string ack_data)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(update_data);
			HaspStatus haspStatus = NativeMethods.hasp_update(intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				if (zero != IntPtr.Zero)
				{
					ack_data = ApiDisp.StringFromNativeUtf8(zero);
				}
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = ApiDisp.NativeUtf8FromString(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = ApiDisp.NativeUtf8FromString(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = ApiDisp.StringFromNativeUtf8(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				this.disp_free(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time)
		{
			return NativeMethods.hasp_datetime_to_hasptime(day, month, year, hour, minute, second, ref time);
		}

		public HaspStatus disp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second)
		{
			return NativeMethods.hasp_hasptime_to_datetime(time, ref day, ref month, ref year, ref hour, ref minute, ref second);
		}

		public HaspStatus disp_set_lib_path(string path)
		{
			IntPtr intPtr = IntPtr.Zero;
			HaspStatus haspStatus;
			if (path != null)
			{
				intPtr = ApiDisp.NativeUtf8FromString(path);
				haspStatus = NativeMethods.hasp_set_lib_path(intPtr);
			}
			else
			{
				haspStatus = NativeMethods.hasp_set_lib_path(0L);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}
	}
}

----------------------------------------------------------

ApiDispatcherDarwin.cs

using System;
using System.Runtime.InteropServices;
using System.Text;
using Aladdin.HASP.Internal.NativeMethods64;
using Aladdin.HASP.Internal.NativeMethodsDarwin;

namespace Aladdin.HASP.Internal
{
	internal class ApiDispatcherDarwin : ApiDispatcher
	{
		public HaspStatus disp_login(int feature_id, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login(int feature_id, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr2 = Marshal.StringToHGlobalAnsi(scope);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr2 = Marshal.StringToHGlobalAnsi(scope);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_logout(int handle)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_logout(handle);
		}

		public HaspStatus disp_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, int length, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, length, intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, buffer, 0, length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref bool buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref byte buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref char buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref double buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref short buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref int buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref long buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ushort buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref uint buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ulong buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref float buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref string buffer)
		{
			IntPtr zero = IntPtr.Zero;
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_read(handle, fileid, offset, 1, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAuto(zero);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(buffer, 0, intPtr, buffer.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, buffer.Length, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, bool buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, char buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, double buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, short buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, int buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, long buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ushort buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, uint buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ulong buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, float buffer)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, string buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToCoTaskMemAuto(buffer);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_write(handle, fileid, offset, 1, ref intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAnsi(intPtr);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_size(int handle, int fileid, ref int size)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_get_size(handle, fileid, ref size);
		}

		public HaspStatus disp_get_rtc(int handle, ref long time)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_get_rtc(handle, ref time);
		}

		public HaspStatus disp_legacy_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_set_rtc(int handle, long new_time)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_set_rtc(handle, new_time);
		}

		public HaspStatus disp_legacy_set_idletime(int handle, short idle_time)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_legacy_set_idletime(handle, idle_time);
		}

		public HaspStatus disp_get_info(string scope, string format, string vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_info(string scope, string format, byte[] vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_sessioninfo(int handle, string format, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(format);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_get_sessioninfo(handle, intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public void disp_free(IntPtr info)
		{
			Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_free(info);
		}

		public HaspStatus disp_update(string update_data, ref string ack_data)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(update_data);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_update(intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				ack_data = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_detach(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			string text = "";
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_detach(detach_action, scope, vendor_code, recipient, ref text);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = text;
			}
			if (!string.IsNullOrEmpty(text))
			{
				text = "";
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_transfer(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethods64.NativeMethods.hasp_transfer(action, scope, vendor_code, recipient, ref info);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_datetime_to_hasptime(day, month, year, hour, minute, second, ref time);
		}

		public HaspStatus disp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second)
		{
			return Aladdin.HASP.Internal.NativeMethodsDarwin.NativeMethods.hasp_hasptime_to_datetime(time, ref day, ref month, ref year, ref hour, ref minute, ref second);
		}

		public HaspStatus disp_set_lib_path(string path)
		{
			return HaspStatus.NotImplemented;
		}
	}
}

-------------------------------------------------------

ApiDispatcherLinux32.cs

using System;
using System.Runtime.InteropServices;
using System.Text;
using Aladdin.HASP.Internal.NativeMethodsLinux32;

namespace Aladdin.HASP.Internal
{
	internal class ApiDispatcherLinux32 : ApiDispatcher
	{
		public HaspStatus disp_login(int feature_id, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login(int feature_id, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr2 = Marshal.StringToHGlobalAnsi(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr2 = Marshal.StringToHGlobalAnsi(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_logout(int handle)
		{
			return NativeMethods.hasp_logout(handle);
		}

		public HaspStatus disp_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, int length, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, length, intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, buffer, 0, length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref bool buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref byte buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref char buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref double buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref short buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref int buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref long buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ushort buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref uint buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ulong buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref float buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref string buffer)
		{
			IntPtr zero = IntPtr.Zero;
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, 1, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAuto(zero);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(buffer, 0, intPtr, buffer.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, buffer.Length, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, bool buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, char buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, double buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, short buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, int buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, long buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ushort buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, uint buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ulong buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, float buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, string buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToCoTaskMemAuto(buffer);
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, 1, ref intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAnsi(intPtr);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_size(int handle, int fileid, ref int size)
		{
			return NativeMethods.hasp_get_size(handle, fileid, ref size);
		}

		public HaspStatus disp_get_rtc(int handle, ref long time)
		{
			return NativeMethods.hasp_get_rtc(handle, ref time);
		}

		public HaspStatus disp_legacy_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_set_rtc(int handle, long new_time)
		{
			return NativeMethods.hasp_legacy_set_rtc(handle, new_time);
		}

		public HaspStatus disp_legacy_set_idletime(int handle, short idle_time)
		{
			return NativeMethods.hasp_legacy_set_idletime(handle, idle_time);
		}

		public HaspStatus disp_get_info(string scope, string format, string vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_info(string scope, string format, byte[] vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_sessioninfo(int handle, string format, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(format);
			HaspStatus haspStatus = NativeMethods.hasp_get_sessioninfo(handle, intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public void disp_free(IntPtr info)
		{
			NativeMethods.hasp_free(info);
		}

		public HaspStatus disp_update(string update_data, ref string ack_data)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(update_data);
			HaspStatus haspStatus = NativeMethods.hasp_update(intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				ack_data = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			string text = "";
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(detach_action, scope, vendor_code, recipient, ref text);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = text;
			}
			if (!string.IsNullOrEmpty(text))
			{
				text = "";
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(action, scope, vendor_code, recipient, ref info);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time)
		{
			return NativeMethods.hasp_datetime_to_hasptime(day, month, year, hour, minute, second, ref time);
		}

		public HaspStatus disp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second)
		{
			return NativeMethods.hasp_hasptime_to_datetime(time, ref day, ref month, ref year, ref hour, ref minute, ref second);
		}

		public HaspStatus disp_set_lib_path(string path)
		{
			return HaspStatus.NotImplemented;
		}
	}
}

--------------------------------------------------------

ApiDispatcherLinux64.cs

using System;
using System.Runtime.InteropServices;
using System.Text;
using Aladdin.HASP.Internal.NativeMethodsLinux64;

namespace Aladdin.HASP.Internal
{
	internal class ApiDispatcherLinux64 : ApiDispatcher
	{
		public HaspStatus disp_login(int feature_id, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login(int feature_id, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_login(feature_id, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, string vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr2 = Marshal.StringToHGlobalAnsi(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_login_scope(int feature_id, string scope, byte[] vendor_code, ref int handle)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr2 = Marshal.StringToHGlobalAnsi(scope);
			HaspStatus haspStatus = NativeMethods.hasp_login_scope(feature_id, intPtr2, intPtr, ref handle);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			return haspStatus;
		}

		public HaspStatus disp_logout(int handle)
		{
			return NativeMethods.hasp_logout(handle);
		}

		public HaspStatus disp_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, int length, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, length, intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, buffer, 0, length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref bool buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref byte buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref char buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref double buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref short buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref int buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref long buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ushort buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref uint buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref ulong buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref float buffer)
		{
			return NativeMethods.hasp_read(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_read(int handle, int fileid, int offset, ref string buffer)
		{
			IntPtr zero = IntPtr.Zero;
			HaspStatus haspStatus = NativeMethods.hasp_read(handle, fileid, offset, 1, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAuto(zero);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte[] buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(buffer.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(buffer, 0, intPtr, buffer.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, buffer.Length, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, bool buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, byte buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 1, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, char buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, double buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, short buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, int buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, long buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ushort buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 2, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, uint buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, ulong buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 8, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, float buffer)
		{
			return NativeMethods.hasp_write(handle, fileid, offset, 4, ref buffer);
		}

		public HaspStatus disp_write(int handle, int fileid, int offset, string buffer)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToCoTaskMemAuto(buffer);
			HaspStatus haspStatus = NativeMethods.hasp_write(handle, fileid, offset, 1, ref intPtr);
			if (haspStatus == HaspStatus.StatusOk)
			{
				buffer = Marshal.PtrToStringAnsi(intPtr);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_size(int handle, int fileid, ref int size)
		{
			return NativeMethods.hasp_get_size(handle, fileid, ref size);
		}

		public HaspStatus disp_get_rtc(int handle, ref long time)
		{
			return NativeMethods.hasp_get_rtc(handle, ref time);
		}

		public HaspStatus disp_legacy_encrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_encrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_encrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, byte[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, double[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, short[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 2);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 2);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, int[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, long[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 8);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 8);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_decrypt(int handle, float[] data)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.AllocHGlobal(data.Length * 4);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.Copy(data, 0, intPtr, data.Length);
			}
			HaspStatus haspStatus = NativeMethods.hasp_legacy_decrypt(handle, intPtr, data.Length * 4);
			if (haspStatus == HaspStatus.StatusOk)
			{
				Marshal.Copy(intPtr, data, 0, data.Length);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_legacy_set_rtc(int handle, long new_time)
		{
			return NativeMethods.hasp_legacy_set_rtc(handle, new_time);
		}

		public HaspStatus disp_legacy_set_idletime(int handle, short idle_time)
		{
			return NativeMethods.hasp_legacy_set_idletime(handle, idle_time);
		}

		public HaspStatus disp_get_info(string scope, string format, string vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_info(string scope, string format, byte[] vendor_code, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(format);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_info(intPtr, intPtr2, intPtr3, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_sessioninfo(int handle, string format, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(format);
			HaspStatus haspStatus = NativeMethods.hasp_get_sessioninfo(handle, intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public void disp_free(IntPtr info)
		{
			NativeMethods.hasp_free(info);
		}

		public HaspStatus disp_update(string update_data, ref string ack_data)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(update_data);
			HaspStatus haspStatus = NativeMethods.hasp_update(intPtr, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				ack_data = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_detach(string detach_action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			string text = "";
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(detach_action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_detach(detach_action, scope, vendor_code, recipient, ref text);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = text;
			}
			if (!string.IsNullOrEmpty(text))
			{
				text = "";
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, string vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(vendor_code);
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(intPtr2, intPtr, intPtr3, intPtr4, ref zero);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_transfer(string action, string scope, byte[] vendor_code, string recipient, ref string info)
		{
			IntPtr intPtr = IntPtr.Zero;
			IntPtr intPtr2 = IntPtr.Zero;
			IntPtr intPtr3 = IntPtr.Zero;
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr4 = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(scope);
			intPtr2 = Marshal.StringToHGlobalAnsi(action);
			intPtr3 = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			intPtr4 = Marshal.StringToHGlobalAnsi(recipient);
			HaspStatus haspStatus = NativeMethods.hasp_transfer(action, scope, vendor_code, recipient, ref info);
			if (haspStatus == HaspStatus.StatusOk)
			{
				info = Marshal.PtrToStringAnsi(zero);
			}
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			if (intPtr2 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr2);
			}
			if (intPtr3 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr3);
			}
			if (zero != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(zero);
			}
			if (intPtr4 != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr4);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, string vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(vendor_code);
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_get_version(ref int major_version, ref int minor_version, ref int build_server, ref int build_number, byte[] vendor_code)
		{
			IntPtr intPtr = IntPtr.Zero;
			intPtr = Marshal.StringToHGlobalAnsi(Encoding.ASCII.GetString(vendor_code));
			HaspStatus haspStatus = NativeMethods.hasp_get_version(ref major_version, ref minor_version, ref build_server, ref build_number, intPtr);
			if (intPtr != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(intPtr);
			}
			return haspStatus;
		}

		public HaspStatus disp_datetime_to_hasptime(int day, int month, int year, int hour, int minute, int second, ref long time)
		{
			return NativeMethods.hasp_datetime_to_hasptime(day, month, year, hour, minute, second, ref time);
		}

		public HaspStatus disp_hasptime_to_datetime(long time, ref int day, ref int month, ref int year, ref int hour, ref int minute, ref int second)
		{
			return NativeMethods.hasp_hasptime_to_datetime(time, ref day, ref month, ref year, ref hour, ref minute, ref second);
		}

		public HaspStatus disp_set_lib_path(string path)
		{
			return HaspStatus.NotImplemented;
		}
	}
}

-----------------------------------------------------------

HedsCrypt.cs

using System;
using System.Security.Cryptography;

namespace HEDS
{
	internal class HedsCrypt
	{
		public void Init(string s)
		{
			this.rsaProvider = new RSACryptoServiceProvider();
			this.rsaProvider.FromXmlString(s);
		}

		public bool VerifyData(byte[] bSource, byte[] bSign)
		{
			return this.rsaProvider.VerifyData(bSource, new SHA1CryptoServiceProvider(), bSign);
		}

		private RSACryptoServiceProvider rsaProvider;
	}
}

---------------------------------------------------------

HedsFile.cs

using System;
using System.Diagnostics;
using System.IO;
using Aladdin.HASP;

namespace HEDS
{
	internal class HedsFile
	{
		public string CheckFile(string str)
		{
			string text = str;
			if (!text.EndsWith("\\"))
			{
				text += "\\";
			}
			text += this.strFileName;
			string text2;
			if (File.Exists(text))
			{
				text2 = text;
			}
			else
			{
				text2 = null;
			}
			return text2;
		}

		public string FindFile(string additionalPath)
		{
			try
			{
				string text = this.CheckFile(Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName));
				if (text != null)
				{
					return text;
				}
				text = this.CheckFile(Path.GetFullPath(Environment.CurrentDirectory));
				if (text != null)
				{
					return text;
				}
				text = this.CheckFile(Path.GetFullPath(Environment.SystemDirectory));
				if (text != null)
				{
					return text;
				}
				text = this.CheckFile(Path.GetFullPath(Environment.GetEnvironmentVariable("windir") + "\\system"));
				if (text != null)
				{
					return text;
				}
				text = this.CheckFile(Path.GetFullPath(Environment.GetEnvironmentVariable("windir")));
				if (text != null)
				{
					return text;
				}
				if (additionalPath != null)
				{
					text = this.CheckFile(additionalPath);
					if (text != null)
					{
						return text;
					}
				}
				string[] array = Environment.GetEnvironmentVariable("path").Split(new char[] { ';' });
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != null && array[i].Length > 0)
					{
						text = this.CheckFile(Path.GetFullPath(array[i]));
						if (text != null)
						{
							return text;
						}
					}
				}
			}
			catch (FileNotFoundException ex)
			{
			}
			return null;
		}

		public HedsFile.heds_status CheckSignature(string strFile, int iGeneration)
		{
			try
			{
				if (strFile == null)
				{
					return HedsFile.heds_status.HEDS_FILE_NOT_FOUND;
				}
				this.hedsSign = new HedsSign();
				FileStream fileStream = new FileStream(strFile, FileMode.Open, FileAccess.Read);
				fileStream.Seek(-4L, SeekOrigin.End);
				BinaryReader binaryReader = new BinaryReader(fileStream);
				int num = binaryReader.ReadInt32();
				if (num > 0 && (long)num < fileStream.Length)
				{
					fileStream.Seek((long)num, SeekOrigin.Begin);
					if (this.hedsSign.LoadSignature(fileStream))
					{
						int num2 = num;
						fileStream.Seek(0L, SeekOrigin.Begin);
						byte[] array = binaryReader.ReadBytes(num2);
						byte[] signature = this.hedsSign.GetSignature(iGeneration);
						if (signature != null)
						{
							if (this.hedsCrypt.VerifyData(array, signature))
							{
								return HedsFile.heds_status.HEDS_STATUS_OK;
							}
							return HedsFile.heds_status.HEDS_SIGNATURE_BROKEN;
						}
					}
				}
			}
			catch (DllBrokenException)
			{
				return HedsFile.heds_status.HEDS_SIGNATURE_BROKEN;
			}
			return HedsFile.heds_status.HEDS_GENERATION_NOT_FOUND;
		}

		public string strFileName;

		public HedsCrypt hedsCrypt;

		private HedsSign hedsSign;

		public enum heds_status
		{
			HEDS_STATUS_OK,
			HEDS_SIGNATURE_BROKEN = -1,
			HEDS_GENERATION_NOT_FOUND = -2,
			HEDS_FILE_NOT_FOUND = -3
		}
	}
}

------------------------------------------------------

HedsSign.cs

using System;
using System.IO;

namespace HEDS
{
	internal class HedsSign
	{
		private bool IsValidMagic()
		{
			return this.hdr.ulMagic == 1396983112;
		}

		public bool LoadSignature(Stream s)
		{
			BinaryReader binaryReader = new BinaryReader(s);
			this.hdr.ulMagic = binaryReader.ReadInt32();
			bool flag;
			if (!this.IsValidMagic())
			{
				flag = false;
			}
			else
			{
				this.hdr.ulCount = binaryReader.ReadInt32();
				if (this.hdr.ulCount > 16)
				{
					flag = false;
				}
				else
				{
					this.sign = new HedsSign.Signature[this.hdr.ulCount];
					for (int i = 0; i < this.hdr.ulCount; i++)
					{
						this.sign[i] = new HedsSign.Signature();
						this.sign[i].iGeneration = binaryReader.ReadInt32();
						this.sign[i].iSignatureLen = binaryReader.ReadInt32();
						this.sign[i].bSignature = new byte[this.sign[i].iSignatureLen];
						binaryReader.Read(this.sign[i].bSignature, 0, this.sign[i].bSignature.Length);
					}
					flag = true;
				}
			}
			return flag;
		}

		public byte[] GetSignature(int iGen)
		{
			for (int i = 0; i < this.hdr.ulCount; i++)
			{
				if (this.sign[i].iGeneration == iGen)
				{
					return this.sign[i].bSignature;
				}
			}
			return null;
		}

		private HedsSign.Header hdr = new HedsSign.Header();

		private HedsSign.Signature[] sign;

		private class Header
		{
			public int ulMagic = 1396983112;

			public int ulCount = 0;
		}

		private class Signature
		{
			public int iGeneration = 0;

			public int iSignatureLen = 0;

			public byte[] bSignature;
		}
	}
}

--------------------------------------------------------------------

AssemblyInfo.cs

using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Permissions;

[assembly: AssemblyVersion("7.3.1.47562")]
[assembly: ComVisible(false)]
[assembly: AssemblyCompany("SafeNet Inc.")]
[assembly: AssemblyTrademark("Sentinel is a trademark of SafeNet Inc.")]
[assembly: AssemblyCopyright(" 2014 SafeNet, Inc. All rights reserved.")]
[assembly: AssemblyProduct("Sentinel LDK Assembly for Microsoft .NET")]
[assembly: AssemblyFileVersion("7.3.1.47562")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyDescription("Sentinel LDK Assembly DLL")]
[assembly: AssemblyTitle("Sentinel LDK Assembly DLL")]
[assembly: CLSCompliant(true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, Execution = true, Action = SecurityAction.LinkDemand, UnmanagedCode = true)]
